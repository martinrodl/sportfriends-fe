var IL = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function jx(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
}
var Nw = { exports: {} }, am = {}, Ng = { exports: {} }, mn = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nx;
function jL() {
  if (nx)
    return mn;
  nx = 1;
  var o = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), m = Symbol.for("react.strict_mode"), w = Symbol.for("react.profiler"), M = Symbol.for("react.provider"), C = Symbol.for("react.context"), W = Symbol.for("react.forward_ref"), z = Symbol.for("react.suspense"), j = Symbol.for("react.memo"), Z = Symbol.for("react.lazy"), H = Symbol.iterator;
  function $(N) {
    return N === null || typeof N != "object" ? null : (N = H && N[H] || N["@@iterator"], typeof N == "function" ? N : null);
  }
  var J = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, oe = Object.assign, ce = {};
  function ue(N, se, xe) {
    this.props = N, this.context = se, this.refs = ce, this.updater = xe || J;
  }
  ue.prototype.isReactComponent = {}, ue.prototype.setState = function(N, se) {
    if (typeof N != "object" && typeof N != "function" && N != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, N, se, "setState");
  }, ue.prototype.forceUpdate = function(N) {
    this.updater.enqueueForceUpdate(this, N, "forceUpdate");
  };
  function Ke() {
  }
  Ke.prototype = ue.prototype;
  function He(N, se, xe) {
    this.props = N, this.context = se, this.refs = ce, this.updater = xe || J;
  }
  var ve = He.prototype = new Ke();
  ve.constructor = He, oe(ve, ue.prototype), ve.isPureReactComponent = !0;
  var ye = Array.isArray, G = Object.prototype.hasOwnProperty, Me = { current: null }, ze = { key: !0, ref: !0, __self: !0, __source: !0 };
  function kt(N, se, xe) {
    var et, je = {}, qe = null, Oe = null;
    if (se != null)
      for (et in se.ref !== void 0 && (Oe = se.ref), se.key !== void 0 && (qe = "" + se.key), se)
        G.call(se, et) && !ze.hasOwnProperty(et) && (je[et] = se[et]);
    var Rt = arguments.length - 2;
    if (Rt === 1)
      je.children = xe;
    else if (1 < Rt) {
      for (var _t = Array(Rt), on = 0; on < Rt; on++)
        _t[on] = arguments[on + 2];
      je.children = _t;
    }
    if (N && N.defaultProps)
      for (et in Rt = N.defaultProps, Rt)
        je[et] === void 0 && (je[et] = Rt[et]);
    return { $$typeof: o, type: N, key: qe, ref: Oe, props: je, _owner: Me.current };
  }
  function It(N, se) {
    return { $$typeof: o, type: N.type, key: se, ref: N.ref, props: N.props, _owner: N._owner };
  }
  function Nt(N) {
    return typeof N == "object" && N !== null && N.$$typeof === o;
  }
  function Xe(N) {
    var se = { "=": "=0", ":": "=2" };
    return "$" + N.replace(/[=:]/g, function(xe) {
      return se[xe];
    });
  }
  var Mt = /\/+/g;
  function ut(N, se) {
    return typeof N == "object" && N !== null && N.key != null ? Xe("" + N.key) : se.toString(36);
  }
  function lt(N, se, xe, et, je) {
    var qe = typeof N;
    (qe === "undefined" || qe === "boolean") && (N = null);
    var Oe = !1;
    if (N === null)
      Oe = !0;
    else
      switch (qe) {
        case "string":
        case "number":
          Oe = !0;
          break;
        case "object":
          switch (N.$$typeof) {
            case o:
            case c:
              Oe = !0;
          }
      }
    if (Oe)
      return Oe = N, je = je(Oe), N = et === "" ? "." + ut(Oe, 0) : et, ye(je) ? (xe = "", N != null && (xe = N.replace(Mt, "$&/") + "/"), lt(je, se, xe, "", function(on) {
        return on;
      })) : je != null && (Nt(je) && (je = It(je, xe + (!je.key || Oe && Oe.key === je.key ? "" : ("" + je.key).replace(Mt, "$&/") + "/") + N)), se.push(je)), 1;
    if (Oe = 0, et = et === "" ? "." : et + ":", ye(N))
      for (var Rt = 0; Rt < N.length; Rt++) {
        qe = N[Rt];
        var _t = et + ut(qe, Rt);
        Oe += lt(qe, se, xe, _t, je);
      }
    else if (_t = $(N), typeof _t == "function")
      for (N = _t.call(N), Rt = 0; !(qe = N.next()).done; )
        qe = qe.value, _t = et + ut(qe, Rt++), Oe += lt(qe, se, xe, _t, je);
    else if (qe === "object")
      throw se = String(N), Error("Objects are not valid as a React child (found: " + (se === "[object Object]" ? "object with keys {" + Object.keys(N).join(", ") + "}" : se) + "). If you meant to render a collection of children, use an array instead.");
    return Oe;
  }
  function tn(N, se, xe) {
    if (N == null)
      return N;
    var et = [], je = 0;
    return lt(N, et, "", "", function(qe) {
      return se.call(xe, qe, je++);
    }), et;
  }
  function vt(N) {
    if (N._status === -1) {
      var se = N._result;
      se = se(), se.then(function(xe) {
        (N._status === 0 || N._status === -1) && (N._status = 1, N._result = xe);
      }, function(xe) {
        (N._status === 0 || N._status === -1) && (N._status = 2, N._result = xe);
      }), N._status === -1 && (N._status = 0, N._result = se);
    }
    if (N._status === 1)
      return N._result.default;
    throw N._result;
  }
  var Ne = { current: null }, le = { transition: null }, Je = { ReactCurrentDispatcher: Ne, ReactCurrentBatchConfig: le, ReactCurrentOwner: Me };
  return mn.Children = { map: tn, forEach: function(N, se, xe) {
    tn(N, function() {
      se.apply(this, arguments);
    }, xe);
  }, count: function(N) {
    var se = 0;
    return tn(N, function() {
      se++;
    }), se;
  }, toArray: function(N) {
    return tn(N, function(se) {
      return se;
    }) || [];
  }, only: function(N) {
    if (!Nt(N))
      throw Error("React.Children.only expected to receive a single React element child.");
    return N;
  } }, mn.Component = ue, mn.Fragment = d, mn.Profiler = w, mn.PureComponent = He, mn.StrictMode = m, mn.Suspense = z, mn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Je, mn.cloneElement = function(N, se, xe) {
    if (N == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + N + ".");
    var et = oe({}, N.props), je = N.key, qe = N.ref, Oe = N._owner;
    if (se != null) {
      if (se.ref !== void 0 && (qe = se.ref, Oe = Me.current), se.key !== void 0 && (je = "" + se.key), N.type && N.type.defaultProps)
        var Rt = N.type.defaultProps;
      for (_t in se)
        G.call(se, _t) && !ze.hasOwnProperty(_t) && (et[_t] = se[_t] === void 0 && Rt !== void 0 ? Rt[_t] : se[_t]);
    }
    var _t = arguments.length - 2;
    if (_t === 1)
      et.children = xe;
    else if (1 < _t) {
      Rt = Array(_t);
      for (var on = 0; on < _t; on++)
        Rt[on] = arguments[on + 2];
      et.children = Rt;
    }
    return { $$typeof: o, type: N.type, key: je, ref: qe, props: et, _owner: Oe };
  }, mn.createContext = function(N) {
    return N = { $$typeof: C, _currentValue: N, _currentValue2: N, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, N.Provider = { $$typeof: M, _context: N }, N.Consumer = N;
  }, mn.createElement = kt, mn.createFactory = function(N) {
    var se = kt.bind(null, N);
    return se.type = N, se;
  }, mn.createRef = function() {
    return { current: null };
  }, mn.forwardRef = function(N) {
    return { $$typeof: W, render: N };
  }, mn.isValidElement = Nt, mn.lazy = function(N) {
    return { $$typeof: Z, _payload: { _status: -1, _result: N }, _init: vt };
  }, mn.memo = function(N, se) {
    return { $$typeof: j, type: N, compare: se === void 0 ? null : se };
  }, mn.startTransition = function(N) {
    var se = le.transition;
    le.transition = {};
    try {
      N();
    } finally {
      le.transition = se;
    }
  }, mn.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, mn.useCallback = function(N, se) {
    return Ne.current.useCallback(N, se);
  }, mn.useContext = function(N) {
    return Ne.current.useContext(N);
  }, mn.useDebugValue = function() {
  }, mn.useDeferredValue = function(N) {
    return Ne.current.useDeferredValue(N);
  }, mn.useEffect = function(N, se) {
    return Ne.current.useEffect(N, se);
  }, mn.useId = function() {
    return Ne.current.useId();
  }, mn.useImperativeHandle = function(N, se, xe) {
    return Ne.current.useImperativeHandle(N, se, xe);
  }, mn.useInsertionEffect = function(N, se) {
    return Ne.current.useInsertionEffect(N, se);
  }, mn.useLayoutEffect = function(N, se) {
    return Ne.current.useLayoutEffect(N, se);
  }, mn.useMemo = function(N, se) {
    return Ne.current.useMemo(N, se);
  }, mn.useReducer = function(N, se, xe) {
    return Ne.current.useReducer(N, se, xe);
  }, mn.useRef = function(N) {
    return Ne.current.useRef(N);
  }, mn.useState = function(N) {
    return Ne.current.useState(N);
  }, mn.useSyncExternalStore = function(N, se, xe) {
    return Ne.current.useSyncExternalStore(N, se, xe);
  }, mn.useTransition = function() {
    return Ne.current.useTransition();
  }, mn.version = "18.2.0", mn;
}
var lm = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
lm.exports;
var rx;
function FL() {
  return rx || (rx = 1, function(o, c) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var d = "18.2.0", m = Symbol.for("react.element"), w = Symbol.for("react.portal"), M = Symbol.for("react.fragment"), C = Symbol.for("react.strict_mode"), W = Symbol.for("react.profiler"), z = Symbol.for("react.provider"), j = Symbol.for("react.context"), Z = Symbol.for("react.forward_ref"), H = Symbol.for("react.suspense"), $ = Symbol.for("react.suspense_list"), J = Symbol.for("react.memo"), oe = Symbol.for("react.lazy"), ce = Symbol.for("react.offscreen"), ue = Symbol.iterator, Ke = "@@iterator";
      function He(b) {
        if (b === null || typeof b != "object")
          return null;
        var A = ue && b[ue] || b[Ke];
        return typeof A == "function" ? A : null;
      }
      var ve = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, ye = {
        transition: null
      }, G = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, Me = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, ze = {}, kt = null;
      function It(b) {
        kt = b;
      }
      ze.setExtraStackFrame = function(b) {
        kt = b;
      }, ze.getCurrentStack = null, ze.getStackAddendum = function() {
        var b = "";
        kt && (b += kt);
        var A = ze.getCurrentStack;
        return A && (b += A() || ""), b;
      };
      var Nt = !1, Xe = !1, Mt = !1, ut = !1, lt = !1, tn = {
        ReactCurrentDispatcher: ve,
        ReactCurrentBatchConfig: ye,
        ReactCurrentOwner: Me
      };
      tn.ReactDebugCurrentFrame = ze, tn.ReactCurrentActQueue = G;
      function vt(b) {
        {
          for (var A = arguments.length, te = new Array(A > 1 ? A - 1 : 0), fe = 1; fe < A; fe++)
            te[fe - 1] = arguments[fe];
          le("warn", b, te);
        }
      }
      function Ne(b) {
        {
          for (var A = arguments.length, te = new Array(A > 1 ? A - 1 : 0), fe = 1; fe < A; fe++)
            te[fe - 1] = arguments[fe];
          le("error", b, te);
        }
      }
      function le(b, A, te) {
        {
          var fe = tn.ReactDebugCurrentFrame, Ce = fe.getStackAddendum();
          Ce !== "" && (A += "%s", te = te.concat([Ce]));
          var St = te.map(function(Le) {
            return String(Le);
          });
          St.unshift("Warning: " + A), Function.prototype.apply.call(console[b], console, St);
        }
      }
      var Je = {};
      function N(b, A) {
        {
          var te = b.constructor, fe = te && (te.displayName || te.name) || "ReactClass", Ce = fe + "." + A;
          if (Je[Ce])
            return;
          Ne("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", A, fe), Je[Ce] = !0;
        }
      }
      var se = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(b) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(b, A, te) {
          N(b, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(b, A, te, fe) {
          N(b, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(b, A, te, fe) {
          N(b, "setState");
        }
      }, xe = Object.assign, et = {};
      Object.freeze(et);
      function je(b, A, te) {
        this.props = b, this.context = A, this.refs = et, this.updater = te || se;
      }
      je.prototype.isReactComponent = {}, je.prototype.setState = function(b, A) {
        if (typeof b != "object" && typeof b != "function" && b != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, b, A, "setState");
      }, je.prototype.forceUpdate = function(b) {
        this.updater.enqueueForceUpdate(this, b, "forceUpdate");
      };
      {
        var qe = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, Oe = function(b, A) {
          Object.defineProperty(je.prototype, b, {
            get: function() {
              vt("%s(...) is deprecated in plain JavaScript React classes. %s", A[0], A[1]);
            }
          });
        };
        for (var Rt in qe)
          qe.hasOwnProperty(Rt) && Oe(Rt, qe[Rt]);
      }
      function _t() {
      }
      _t.prototype = je.prototype;
      function on(b, A, te) {
        this.props = b, this.context = A, this.refs = et, this.updater = te || se;
      }
      var Sr = on.prototype = new _t();
      Sr.constructor = on, xe(Sr, je.prototype), Sr.isPureReactComponent = !0;
      function ur() {
        var b = {
          current: null
        };
        return Object.seal(b), b;
      }
      var Ue = Array.isArray;
      function yn(b) {
        return Ue(b);
      }
      function Ie(b) {
        {
          var A = typeof Symbol == "function" && Symbol.toStringTag, te = A && b[Symbol.toStringTag] || b.constructor.name || "Object";
          return te;
        }
      }
      function zn(b) {
        try {
          return Xn(b), !1;
        } catch {
          return !0;
        }
      }
      function Xn(b) {
        return "" + b;
      }
      function Bn(b) {
        if (zn(b))
          return Ne("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ie(b)), Xn(b);
      }
      function Hr(b, A, te) {
        var fe = b.displayName;
        if (fe)
          return fe;
        var Ce = A.displayName || A.name || "";
        return Ce !== "" ? te + "(" + Ce + ")" : te;
      }
      function ki(b) {
        return b.displayName || "Context";
      }
      function Dr(b) {
        if (b == null)
          return null;
        if (typeof b.tag == "number" && Ne("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
          return b.displayName || b.name || null;
        if (typeof b == "string")
          return b;
        switch (b) {
          case M:
            return "Fragment";
          case w:
            return "Portal";
          case W:
            return "Profiler";
          case C:
            return "StrictMode";
          case H:
            return "Suspense";
          case $:
            return "SuspenseList";
        }
        if (typeof b == "object")
          switch (b.$$typeof) {
            case j:
              var A = b;
              return ki(A) + ".Consumer";
            case z:
              var te = b;
              return ki(te._context) + ".Provider";
            case Z:
              return Hr(b, b.render, "ForwardRef");
            case J:
              var fe = b.displayName || null;
              return fe !== null ? fe : Dr(b.type) || "Memo";
            case oe: {
              var Ce = b, St = Ce._payload, Le = Ce._init;
              try {
                return Dr(Le(St));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var zr = Object.prototype.hasOwnProperty, fi = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Br, Yi, Yr;
      Yr = {};
      function Xr(b) {
        if (zr.call(b, "ref")) {
          var A = Object.getOwnPropertyDescriptor(b, "ref").get;
          if (A && A.isReactWarning)
            return !1;
        }
        return b.ref !== void 0;
      }
      function er(b) {
        if (zr.call(b, "key")) {
          var A = Object.getOwnPropertyDescriptor(b, "key").get;
          if (A && A.isReactWarning)
            return !1;
        }
        return b.key !== void 0;
      }
      function Jr(b, A) {
        var te = function() {
          Br || (Br = !0, Ne("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        te.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: te,
          configurable: !0
        });
      }
      function Qa(b, A) {
        var te = function() {
          Yi || (Yi = !0, Ne("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        te.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: te,
          configurable: !0
        });
      }
      function Oi(b) {
        if (typeof b.ref == "string" && Me.current && b.__self && Me.current.stateNode !== b.__self) {
          var A = Dr(Me.current.type);
          Yr[A] || (Ne('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', A, b.ref), Yr[A] = !0);
        }
      }
      var De = function(b, A, te, fe, Ce, St, Le) {
        var gt = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: m,
          // Built-in properties that belong on the element
          type: b,
          key: A,
          ref: te,
          props: Le,
          // Record the component responsible for creating this element.
          _owner: St
        };
        return gt._store = {}, Object.defineProperty(gt._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(gt, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: fe
        }), Object.defineProperty(gt, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Ce
        }), Object.freeze && (Object.freeze(gt.props), Object.freeze(gt)), gt;
      };
      function ft(b, A, te) {
        var fe, Ce = {}, St = null, Le = null, gt = null, qt = null;
        if (A != null) {
          Xr(A) && (Le = A.ref, Oi(A)), er(A) && (Bn(A.key), St = "" + A.key), gt = A.__self === void 0 ? null : A.__self, qt = A.__source === void 0 ? null : A.__source;
          for (fe in A)
            zr.call(A, fe) && !fi.hasOwnProperty(fe) && (Ce[fe] = A[fe]);
        }
        var an = arguments.length - 2;
        if (an === 1)
          Ce.children = te;
        else if (an > 1) {
          for (var jn = Array(an), Xt = 0; Xt < an; Xt++)
            jn[Xt] = arguments[Xt + 2];
          Object.freeze && Object.freeze(jn), Ce.children = jn;
        }
        if (b && b.defaultProps) {
          var Fn = b.defaultProps;
          for (fe in Fn)
            Ce[fe] === void 0 && (Ce[fe] = Fn[fe]);
        }
        if (St || Le) {
          var Hn = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          St && Jr(Ce, Hn), Le && Qa(Ce, Hn);
        }
        return De(b, St, Le, gt, qt, Me.current, Ce);
      }
      function Yt(b, A) {
        var te = De(b.type, A, b.ref, b._self, b._source, b._owner, b.props);
        return te;
      }
      function dn(b, A, te) {
        if (b == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + b + ".");
        var fe, Ce = xe({}, b.props), St = b.key, Le = b.ref, gt = b._self, qt = b._source, an = b._owner;
        if (A != null) {
          Xr(A) && (Le = A.ref, an = Me.current), er(A) && (Bn(A.key), St = "" + A.key);
          var jn;
          b.type && b.type.defaultProps && (jn = b.type.defaultProps);
          for (fe in A)
            zr.call(A, fe) && !fi.hasOwnProperty(fe) && (A[fe] === void 0 && jn !== void 0 ? Ce[fe] = jn[fe] : Ce[fe] = A[fe]);
        }
        var Xt = arguments.length - 2;
        if (Xt === 1)
          Ce.children = te;
        else if (Xt > 1) {
          for (var Fn = Array(Xt), Hn = 0; Hn < Xt; Hn++)
            Fn[Hn] = arguments[Hn + 2];
          Ce.children = Fn;
        }
        return De(b.type, St, Le, gt, qt, an, Ce);
      }
      function gn(b) {
        return typeof b == "object" && b !== null && b.$$typeof === m;
      }
      var dr = ".", Un = ":";
      function ei(b) {
        var A = /[=:]/g, te = {
          "=": "=0",
          ":": "=2"
        }, fe = b.replace(A, function(Ce) {
          return te[Ce];
        });
        return "$" + fe;
      }
      var bn = !1, ti = /\/+/g;
      function _n(b) {
        return b.replace(ti, "$&/");
      }
      function Sn(b, A) {
        return typeof b == "object" && b !== null && b.key != null ? (Bn(b.key), ei("" + b.key)) : A.toString(36);
      }
      function Ma(b, A, te, fe, Ce) {
        var St = typeof b;
        (St === "undefined" || St === "boolean") && (b = null);
        var Le = !1;
        if (b === null)
          Le = !0;
        else
          switch (St) {
            case "string":
            case "number":
              Le = !0;
              break;
            case "object":
              switch (b.$$typeof) {
                case m:
                case w:
                  Le = !0;
              }
          }
        if (Le) {
          var gt = b, qt = Ce(gt), an = fe === "" ? dr + Sn(gt, 0) : fe;
          if (yn(qt)) {
            var jn = "";
            an != null && (jn = _n(an) + "/"), Ma(qt, A, jn, "", function(_f) {
              return _f;
            });
          } else
            qt != null && (gn(qt) && (qt.key && (!gt || gt.key !== qt.key) && Bn(qt.key), qt = Yt(
              qt,
              // Keep both the (mapped) and old keys if they differ, just as
              // traverseAllChildren used to do for objects as children
              te + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              (qt.key && (!gt || gt.key !== qt.key) ? (
                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                // eslint-disable-next-line react-internal/safe-string-coercion
                _n("" + qt.key) + "/"
              ) : "") + an
            )), A.push(qt));
          return 1;
        }
        var Xt, Fn, Hn = 0, Ht = fe === "" ? dr : fe + Un;
        if (yn(b))
          for (var lo = 0; lo < b.length; lo++)
            Xt = b[lo], Fn = Ht + Sn(Xt, lo), Hn += Ma(Xt, A, te, Fn, Ce);
        else {
          var As = He(b);
          if (typeof As == "function") {
            var zs = b;
            As === zs.entries && (bn || vt("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), bn = !0);
            for (var gf = As.call(zs), oa, yu = 0; !(oa = gf.next()).done; )
              Xt = oa.value, Fn = Ht + Sn(Xt, yu++), Hn += Ma(Xt, A, te, Fn, Ce);
          } else if (St === "object") {
            var al = String(b);
            throw new Error("Objects are not valid as a React child (found: " + (al === "[object Object]" ? "object with keys {" + Object.keys(b).join(", ") + "}" : al) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return Hn;
      }
      function ia(b, A, te) {
        if (b == null)
          return b;
        var fe = [], Ce = 0;
        return Ma(b, fe, "", "", function(St) {
          return A.call(te, St, Ce++);
        }), fe;
      }
      function ns(b) {
        var A = 0;
        return ia(b, function() {
          A++;
        }), A;
      }
      function Ls(b, A, te) {
        ia(b, function() {
          A.apply(this, arguments);
        }, te);
      }
      function hu(b) {
        return ia(b, function(A) {
          return A;
        }) || [];
      }
      function Lo(b) {
        if (!gn(b))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return b;
      }
      function qa(b) {
        var A = {
          $$typeof: j,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: b,
          _currentValue2: b,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        A.Provider = {
          $$typeof: z,
          _context: A
        };
        var te = !1, fe = !1, Ce = !1;
        {
          var St = {
            $$typeof: j,
            _context: A
          };
          Object.defineProperties(St, {
            Provider: {
              get: function() {
                return fe || (fe = !0, Ne("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), A.Provider;
              },
              set: function(Le) {
                A.Provider = Le;
              }
            },
            _currentValue: {
              get: function() {
                return A._currentValue;
              },
              set: function(Le) {
                A._currentValue = Le;
              }
            },
            _currentValue2: {
              get: function() {
                return A._currentValue2;
              },
              set: function(Le) {
                A._currentValue2 = Le;
              }
            },
            _threadCount: {
              get: function() {
                return A._threadCount;
              },
              set: function(Le) {
                A._threadCount = Le;
              }
            },
            Consumer: {
              get: function() {
                return te || (te = !0, Ne("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), A.Consumer;
              }
            },
            displayName: {
              get: function() {
                return A.displayName;
              },
              set: function(Le) {
                Ce || (vt("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Le), Ce = !0);
              }
            }
          }), A.Consumer = St;
        }
        return A._currentRenderer = null, A._currentRenderer2 = null, A;
      }
      var Vi = -1, Ka = 0, Wi = 1, Xa = 2;
      function tr(b) {
        if (b._status === Vi) {
          var A = b._result, te = A();
          if (te.then(function(St) {
            if (b._status === Ka || b._status === Vi) {
              var Le = b;
              Le._status = Wi, Le._result = St;
            }
          }, function(St) {
            if (b._status === Ka || b._status === Vi) {
              var Le = b;
              Le._status = Xa, Le._result = St;
            }
          }), b._status === Vi) {
            var fe = b;
            fe._status = Ka, fe._result = te;
          }
        }
        if (b._status === Wi) {
          var Ce = b._result;
          return Ce === void 0 && Ne(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, Ce), "default" in Ce || Ne(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, Ce), Ce.default;
        } else
          throw b._result;
      }
      function We(b) {
        var A = {
          // We use these fields to store the result.
          _status: Vi,
          _result: b
        }, te = {
          $$typeof: oe,
          _payload: A,
          _init: tr
        };
        {
          var fe, Ce;
          Object.defineProperties(te, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return fe;
              },
              set: function(St) {
                Ne("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), fe = St, Object.defineProperty(te, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return Ce;
              },
              set: function(St) {
                Ne("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Ce = St, Object.defineProperty(te, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return te;
      }
      function Ra(b) {
        b != null && b.$$typeof === J ? Ne("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof b != "function" ? Ne("forwardRef requires a render function but was given %s.", b === null ? "null" : typeof b) : b.length !== 0 && b.length !== 2 && Ne("forwardRef render functions accept exactly two parameters: props and ref. %s", b.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), b != null && (b.defaultProps != null || b.propTypes != null) && Ne("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var A = {
          $$typeof: Z,
          render: b
        };
        {
          var te;
          Object.defineProperty(A, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return te;
            },
            set: function(fe) {
              te = fe, !b.name && !b.displayName && (b.displayName = fe);
            }
          });
        }
        return A;
      }
      var U;
      U = Symbol.for("react.module.reference");
      function _e(b) {
        return !!(typeof b == "string" || typeof b == "function" || b === M || b === W || lt || b === C || b === H || b === $ || ut || b === ce || Nt || Xe || Mt || typeof b == "object" && b !== null && (b.$$typeof === oe || b.$$typeof === J || b.$$typeof === z || b.$$typeof === j || b.$$typeof === Z || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        b.$$typeof === U || b.getModuleId !== void 0));
      }
      function ke(b, A) {
        _e(b) || Ne("memo: The first argument must be a component. Instead received: %s", b === null ? "null" : typeof b);
        var te = {
          $$typeof: J,
          type: b,
          compare: A === void 0 ? null : A
        };
        {
          var fe;
          Object.defineProperty(te, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return fe;
            },
            set: function(Ce) {
              fe = Ce, !b.name && !b.displayName && (b.displayName = Ce);
            }
          });
        }
        return te;
      }
      function Be() {
        var b = ve.current;
        return b === null && Ne(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), b;
      }
      function Ut(b) {
        var A = Be();
        if (b._context !== void 0) {
          var te = b._context;
          te.Consumer === b ? Ne("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : te.Provider === b && Ne("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return A.useContext(b);
      }
      function $t(b) {
        var A = Be();
        return A.useState(b);
      }
      function jt(b, A, te) {
        var fe = Be();
        return fe.useReducer(b, A, te);
      }
      function mt(b) {
        var A = Be();
        return A.useRef(b);
      }
      function wr(b, A) {
        var te = Be();
        return te.useEffect(b, A);
      }
      function Yn(b, A) {
        var te = Be();
        return te.useInsertionEffect(b, A);
      }
      function Vn(b, A) {
        var te = Be();
        return te.useLayoutEffect(b, A);
      }
      function Ur(b, A) {
        var te = Be();
        return te.useCallback(b, A);
      }
      function Ja(b, A) {
        var te = Be();
        return te.useMemo(b, A);
      }
      function No(b, A, te) {
        var fe = Be();
        return fe.useImperativeHandle(b, A, te);
      }
      function cn(b, A) {
        {
          var te = Be();
          return te.useDebugValue(b, A);
        }
      }
      function yf() {
        var b = Be();
        return b.useTransition();
      }
      function Da(b) {
        var A = Be();
        return A.useDeferredValue(b);
      }
      function Gt() {
        var b = Be();
        return b.useId();
      }
      function eo(b, A, te) {
        var fe = Be();
        return fe.useSyncExternalStore(b, A, te);
      }
      var to = 0, no, Po, di, Ao, Pt, In, rs;
      function zo() {
      }
      zo.__reactDisabledLog = !0;
      function ka() {
        {
          if (to === 0) {
            no = console.log, Po = console.info, di = console.warn, Ao = console.error, Pt = console.group, In = console.groupCollapsed, rs = console.groupEnd;
            var b = {
              configurable: !0,
              enumerable: !0,
              value: zo,
              writable: !0
            };
            Object.defineProperties(console, {
              info: b,
              log: b,
              warn: b,
              error: b,
              group: b,
              groupCollapsed: b,
              groupEnd: b
            });
          }
          to++;
        }
      }
      function ro() {
        {
          if (to--, to === 0) {
            var b = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: xe({}, b, {
                value: no
              }),
              info: xe({}, b, {
                value: Po
              }),
              warn: xe({}, b, {
                value: di
              }),
              error: xe({}, b, {
                value: Ao
              }),
              group: xe({}, b, {
                value: Pt
              }),
              groupCollapsed: xe({}, b, {
                value: In
              }),
              groupEnd: xe({}, b, {
                value: rs
              })
            });
          }
          to < 0 && Ne("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var xt = tn.ReactCurrentDispatcher, sn;
      function io(b, A, te) {
        {
          if (sn === void 0)
            try {
              throw Error();
            } catch (Ce) {
              var fe = Ce.stack.trim().match(/\n( *(at )?)/);
              sn = fe && fe[1] || "";
            }
          return `
` + sn + b;
        }
      }
      var Oa = !1, kr;
      {
        var pu = typeof WeakMap == "function" ? WeakMap : Map;
        kr = new pu();
      }
      function Uo(b, A) {
        if (!b || Oa)
          return "";
        {
          var te = kr.get(b);
          if (te !== void 0)
            return te;
        }
        var fe;
        Oa = !0;
        var Ce = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var St;
        St = xt.current, xt.current = null, ka();
        try {
          if (A) {
            var Le = function() {
              throw Error();
            };
            if (Object.defineProperty(Le.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Le, []);
              } catch (Ht) {
                fe = Ht;
              }
              Reflect.construct(b, [], Le);
            } else {
              try {
                Le.call();
              } catch (Ht) {
                fe = Ht;
              }
              b.call(Le.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Ht) {
              fe = Ht;
            }
            b();
          }
        } catch (Ht) {
          if (Ht && fe && typeof Ht.stack == "string") {
            for (var gt = Ht.stack.split(`
`), qt = fe.stack.split(`
`), an = gt.length - 1, jn = qt.length - 1; an >= 1 && jn >= 0 && gt[an] !== qt[jn]; )
              jn--;
            for (; an >= 1 && jn >= 0; an--, jn--)
              if (gt[an] !== qt[jn]) {
                if (an !== 1 || jn !== 1)
                  do
                    if (an--, jn--, jn < 0 || gt[an] !== qt[jn]) {
                      var Xt = `
` + gt[an].replace(" at new ", " at ");
                      return b.displayName && Xt.includes("<anonymous>") && (Xt = Xt.replace("<anonymous>", b.displayName)), typeof b == "function" && kr.set(b, Xt), Xt;
                    }
                  while (an >= 1 && jn >= 0);
                break;
              }
          }
        } finally {
          Oa = !1, xt.current = St, ro(), Error.prepareStackTrace = Ce;
        }
        var Fn = b ? b.displayName || b.name : "", Hn = Fn ? io(Fn) : "";
        return typeof b == "function" && kr.set(b, Hn), Hn;
      }
      function hi(b, A, te) {
        return Uo(b, !1);
      }
      function lr(b) {
        var A = b.prototype;
        return !!(A && A.isReactComponent);
      }
      function ni(b, A, te) {
        if (b == null)
          return "";
        if (typeof b == "function")
          return Uo(b, lr(b));
        if (typeof b == "string")
          return io(b);
        switch (b) {
          case H:
            return io("Suspense");
          case $:
            return io("SuspenseList");
        }
        if (typeof b == "object")
          switch (b.$$typeof) {
            case Z:
              return hi(b.render);
            case J:
              return ni(b.type, A, te);
            case oe: {
              var fe = b, Ce = fe._payload, St = fe._init;
              try {
                return ni(St(Ce), A, te);
              } catch {
              }
            }
          }
        return "";
      }
      var nn = {}, ao = tn.ReactDebugCurrentFrame;
      function Io(b) {
        if (b) {
          var A = b._owner, te = ni(b.type, b._source, A ? A.type : null);
          ao.setExtraStackFrame(te);
        } else
          ao.setExtraStackFrame(null);
      }
      function oo(b, A, te, fe, Ce) {
        {
          var St = Function.call.bind(zr);
          for (var Le in b)
            if (St(b, Le)) {
              var gt = void 0;
              try {
                if (typeof b[Le] != "function") {
                  var qt = Error((fe || "React class") + ": " + te + " type `" + Le + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[Le] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw qt.name = "Invariant Violation", qt;
                }
                gt = b[Le](A, Le, fe, te, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (an) {
                gt = an;
              }
              gt && !(gt instanceof Error) && (Io(Ce), Ne("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", fe || "React class", te, Le, typeof gt), Io(null)), gt instanceof Error && !(gt.message in nn) && (nn[gt.message] = !0, Io(Ce), Ne("Failed %s type: %s", te, gt.message), Io(null));
            }
        }
      }
      function rn(b) {
        if (b) {
          var A = b._owner, te = ni(b.type, b._source, A ? A.type : null);
          It(te);
        } else
          It(null);
      }
      var is;
      is = !1;
      function jo() {
        if (Me.current) {
          var b = Dr(Me.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
      function Ot(b) {
        if (b !== void 0) {
          var A = b.fileName.replace(/^.*[\\\/]/, ""), te = b.lineNumber;
          return `

Check your code at ` + A + ":" + te + ".";
        }
        return "";
      }
      function Fo(b) {
        return b != null ? Ot(b.__source) : "";
      }
      var Wn = {};
      function pi(b) {
        var A = jo();
        if (!A) {
          var te = typeof b == "string" ? b : b.displayName || b.name;
          te && (A = `

Check the top-level render call using <` + te + ">.");
        }
        return A;
      }
      function Vr(b, A) {
        if (!(!b._store || b._store.validated || b.key != null)) {
          b._store.validated = !0;
          var te = pi(A);
          if (!Wn[te]) {
            Wn[te] = !0;
            var fe = "";
            b && b._owner && b._owner !== Me.current && (fe = " It was passed a child from " + Dr(b._owner.type) + "."), rn(b), Ne('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', te, fe), rn(null);
          }
        }
      }
      function as(b, A) {
        if (typeof b == "object") {
          if (yn(b))
            for (var te = 0; te < b.length; te++) {
              var fe = b[te];
              gn(fe) && Vr(fe, A);
            }
          else if (gn(b))
            b._store && (b._store.validated = !0);
          else if (b) {
            var Ce = He(b);
            if (typeof Ce == "function" && Ce !== b.entries)
              for (var St = Ce.call(b), Le; !(Le = St.next()).done; )
                gn(Le.value) && Vr(Le.value, A);
          }
        }
      }
      function nt(b) {
        {
          var A = b.type;
          if (A == null || typeof A == "string")
            return;
          var te;
          if (typeof A == "function")
            te = A.propTypes;
          else if (typeof A == "object" && (A.$$typeof === Z || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          A.$$typeof === J))
            te = A.propTypes;
          else
            return;
          if (te) {
            var fe = Dr(A);
            oo(te, b.props, "prop", fe, b);
          } else if (A.PropTypes !== void 0 && !is) {
            is = !0;
            var Ce = Dr(A);
            Ne("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ce || "Unknown");
          }
          typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && Ne("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function Qt(b) {
        {
          for (var A = Object.keys(b.props), te = 0; te < A.length; te++) {
            var fe = A[te];
            if (fe !== "children" && fe !== "key") {
              rn(b), Ne("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", fe), rn(null);
              break;
            }
          }
          b.ref !== null && (rn(b), Ne("Invalid attribute `ref` supplied to `React.Fragment`."), rn(null));
        }
      }
      function Mn(b, A, te) {
        var fe = _e(b);
        if (!fe) {
          var Ce = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (Ce += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var St = Fo(A);
          St ? Ce += St : Ce += jo();
          var Le;
          b === null ? Le = "null" : yn(b) ? Le = "array" : b !== void 0 && b.$$typeof === m ? (Le = "<" + (Dr(b.type) || "Unknown") + " />", Ce = " Did you accidentally export a JSX literal instead of a component?") : Le = typeof b, Ne("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Le, Ce);
        }
        var gt = ft.apply(this, arguments);
        if (gt == null)
          return gt;
        if (fe)
          for (var qt = 2; qt < arguments.length; qt++)
            as(arguments[qt], b);
        return b === M ? Qt(gt) : nt(gt), gt;
      }
      var vi = !1;
      function Er(b) {
        var A = Mn.bind(null, b);
        return A.type = b, vi || (vi = !0, vt("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(A, "type", {
          enumerable: !1,
          get: function() {
            return vt("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: b
            }), b;
          }
        }), A;
      }
      function aa(b, A, te) {
        for (var fe = dn.apply(this, arguments), Ce = 2; Ce < arguments.length; Ce++)
          as(arguments[Ce], fe.type);
        return nt(fe), fe;
      }
      function vu(b, A) {
        var te = ye.transition;
        ye.transition = {};
        var fe = ye.transition;
        ye.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          b();
        } finally {
          if (ye.transition = te, te === null && fe._updatedFibers) {
            var Ce = fe._updatedFibers.size;
            Ce > 10 && vt("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), fe._updatedFibers.clear();
          }
        }
      }
      var mi = !1, so = null;
      function os(b) {
        if (so === null)
          try {
            var A = ("require" + Math.random()).slice(0, 7), te = o && o[A];
            so = te.call(o, "timers").setImmediate;
          } catch {
            so = function(Ce) {
              mi === !1 && (mi = !0, typeof MessageChannel > "u" && Ne("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var St = new MessageChannel();
              St.port1.onmessage = Ce, St.port2.postMessage(void 0);
            };
          }
        return so(b);
      }
      var Dn = 0, Li = !1;
      function Ho(b) {
        {
          var A = Dn;
          Dn++, G.current === null && (G.current = []);
          var te = G.isBatchingLegacy, fe;
          try {
            if (G.isBatchingLegacy = !0, fe = b(), !te && G.didScheduleLegacyUpdate) {
              var Ce = G.current;
              Ce !== null && (G.didScheduleLegacyUpdate = !1, uo(Ce));
            }
          } catch (Fn) {
            throw Zi(A), Fn;
          } finally {
            G.isBatchingLegacy = te;
          }
          if (fe !== null && typeof fe == "object" && typeof fe.then == "function") {
            var St = fe, Le = !1, gt = {
              then: function(Fn, Hn) {
                Le = !0, St.then(function(Ht) {
                  Zi(A), Dn === 0 ? mu(Ht, Fn, Hn) : Fn(Ht);
                }, function(Ht) {
                  Zi(A), Hn(Ht);
                });
              }
            };
            return !Li && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              Le || (Li = !0, Ne("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), gt;
          } else {
            var qt = fe;
            if (Zi(A), Dn === 0) {
              var an = G.current;
              an !== null && (uo(an), G.current = null);
              var jn = {
                then: function(Fn, Hn) {
                  G.current === null ? (G.current = [], mu(qt, Fn, Hn)) : Fn(qt);
                }
              };
              return jn;
            } else {
              var Xt = {
                then: function(Fn, Hn) {
                  Fn(qt);
                }
              };
              return Xt;
            }
          }
        }
      }
      function Zi(b) {
        b !== Dn - 1 && Ne("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), Dn = b;
      }
      function mu(b, A, te) {
        {
          var fe = G.current;
          if (fe !== null)
            try {
              uo(fe), os(function() {
                fe.length === 0 ? (G.current = null, A(b)) : mu(b, A, te);
              });
            } catch (Ce) {
              te(Ce);
            }
          else
            A(b);
        }
      }
      var Bo = !1;
      function uo(b) {
        if (!Bo) {
          Bo = !0;
          var A = 0;
          try {
            for (; A < b.length; A++) {
              var te = b[A];
              do
                te = te(!0);
              while (te !== null);
            }
            b.length = 0;
          } catch (fe) {
            throw b = b.slice(A + 1), fe;
          } finally {
            Bo = !1;
          }
        }
      }
      var Ns = Mn, Ps = aa, Kt = Er, La = {
        map: ia,
        forEach: Ls,
        count: ns,
        toArray: hu,
        only: Lo
      };
      c.Children = La, c.Component = je, c.Fragment = M, c.Profiler = W, c.PureComponent = on, c.StrictMode = C, c.Suspense = H, c.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tn, c.cloneElement = Ps, c.createContext = qa, c.createElement = Ns, c.createFactory = Kt, c.createRef = ur, c.forwardRef = Ra, c.isValidElement = gn, c.lazy = We, c.memo = ke, c.startTransition = vu, c.unstable_act = Ho, c.useCallback = Ur, c.useContext = Ut, c.useDebugValue = cn, c.useDeferredValue = Da, c.useEffect = wr, c.useId = Gt, c.useImperativeHandle = No, c.useInsertionEffect = Yn, c.useLayoutEffect = Vn, c.useMemo = Ja, c.useReducer = jt, c.useRef = mt, c.useState = $t, c.useSyncExternalStore = eo, c.useTransition = yf, c.version = d, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(lm, lm.exports)), lm.exports;
}
var ix;
function ic() {
  return ix || (ix = 1, process.env.NODE_ENV === "production" ? Ng.exports = jL() : Ng.exports = FL()), Ng.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ax;
function HL() {
  if (ax)
    return am;
  ax = 1;
  var o = ic(), c = Symbol.for("react.element"), d = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, w = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, M = { key: !0, ref: !0, __self: !0, __source: !0 };
  function C(W, z, j) {
    var Z, H = {}, $ = null, J = null;
    j !== void 0 && ($ = "" + j), z.key !== void 0 && ($ = "" + z.key), z.ref !== void 0 && (J = z.ref);
    for (Z in z)
      m.call(z, Z) && !M.hasOwnProperty(Z) && (H[Z] = z[Z]);
    if (W && W.defaultProps)
      for (Z in z = W.defaultProps, z)
        H[Z] === void 0 && (H[Z] = z[Z]);
    return { $$typeof: c, type: W, key: $, ref: J, props: H, _owner: w.current };
  }
  return am.Fragment = d, am.jsx = C, am.jsxs = C, am;
}
var om = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ox;
function BL() {
  return ox || (ox = 1, process.env.NODE_ENV !== "production" && function() {
    var o = ic(), c = Symbol.for("react.element"), d = Symbol.for("react.portal"), m = Symbol.for("react.fragment"), w = Symbol.for("react.strict_mode"), M = Symbol.for("react.profiler"), C = Symbol.for("react.provider"), W = Symbol.for("react.context"), z = Symbol.for("react.forward_ref"), j = Symbol.for("react.suspense"), Z = Symbol.for("react.suspense_list"), H = Symbol.for("react.memo"), $ = Symbol.for("react.lazy"), J = Symbol.for("react.offscreen"), oe = Symbol.iterator, ce = "@@iterator";
    function ue(U) {
      if (U === null || typeof U != "object")
        return null;
      var _e = oe && U[oe] || U[ce];
      return typeof _e == "function" ? _e : null;
    }
    var Ke = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function He(U) {
      {
        for (var _e = arguments.length, ke = new Array(_e > 1 ? _e - 1 : 0), Be = 1; Be < _e; Be++)
          ke[Be - 1] = arguments[Be];
        ve("error", U, ke);
      }
    }
    function ve(U, _e, ke) {
      {
        var Be = Ke.ReactDebugCurrentFrame, Ut = Be.getStackAddendum();
        Ut !== "" && (_e += "%s", ke = ke.concat([Ut]));
        var $t = ke.map(function(jt) {
          return String(jt);
        });
        $t.unshift("Warning: " + _e), Function.prototype.apply.call(console[U], console, $t);
      }
    }
    var ye = !1, G = !1, Me = !1, ze = !1, kt = !1, It;
    It = Symbol.for("react.module.reference");
    function Nt(U) {
      return !!(typeof U == "string" || typeof U == "function" || U === m || U === M || kt || U === w || U === j || U === Z || ze || U === J || ye || G || Me || typeof U == "object" && U !== null && (U.$$typeof === $ || U.$$typeof === H || U.$$typeof === C || U.$$typeof === W || U.$$typeof === z || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      U.$$typeof === It || U.getModuleId !== void 0));
    }
    function Xe(U, _e, ke) {
      var Be = U.displayName;
      if (Be)
        return Be;
      var Ut = _e.displayName || _e.name || "";
      return Ut !== "" ? ke + "(" + Ut + ")" : ke;
    }
    function Mt(U) {
      return U.displayName || "Context";
    }
    function ut(U) {
      if (U == null)
        return null;
      if (typeof U.tag == "number" && He("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof U == "function")
        return U.displayName || U.name || null;
      if (typeof U == "string")
        return U;
      switch (U) {
        case m:
          return "Fragment";
        case d:
          return "Portal";
        case M:
          return "Profiler";
        case w:
          return "StrictMode";
        case j:
          return "Suspense";
        case Z:
          return "SuspenseList";
      }
      if (typeof U == "object")
        switch (U.$$typeof) {
          case W:
            var _e = U;
            return Mt(_e) + ".Consumer";
          case C:
            var ke = U;
            return Mt(ke._context) + ".Provider";
          case z:
            return Xe(U, U.render, "ForwardRef");
          case H:
            var Be = U.displayName || null;
            return Be !== null ? Be : ut(U.type) || "Memo";
          case $: {
            var Ut = U, $t = Ut._payload, jt = Ut._init;
            try {
              return ut(jt($t));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var lt = Object.assign, tn = 0, vt, Ne, le, Je, N, se, xe;
    function et() {
    }
    et.__reactDisabledLog = !0;
    function je() {
      {
        if (tn === 0) {
          vt = console.log, Ne = console.info, le = console.warn, Je = console.error, N = console.group, se = console.groupCollapsed, xe = console.groupEnd;
          var U = {
            configurable: !0,
            enumerable: !0,
            value: et,
            writable: !0
          };
          Object.defineProperties(console, {
            info: U,
            log: U,
            warn: U,
            error: U,
            group: U,
            groupCollapsed: U,
            groupEnd: U
          });
        }
        tn++;
      }
    }
    function qe() {
      {
        if (tn--, tn === 0) {
          var U = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: lt({}, U, {
              value: vt
            }),
            info: lt({}, U, {
              value: Ne
            }),
            warn: lt({}, U, {
              value: le
            }),
            error: lt({}, U, {
              value: Je
            }),
            group: lt({}, U, {
              value: N
            }),
            groupCollapsed: lt({}, U, {
              value: se
            }),
            groupEnd: lt({}, U, {
              value: xe
            })
          });
        }
        tn < 0 && He("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Oe = Ke.ReactCurrentDispatcher, Rt;
    function _t(U, _e, ke) {
      {
        if (Rt === void 0)
          try {
            throw Error();
          } catch (Ut) {
            var Be = Ut.stack.trim().match(/\n( *(at )?)/);
            Rt = Be && Be[1] || "";
          }
        return `
` + Rt + U;
      }
    }
    var on = !1, Sr;
    {
      var ur = typeof WeakMap == "function" ? WeakMap : Map;
      Sr = new ur();
    }
    function Ue(U, _e) {
      if (!U || on)
        return "";
      {
        var ke = Sr.get(U);
        if (ke !== void 0)
          return ke;
      }
      var Be;
      on = !0;
      var Ut = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var $t;
      $t = Oe.current, Oe.current = null, je();
      try {
        if (_e) {
          var jt = function() {
            throw Error();
          };
          if (Object.defineProperty(jt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(jt, []);
            } catch (cn) {
              Be = cn;
            }
            Reflect.construct(U, [], jt);
          } else {
            try {
              jt.call();
            } catch (cn) {
              Be = cn;
            }
            U.call(jt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (cn) {
            Be = cn;
          }
          U();
        }
      } catch (cn) {
        if (cn && Be && typeof cn.stack == "string") {
          for (var mt = cn.stack.split(`
`), wr = Be.stack.split(`
`), Yn = mt.length - 1, Vn = wr.length - 1; Yn >= 1 && Vn >= 0 && mt[Yn] !== wr[Vn]; )
            Vn--;
          for (; Yn >= 1 && Vn >= 0; Yn--, Vn--)
            if (mt[Yn] !== wr[Vn]) {
              if (Yn !== 1 || Vn !== 1)
                do
                  if (Yn--, Vn--, Vn < 0 || mt[Yn] !== wr[Vn]) {
                    var Ur = `
` + mt[Yn].replace(" at new ", " at ");
                    return U.displayName && Ur.includes("<anonymous>") && (Ur = Ur.replace("<anonymous>", U.displayName)), typeof U == "function" && Sr.set(U, Ur), Ur;
                  }
                while (Yn >= 1 && Vn >= 0);
              break;
            }
        }
      } finally {
        on = !1, Oe.current = $t, qe(), Error.prepareStackTrace = Ut;
      }
      var Ja = U ? U.displayName || U.name : "", No = Ja ? _t(Ja) : "";
      return typeof U == "function" && Sr.set(U, No), No;
    }
    function yn(U, _e, ke) {
      return Ue(U, !1);
    }
    function Ie(U) {
      var _e = U.prototype;
      return !!(_e && _e.isReactComponent);
    }
    function zn(U, _e, ke) {
      if (U == null)
        return "";
      if (typeof U == "function")
        return Ue(U, Ie(U));
      if (typeof U == "string")
        return _t(U);
      switch (U) {
        case j:
          return _t("Suspense");
        case Z:
          return _t("SuspenseList");
      }
      if (typeof U == "object")
        switch (U.$$typeof) {
          case z:
            return yn(U.render);
          case H:
            return zn(U.type, _e, ke);
          case $: {
            var Be = U, Ut = Be._payload, $t = Be._init;
            try {
              return zn($t(Ut), _e, ke);
            } catch {
            }
          }
        }
      return "";
    }
    var Xn = Object.prototype.hasOwnProperty, Bn = {}, Hr = Ke.ReactDebugCurrentFrame;
    function ki(U) {
      if (U) {
        var _e = U._owner, ke = zn(U.type, U._source, _e ? _e.type : null);
        Hr.setExtraStackFrame(ke);
      } else
        Hr.setExtraStackFrame(null);
    }
    function Dr(U, _e, ke, Be, Ut) {
      {
        var $t = Function.call.bind(Xn);
        for (var jt in U)
          if ($t(U, jt)) {
            var mt = void 0;
            try {
              if (typeof U[jt] != "function") {
                var wr = Error((Be || "React class") + ": " + ke + " type `" + jt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof U[jt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw wr.name = "Invariant Violation", wr;
              }
              mt = U[jt](_e, jt, Be, ke, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Yn) {
              mt = Yn;
            }
            mt && !(mt instanceof Error) && (ki(Ut), He("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Be || "React class", ke, jt, typeof mt), ki(null)), mt instanceof Error && !(mt.message in Bn) && (Bn[mt.message] = !0, ki(Ut), He("Failed %s type: %s", ke, mt.message), ki(null));
          }
      }
    }
    var zr = Array.isArray;
    function fi(U) {
      return zr(U);
    }
    function Br(U) {
      {
        var _e = typeof Symbol == "function" && Symbol.toStringTag, ke = _e && U[Symbol.toStringTag] || U.constructor.name || "Object";
        return ke;
      }
    }
    function Yi(U) {
      try {
        return Yr(U), !1;
      } catch {
        return !0;
      }
    }
    function Yr(U) {
      return "" + U;
    }
    function Xr(U) {
      if (Yi(U))
        return He("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Br(U)), Yr(U);
    }
    var er = Ke.ReactCurrentOwner, Jr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Qa, Oi, De;
    De = {};
    function ft(U) {
      if (Xn.call(U, "ref")) {
        var _e = Object.getOwnPropertyDescriptor(U, "ref").get;
        if (_e && _e.isReactWarning)
          return !1;
      }
      return U.ref !== void 0;
    }
    function Yt(U) {
      if (Xn.call(U, "key")) {
        var _e = Object.getOwnPropertyDescriptor(U, "key").get;
        if (_e && _e.isReactWarning)
          return !1;
      }
      return U.key !== void 0;
    }
    function dn(U, _e) {
      if (typeof U.ref == "string" && er.current && _e && er.current.stateNode !== _e) {
        var ke = ut(er.current.type);
        De[ke] || (He('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', ut(er.current.type), U.ref), De[ke] = !0);
      }
    }
    function gn(U, _e) {
      {
        var ke = function() {
          Qa || (Qa = !0, He("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", _e));
        };
        ke.isReactWarning = !0, Object.defineProperty(U, "key", {
          get: ke,
          configurable: !0
        });
      }
    }
    function dr(U, _e) {
      {
        var ke = function() {
          Oi || (Oi = !0, He("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", _e));
        };
        ke.isReactWarning = !0, Object.defineProperty(U, "ref", {
          get: ke,
          configurable: !0
        });
      }
    }
    var Un = function(U, _e, ke, Be, Ut, $t, jt) {
      var mt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: c,
        // Built-in properties that belong on the element
        type: U,
        key: _e,
        ref: ke,
        props: jt,
        // Record the component responsible for creating this element.
        _owner: $t
      };
      return mt._store = {}, Object.defineProperty(mt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(mt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Be
      }), Object.defineProperty(mt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ut
      }), Object.freeze && (Object.freeze(mt.props), Object.freeze(mt)), mt;
    };
    function ei(U, _e, ke, Be, Ut) {
      {
        var $t, jt = {}, mt = null, wr = null;
        ke !== void 0 && (Xr(ke), mt = "" + ke), Yt(_e) && (Xr(_e.key), mt = "" + _e.key), ft(_e) && (wr = _e.ref, dn(_e, Ut));
        for ($t in _e)
          Xn.call(_e, $t) && !Jr.hasOwnProperty($t) && (jt[$t] = _e[$t]);
        if (U && U.defaultProps) {
          var Yn = U.defaultProps;
          for ($t in Yn)
            jt[$t] === void 0 && (jt[$t] = Yn[$t]);
        }
        if (mt || wr) {
          var Vn = typeof U == "function" ? U.displayName || U.name || "Unknown" : U;
          mt && gn(jt, Vn), wr && dr(jt, Vn);
        }
        return Un(U, mt, wr, Ut, Be, er.current, jt);
      }
    }
    var bn = Ke.ReactCurrentOwner, ti = Ke.ReactDebugCurrentFrame;
    function _n(U) {
      if (U) {
        var _e = U._owner, ke = zn(U.type, U._source, _e ? _e.type : null);
        ti.setExtraStackFrame(ke);
      } else
        ti.setExtraStackFrame(null);
    }
    var Sn;
    Sn = !1;
    function Ma(U) {
      return typeof U == "object" && U !== null && U.$$typeof === c;
    }
    function ia() {
      {
        if (bn.current) {
          var U = ut(bn.current.type);
          if (U)
            return `

Check the render method of \`` + U + "`.";
        }
        return "";
      }
    }
    function ns(U) {
      {
        if (U !== void 0) {
          var _e = U.fileName.replace(/^.*[\\\/]/, ""), ke = U.lineNumber;
          return `

Check your code at ` + _e + ":" + ke + ".";
        }
        return "";
      }
    }
    var Ls = {};
    function hu(U) {
      {
        var _e = ia();
        if (!_e) {
          var ke = typeof U == "string" ? U : U.displayName || U.name;
          ke && (_e = `

Check the top-level render call using <` + ke + ">.");
        }
        return _e;
      }
    }
    function Lo(U, _e) {
      {
        if (!U._store || U._store.validated || U.key != null)
          return;
        U._store.validated = !0;
        var ke = hu(_e);
        if (Ls[ke])
          return;
        Ls[ke] = !0;
        var Be = "";
        U && U._owner && U._owner !== bn.current && (Be = " It was passed a child from " + ut(U._owner.type) + "."), _n(U), He('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ke, Be), _n(null);
      }
    }
    function qa(U, _e) {
      {
        if (typeof U != "object")
          return;
        if (fi(U))
          for (var ke = 0; ke < U.length; ke++) {
            var Be = U[ke];
            Ma(Be) && Lo(Be, _e);
          }
        else if (Ma(U))
          U._store && (U._store.validated = !0);
        else if (U) {
          var Ut = ue(U);
          if (typeof Ut == "function" && Ut !== U.entries)
            for (var $t = Ut.call(U), jt; !(jt = $t.next()).done; )
              Ma(jt.value) && Lo(jt.value, _e);
        }
      }
    }
    function Vi(U) {
      {
        var _e = U.type;
        if (_e == null || typeof _e == "string")
          return;
        var ke;
        if (typeof _e == "function")
          ke = _e.propTypes;
        else if (typeof _e == "object" && (_e.$$typeof === z || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        _e.$$typeof === H))
          ke = _e.propTypes;
        else
          return;
        if (ke) {
          var Be = ut(_e);
          Dr(ke, U.props, "prop", Be, U);
        } else if (_e.PropTypes !== void 0 && !Sn) {
          Sn = !0;
          var Ut = ut(_e);
          He("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ut || "Unknown");
        }
        typeof _e.getDefaultProps == "function" && !_e.getDefaultProps.isReactClassApproved && He("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ka(U) {
      {
        for (var _e = Object.keys(U.props), ke = 0; ke < _e.length; ke++) {
          var Be = _e[ke];
          if (Be !== "children" && Be !== "key") {
            _n(U), He("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Be), _n(null);
            break;
          }
        }
        U.ref !== null && (_n(U), He("Invalid attribute `ref` supplied to `React.Fragment`."), _n(null));
      }
    }
    function Wi(U, _e, ke, Be, Ut, $t) {
      {
        var jt = Nt(U);
        if (!jt) {
          var mt = "";
          (U === void 0 || typeof U == "object" && U !== null && Object.keys(U).length === 0) && (mt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var wr = ns(Ut);
          wr ? mt += wr : mt += ia();
          var Yn;
          U === null ? Yn = "null" : fi(U) ? Yn = "array" : U !== void 0 && U.$$typeof === c ? (Yn = "<" + (ut(U.type) || "Unknown") + " />", mt = " Did you accidentally export a JSX literal instead of a component?") : Yn = typeof U, He("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Yn, mt);
        }
        var Vn = ei(U, _e, ke, Ut, $t);
        if (Vn == null)
          return Vn;
        if (jt) {
          var Ur = _e.children;
          if (Ur !== void 0)
            if (Be)
              if (fi(Ur)) {
                for (var Ja = 0; Ja < Ur.length; Ja++)
                  qa(Ur[Ja], U);
                Object.freeze && Object.freeze(Ur);
              } else
                He("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              qa(Ur, U);
        }
        return U === m ? Ka(Vn) : Vi(Vn), Vn;
      }
    }
    function Xa(U, _e, ke) {
      return Wi(U, _e, ke, !0);
    }
    function tr(U, _e, ke) {
      return Wi(U, _e, ke, !1);
    }
    var We = tr, Ra = Xa;
    om.Fragment = m, om.jsx = We, om.jsxs = Ra;
  }()), om;
}
process.env.NODE_ENV === "production" ? Nw.exports = HL() : Nw.exports = BL();
var uf = Nw.exports, YL = ic();
const Et = /* @__PURE__ */ jx(YL);
var Pw = { exports: {} }, Gn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sx;
function VL() {
  if (sx)
    return Gn;
  sx = 1;
  var o = typeof Symbol == "function" && Symbol.for, c = o ? Symbol.for("react.element") : 60103, d = o ? Symbol.for("react.portal") : 60106, m = o ? Symbol.for("react.fragment") : 60107, w = o ? Symbol.for("react.strict_mode") : 60108, M = o ? Symbol.for("react.profiler") : 60114, C = o ? Symbol.for("react.provider") : 60109, W = o ? Symbol.for("react.context") : 60110, z = o ? Symbol.for("react.async_mode") : 60111, j = o ? Symbol.for("react.concurrent_mode") : 60111, Z = o ? Symbol.for("react.forward_ref") : 60112, H = o ? Symbol.for("react.suspense") : 60113, $ = o ? Symbol.for("react.suspense_list") : 60120, J = o ? Symbol.for("react.memo") : 60115, oe = o ? Symbol.for("react.lazy") : 60116, ce = o ? Symbol.for("react.block") : 60121, ue = o ? Symbol.for("react.fundamental") : 60117, Ke = o ? Symbol.for("react.responder") : 60118, He = o ? Symbol.for("react.scope") : 60119;
  function ve(G) {
    if (typeof G == "object" && G !== null) {
      var Me = G.$$typeof;
      switch (Me) {
        case c:
          switch (G = G.type, G) {
            case z:
            case j:
            case m:
            case M:
            case w:
            case H:
              return G;
            default:
              switch (G = G && G.$$typeof, G) {
                case W:
                case Z:
                case oe:
                case J:
                case C:
                  return G;
                default:
                  return Me;
              }
          }
        case d:
          return Me;
      }
    }
  }
  function ye(G) {
    return ve(G) === j;
  }
  return Gn.AsyncMode = z, Gn.ConcurrentMode = j, Gn.ContextConsumer = W, Gn.ContextProvider = C, Gn.Element = c, Gn.ForwardRef = Z, Gn.Fragment = m, Gn.Lazy = oe, Gn.Memo = J, Gn.Portal = d, Gn.Profiler = M, Gn.StrictMode = w, Gn.Suspense = H, Gn.isAsyncMode = function(G) {
    return ye(G) || ve(G) === z;
  }, Gn.isConcurrentMode = ye, Gn.isContextConsumer = function(G) {
    return ve(G) === W;
  }, Gn.isContextProvider = function(G) {
    return ve(G) === C;
  }, Gn.isElement = function(G) {
    return typeof G == "object" && G !== null && G.$$typeof === c;
  }, Gn.isForwardRef = function(G) {
    return ve(G) === Z;
  }, Gn.isFragment = function(G) {
    return ve(G) === m;
  }, Gn.isLazy = function(G) {
    return ve(G) === oe;
  }, Gn.isMemo = function(G) {
    return ve(G) === J;
  }, Gn.isPortal = function(G) {
    return ve(G) === d;
  }, Gn.isProfiler = function(G) {
    return ve(G) === M;
  }, Gn.isStrictMode = function(G) {
    return ve(G) === w;
  }, Gn.isSuspense = function(G) {
    return ve(G) === H;
  }, Gn.isValidElementType = function(G) {
    return typeof G == "string" || typeof G == "function" || G === m || G === j || G === M || G === w || G === H || G === $ || typeof G == "object" && G !== null && (G.$$typeof === oe || G.$$typeof === J || G.$$typeof === C || G.$$typeof === W || G.$$typeof === Z || G.$$typeof === ue || G.$$typeof === Ke || G.$$typeof === He || G.$$typeof === ce);
  }, Gn.typeOf = ve, Gn;
}
var Qn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ux;
function WL() {
  return ux || (ux = 1, process.env.NODE_ENV !== "production" && function() {
    var o = typeof Symbol == "function" && Symbol.for, c = o ? Symbol.for("react.element") : 60103, d = o ? Symbol.for("react.portal") : 60106, m = o ? Symbol.for("react.fragment") : 60107, w = o ? Symbol.for("react.strict_mode") : 60108, M = o ? Symbol.for("react.profiler") : 60114, C = o ? Symbol.for("react.provider") : 60109, W = o ? Symbol.for("react.context") : 60110, z = o ? Symbol.for("react.async_mode") : 60111, j = o ? Symbol.for("react.concurrent_mode") : 60111, Z = o ? Symbol.for("react.forward_ref") : 60112, H = o ? Symbol.for("react.suspense") : 60113, $ = o ? Symbol.for("react.suspense_list") : 60120, J = o ? Symbol.for("react.memo") : 60115, oe = o ? Symbol.for("react.lazy") : 60116, ce = o ? Symbol.for("react.block") : 60121, ue = o ? Symbol.for("react.fundamental") : 60117, Ke = o ? Symbol.for("react.responder") : 60118, He = o ? Symbol.for("react.scope") : 60119;
    function ve(Ue) {
      return typeof Ue == "string" || typeof Ue == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      Ue === m || Ue === j || Ue === M || Ue === w || Ue === H || Ue === $ || typeof Ue == "object" && Ue !== null && (Ue.$$typeof === oe || Ue.$$typeof === J || Ue.$$typeof === C || Ue.$$typeof === W || Ue.$$typeof === Z || Ue.$$typeof === ue || Ue.$$typeof === Ke || Ue.$$typeof === He || Ue.$$typeof === ce);
    }
    function ye(Ue) {
      if (typeof Ue == "object" && Ue !== null) {
        var yn = Ue.$$typeof;
        switch (yn) {
          case c:
            var Ie = Ue.type;
            switch (Ie) {
              case z:
              case j:
              case m:
              case M:
              case w:
              case H:
                return Ie;
              default:
                var zn = Ie && Ie.$$typeof;
                switch (zn) {
                  case W:
                  case Z:
                  case oe:
                  case J:
                  case C:
                    return zn;
                  default:
                    return yn;
                }
            }
          case d:
            return yn;
        }
      }
    }
    var G = z, Me = j, ze = W, kt = C, It = c, Nt = Z, Xe = m, Mt = oe, ut = J, lt = d, tn = M, vt = w, Ne = H, le = !1;
    function Je(Ue) {
      return le || (le = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), N(Ue) || ye(Ue) === z;
    }
    function N(Ue) {
      return ye(Ue) === j;
    }
    function se(Ue) {
      return ye(Ue) === W;
    }
    function xe(Ue) {
      return ye(Ue) === C;
    }
    function et(Ue) {
      return typeof Ue == "object" && Ue !== null && Ue.$$typeof === c;
    }
    function je(Ue) {
      return ye(Ue) === Z;
    }
    function qe(Ue) {
      return ye(Ue) === m;
    }
    function Oe(Ue) {
      return ye(Ue) === oe;
    }
    function Rt(Ue) {
      return ye(Ue) === J;
    }
    function _t(Ue) {
      return ye(Ue) === d;
    }
    function on(Ue) {
      return ye(Ue) === M;
    }
    function Sr(Ue) {
      return ye(Ue) === w;
    }
    function ur(Ue) {
      return ye(Ue) === H;
    }
    Qn.AsyncMode = G, Qn.ConcurrentMode = Me, Qn.ContextConsumer = ze, Qn.ContextProvider = kt, Qn.Element = It, Qn.ForwardRef = Nt, Qn.Fragment = Xe, Qn.Lazy = Mt, Qn.Memo = ut, Qn.Portal = lt, Qn.Profiler = tn, Qn.StrictMode = vt, Qn.Suspense = Ne, Qn.isAsyncMode = Je, Qn.isConcurrentMode = N, Qn.isContextConsumer = se, Qn.isContextProvider = xe, Qn.isElement = et, Qn.isForwardRef = je, Qn.isFragment = qe, Qn.isLazy = Oe, Qn.isMemo = Rt, Qn.isPortal = _t, Qn.isProfiler = on, Qn.isStrictMode = Sr, Qn.isSuspense = ur, Qn.isValidElementType = ve, Qn.typeOf = ye;
  }()), Qn;
}
process.env.NODE_ENV === "production" ? Pw.exports = VL() : Pw.exports = WL();
var ZL = Pw.exports, Fx = ZL, $L = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, GL = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, Hx = {};
Hx[Fx.ForwardRef] = $L;
Hx[Fx.Memo] = GL;
var qn = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lx;
function QL() {
  if (lx)
    return qn;
  lx = 1;
  var o = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), m = Symbol.for("react.strict_mode"), w = Symbol.for("react.profiler"), M = Symbol.for("react.provider"), C = Symbol.for("react.context"), W = Symbol.for("react.server_context"), z = Symbol.for("react.forward_ref"), j = Symbol.for("react.suspense"), Z = Symbol.for("react.suspense_list"), H = Symbol.for("react.memo"), $ = Symbol.for("react.lazy"), J = Symbol.for("react.offscreen"), oe;
  oe = Symbol.for("react.module.reference");
  function ce(ue) {
    if (typeof ue == "object" && ue !== null) {
      var Ke = ue.$$typeof;
      switch (Ke) {
        case o:
          switch (ue = ue.type, ue) {
            case d:
            case w:
            case m:
            case j:
            case Z:
              return ue;
            default:
              switch (ue = ue && ue.$$typeof, ue) {
                case W:
                case C:
                case z:
                case $:
                case H:
                case M:
                  return ue;
                default:
                  return Ke;
              }
          }
        case c:
          return Ke;
      }
    }
  }
  return qn.ContextConsumer = C, qn.ContextProvider = M, qn.Element = o, qn.ForwardRef = z, qn.Fragment = d, qn.Lazy = $, qn.Memo = H, qn.Portal = c, qn.Profiler = w, qn.StrictMode = m, qn.Suspense = j, qn.SuspenseList = Z, qn.isAsyncMode = function() {
    return !1;
  }, qn.isConcurrentMode = function() {
    return !1;
  }, qn.isContextConsumer = function(ue) {
    return ce(ue) === C;
  }, qn.isContextProvider = function(ue) {
    return ce(ue) === M;
  }, qn.isElement = function(ue) {
    return typeof ue == "object" && ue !== null && ue.$$typeof === o;
  }, qn.isForwardRef = function(ue) {
    return ce(ue) === z;
  }, qn.isFragment = function(ue) {
    return ce(ue) === d;
  }, qn.isLazy = function(ue) {
    return ce(ue) === $;
  }, qn.isMemo = function(ue) {
    return ce(ue) === H;
  }, qn.isPortal = function(ue) {
    return ce(ue) === c;
  }, qn.isProfiler = function(ue) {
    return ce(ue) === w;
  }, qn.isStrictMode = function(ue) {
    return ce(ue) === m;
  }, qn.isSuspense = function(ue) {
    return ce(ue) === j;
  }, qn.isSuspenseList = function(ue) {
    return ce(ue) === Z;
  }, qn.isValidElementType = function(ue) {
    return typeof ue == "string" || typeof ue == "function" || ue === d || ue === w || ue === m || ue === j || ue === Z || ue === J || typeof ue == "object" && ue !== null && (ue.$$typeof === $ || ue.$$typeof === H || ue.$$typeof === M || ue.$$typeof === C || ue.$$typeof === z || ue.$$typeof === oe || ue.getModuleId !== void 0);
  }, qn.typeOf = ce, qn;
}
var Kn = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cx;
function qL() {
  return cx || (cx = 1, process.env.NODE_ENV !== "production" && function() {
    var o = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), m = Symbol.for("react.strict_mode"), w = Symbol.for("react.profiler"), M = Symbol.for("react.provider"), C = Symbol.for("react.context"), W = Symbol.for("react.server_context"), z = Symbol.for("react.forward_ref"), j = Symbol.for("react.suspense"), Z = Symbol.for("react.suspense_list"), H = Symbol.for("react.memo"), $ = Symbol.for("react.lazy"), J = Symbol.for("react.offscreen"), oe = !1, ce = !1, ue = !1, Ke = !1, He = !1, ve;
    ve = Symbol.for("react.module.reference");
    function ye(Ie) {
      return !!(typeof Ie == "string" || typeof Ie == "function" || Ie === d || Ie === w || He || Ie === m || Ie === j || Ie === Z || Ke || Ie === J || oe || ce || ue || typeof Ie == "object" && Ie !== null && (Ie.$$typeof === $ || Ie.$$typeof === H || Ie.$$typeof === M || Ie.$$typeof === C || Ie.$$typeof === z || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Ie.$$typeof === ve || Ie.getModuleId !== void 0));
    }
    function G(Ie) {
      if (typeof Ie == "object" && Ie !== null) {
        var zn = Ie.$$typeof;
        switch (zn) {
          case o:
            var Xn = Ie.type;
            switch (Xn) {
              case d:
              case w:
              case m:
              case j:
              case Z:
                return Xn;
              default:
                var Bn = Xn && Xn.$$typeof;
                switch (Bn) {
                  case W:
                  case C:
                  case z:
                  case $:
                  case H:
                  case M:
                    return Bn;
                  default:
                    return zn;
                }
            }
          case c:
            return zn;
        }
      }
    }
    var Me = C, ze = M, kt = o, It = z, Nt = d, Xe = $, Mt = H, ut = c, lt = w, tn = m, vt = j, Ne = Z, le = !1, Je = !1;
    function N(Ie) {
      return le || (le = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function se(Ie) {
      return Je || (Je = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function xe(Ie) {
      return G(Ie) === C;
    }
    function et(Ie) {
      return G(Ie) === M;
    }
    function je(Ie) {
      return typeof Ie == "object" && Ie !== null && Ie.$$typeof === o;
    }
    function qe(Ie) {
      return G(Ie) === z;
    }
    function Oe(Ie) {
      return G(Ie) === d;
    }
    function Rt(Ie) {
      return G(Ie) === $;
    }
    function _t(Ie) {
      return G(Ie) === H;
    }
    function on(Ie) {
      return G(Ie) === c;
    }
    function Sr(Ie) {
      return G(Ie) === w;
    }
    function ur(Ie) {
      return G(Ie) === m;
    }
    function Ue(Ie) {
      return G(Ie) === j;
    }
    function yn(Ie) {
      return G(Ie) === Z;
    }
    Kn.ContextConsumer = Me, Kn.ContextProvider = ze, Kn.Element = kt, Kn.ForwardRef = It, Kn.Fragment = Nt, Kn.Lazy = Xe, Kn.Memo = Mt, Kn.Portal = ut, Kn.Profiler = lt, Kn.StrictMode = tn, Kn.Suspense = vt, Kn.SuspenseList = Ne, Kn.isAsyncMode = N, Kn.isConcurrentMode = se, Kn.isContextConsumer = xe, Kn.isContextProvider = et, Kn.isElement = je, Kn.isForwardRef = qe, Kn.isFragment = Oe, Kn.isLazy = Rt, Kn.isMemo = _t, Kn.isPortal = on, Kn.isProfiler = Sr, Kn.isStrictMode = ur, Kn.isSuspense = Ue, Kn.isSuspenseList = yn, Kn.isValidElementType = ye, Kn.typeOf = G;
  }()), Kn;
}
process.env.NODE_ENV === "production" ? QL() : qL();
var Do = {}, Pg = { exports: {} }, yw = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fx;
function KL() {
  return fx || (fx = 1, function(o) {
    function c(le, Je) {
      var N = le.length;
      le.push(Je);
      e:
        for (; 0 < N; ) {
          var se = N - 1 >>> 1, xe = le[se];
          if (0 < w(xe, Je))
            le[se] = Je, le[N] = xe, N = se;
          else
            break e;
        }
    }
    function d(le) {
      return le.length === 0 ? null : le[0];
    }
    function m(le) {
      if (le.length === 0)
        return null;
      var Je = le[0], N = le.pop();
      if (N !== Je) {
        le[0] = N;
        e:
          for (var se = 0, xe = le.length, et = xe >>> 1; se < et; ) {
            var je = 2 * (se + 1) - 1, qe = le[je], Oe = je + 1, Rt = le[Oe];
            if (0 > w(qe, N))
              Oe < xe && 0 > w(Rt, qe) ? (le[se] = Rt, le[Oe] = N, se = Oe) : (le[se] = qe, le[je] = N, se = je);
            else if (Oe < xe && 0 > w(Rt, N))
              le[se] = Rt, le[Oe] = N, se = Oe;
            else
              break e;
          }
      }
      return Je;
    }
    function w(le, Je) {
      var N = le.sortIndex - Je.sortIndex;
      return N !== 0 ? N : le.id - Je.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var M = performance;
      o.unstable_now = function() {
        return M.now();
      };
    } else {
      var C = Date, W = C.now();
      o.unstable_now = function() {
        return C.now() - W;
      };
    }
    var z = [], j = [], Z = 1, H = null, $ = 3, J = !1, oe = !1, ce = !1, ue = typeof setTimeout == "function" ? setTimeout : null, Ke = typeof clearTimeout == "function" ? clearTimeout : null, He = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function ve(le) {
      for (var Je = d(j); Je !== null; ) {
        if (Je.callback === null)
          m(j);
        else if (Je.startTime <= le)
          m(j), Je.sortIndex = Je.expirationTime, c(z, Je);
        else
          break;
        Je = d(j);
      }
    }
    function ye(le) {
      if (ce = !1, ve(le), !oe)
        if (d(z) !== null)
          oe = !0, vt(G);
        else {
          var Je = d(j);
          Je !== null && Ne(ye, Je.startTime - le);
        }
    }
    function G(le, Je) {
      oe = !1, ce && (ce = !1, Ke(kt), kt = -1), J = !0;
      var N = $;
      try {
        for (ve(Je), H = d(z); H !== null && (!(H.expirationTime > Je) || le && !Xe()); ) {
          var se = H.callback;
          if (typeof se == "function") {
            H.callback = null, $ = H.priorityLevel;
            var xe = se(H.expirationTime <= Je);
            Je = o.unstable_now(), typeof xe == "function" ? H.callback = xe : H === d(z) && m(z), ve(Je);
          } else
            m(z);
          H = d(z);
        }
        if (H !== null)
          var et = !0;
        else {
          var je = d(j);
          je !== null && Ne(ye, je.startTime - Je), et = !1;
        }
        return et;
      } finally {
        H = null, $ = N, J = !1;
      }
    }
    var Me = !1, ze = null, kt = -1, It = 5, Nt = -1;
    function Xe() {
      return !(o.unstable_now() - Nt < It);
    }
    function Mt() {
      if (ze !== null) {
        var le = o.unstable_now();
        Nt = le;
        var Je = !0;
        try {
          Je = ze(!0, le);
        } finally {
          Je ? ut() : (Me = !1, ze = null);
        }
      } else
        Me = !1;
    }
    var ut;
    if (typeof He == "function")
      ut = function() {
        He(Mt);
      };
    else if (typeof MessageChannel < "u") {
      var lt = new MessageChannel(), tn = lt.port2;
      lt.port1.onmessage = Mt, ut = function() {
        tn.postMessage(null);
      };
    } else
      ut = function() {
        ue(Mt, 0);
      };
    function vt(le) {
      ze = le, Me || (Me = !0, ut());
    }
    function Ne(le, Je) {
      kt = ue(function() {
        le(o.unstable_now());
      }, Je);
    }
    o.unstable_IdlePriority = 5, o.unstable_ImmediatePriority = 1, o.unstable_LowPriority = 4, o.unstable_NormalPriority = 3, o.unstable_Profiling = null, o.unstable_UserBlockingPriority = 2, o.unstable_cancelCallback = function(le) {
      le.callback = null;
    }, o.unstable_continueExecution = function() {
      oe || J || (oe = !0, vt(G));
    }, o.unstable_forceFrameRate = function(le) {
      0 > le || 125 < le ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : It = 0 < le ? Math.floor(1e3 / le) : 5;
    }, o.unstable_getCurrentPriorityLevel = function() {
      return $;
    }, o.unstable_getFirstCallbackNode = function() {
      return d(z);
    }, o.unstable_next = function(le) {
      switch ($) {
        case 1:
        case 2:
        case 3:
          var Je = 3;
          break;
        default:
          Je = $;
      }
      var N = $;
      $ = Je;
      try {
        return le();
      } finally {
        $ = N;
      }
    }, o.unstable_pauseExecution = function() {
    }, o.unstable_requestPaint = function() {
    }, o.unstable_runWithPriority = function(le, Je) {
      switch (le) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          le = 3;
      }
      var N = $;
      $ = le;
      try {
        return Je();
      } finally {
        $ = N;
      }
    }, o.unstable_scheduleCallback = function(le, Je, N) {
      var se = o.unstable_now();
      switch (typeof N == "object" && N !== null ? (N = N.delay, N = typeof N == "number" && 0 < N ? se + N : se) : N = se, le) {
        case 1:
          var xe = -1;
          break;
        case 2:
          xe = 250;
          break;
        case 5:
          xe = 1073741823;
          break;
        case 4:
          xe = 1e4;
          break;
        default:
          xe = 5e3;
      }
      return xe = N + xe, le = { id: Z++, callback: Je, priorityLevel: le, startTime: N, expirationTime: xe, sortIndex: -1 }, N > se ? (le.sortIndex = N, c(j, le), d(z) === null && le === d(j) && (ce ? (Ke(kt), kt = -1) : ce = !0, Ne(ye, N - se))) : (le.sortIndex = xe, c(z, le), oe || J || (oe = !0, vt(G))), le;
    }, o.unstable_shouldYield = Xe, o.unstable_wrapCallback = function(le) {
      var Je = $;
      return function() {
        var N = $;
        $ = Je;
        try {
          return le.apply(this, arguments);
        } finally {
          $ = N;
        }
      };
    };
  }(yw)), yw;
}
var gw = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dx;
function XL() {
  return dx || (dx = 1, function(o) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var c = !1, d = !1, m = 5;
      function w(De, ft) {
        var Yt = De.length;
        De.push(ft), W(De, ft, Yt);
      }
      function M(De) {
        return De.length === 0 ? null : De[0];
      }
      function C(De) {
        if (De.length === 0)
          return null;
        var ft = De[0], Yt = De.pop();
        return Yt !== ft && (De[0] = Yt, z(De, Yt, 0)), ft;
      }
      function W(De, ft, Yt) {
        for (var dn = Yt; dn > 0; ) {
          var gn = dn - 1 >>> 1, dr = De[gn];
          if (j(dr, ft) > 0)
            De[gn] = ft, De[dn] = dr, dn = gn;
          else
            return;
        }
      }
      function z(De, ft, Yt) {
        for (var dn = Yt, gn = De.length, dr = gn >>> 1; dn < dr; ) {
          var Un = (dn + 1) * 2 - 1, ei = De[Un], bn = Un + 1, ti = De[bn];
          if (j(ei, ft) < 0)
            bn < gn && j(ti, ei) < 0 ? (De[dn] = ti, De[bn] = ft, dn = bn) : (De[dn] = ei, De[Un] = ft, dn = Un);
          else if (bn < gn && j(ti, ft) < 0)
            De[dn] = ti, De[bn] = ft, dn = bn;
          else
            return;
        }
      }
      function j(De, ft) {
        var Yt = De.sortIndex - ft.sortIndex;
        return Yt !== 0 ? Yt : De.id - ft.id;
      }
      var Z = 1, H = 2, $ = 3, J = 4, oe = 5;
      function ce(De, ft) {
      }
      var ue = typeof performance == "object" && typeof performance.now == "function";
      if (ue) {
        var Ke = performance;
        o.unstable_now = function() {
          return Ke.now();
        };
      } else {
        var He = Date, ve = He.now();
        o.unstable_now = function() {
          return He.now() - ve;
        };
      }
      var ye = 1073741823, G = -1, Me = 250, ze = 5e3, kt = 1e4, It = ye, Nt = [], Xe = [], Mt = 1, ut = null, lt = $, tn = !1, vt = !1, Ne = !1, le = typeof setTimeout == "function" ? setTimeout : null, Je = typeof clearTimeout == "function" ? clearTimeout : null, N = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function se(De) {
        for (var ft = M(Xe); ft !== null; ) {
          if (ft.callback === null)
            C(Xe);
          else if (ft.startTime <= De)
            C(Xe), ft.sortIndex = ft.expirationTime, w(Nt, ft);
          else
            return;
          ft = M(Xe);
        }
      }
      function xe(De) {
        if (Ne = !1, se(De), !vt)
          if (M(Nt) !== null)
            vt = !0, Xr(et);
          else {
            var ft = M(Xe);
            ft !== null && er(xe, ft.startTime - De);
          }
      }
      function et(De, ft) {
        vt = !1, Ne && (Ne = !1, Jr()), tn = !0;
        var Yt = lt;
        try {
          var dn;
          if (!d)
            return je(De, ft);
        } finally {
          ut = null, lt = Yt, tn = !1;
        }
      }
      function je(De, ft) {
        var Yt = ft;
        for (se(Yt), ut = M(Nt); ut !== null && !c && !(ut.expirationTime > Yt && (!De || ki())); ) {
          var dn = ut.callback;
          if (typeof dn == "function") {
            ut.callback = null, lt = ut.priorityLevel;
            var gn = ut.expirationTime <= Yt, dr = dn(gn);
            Yt = o.unstable_now(), typeof dr == "function" ? ut.callback = dr : ut === M(Nt) && C(Nt), se(Yt);
          } else
            C(Nt);
          ut = M(Nt);
        }
        if (ut !== null)
          return !0;
        var Un = M(Xe);
        return Un !== null && er(xe, Un.startTime - Yt), !1;
      }
      function qe(De, ft) {
        switch (De) {
          case Z:
          case H:
          case $:
          case J:
          case oe:
            break;
          default:
            De = $;
        }
        var Yt = lt;
        lt = De;
        try {
          return ft();
        } finally {
          lt = Yt;
        }
      }
      function Oe(De) {
        var ft;
        switch (lt) {
          case Z:
          case H:
          case $:
            ft = $;
            break;
          default:
            ft = lt;
            break;
        }
        var Yt = lt;
        lt = ft;
        try {
          return De();
        } finally {
          lt = Yt;
        }
      }
      function Rt(De) {
        var ft = lt;
        return function() {
          var Yt = lt;
          lt = ft;
          try {
            return De.apply(this, arguments);
          } finally {
            lt = Yt;
          }
        };
      }
      function _t(De, ft, Yt) {
        var dn = o.unstable_now(), gn;
        if (typeof Yt == "object" && Yt !== null) {
          var dr = Yt.delay;
          typeof dr == "number" && dr > 0 ? gn = dn + dr : gn = dn;
        } else
          gn = dn;
        var Un;
        switch (De) {
          case Z:
            Un = G;
            break;
          case H:
            Un = Me;
            break;
          case oe:
            Un = It;
            break;
          case J:
            Un = kt;
            break;
          case $:
          default:
            Un = ze;
            break;
        }
        var ei = gn + Un, bn = {
          id: Mt++,
          callback: ft,
          priorityLevel: De,
          startTime: gn,
          expirationTime: ei,
          sortIndex: -1
        };
        return gn > dn ? (bn.sortIndex = gn, w(Xe, bn), M(Nt) === null && bn === M(Xe) && (Ne ? Jr() : Ne = !0, er(xe, gn - dn))) : (bn.sortIndex = ei, w(Nt, bn), !vt && !tn && (vt = !0, Xr(et))), bn;
      }
      function on() {
      }
      function Sr() {
        !vt && !tn && (vt = !0, Xr(et));
      }
      function ur() {
        return M(Nt);
      }
      function Ue(De) {
        De.callback = null;
      }
      function yn() {
        return lt;
      }
      var Ie = !1, zn = null, Xn = -1, Bn = m, Hr = -1;
      function ki() {
        var De = o.unstable_now() - Hr;
        return !(De < Bn);
      }
      function Dr() {
      }
      function zr(De) {
        if (De < 0 || De > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        De > 0 ? Bn = Math.floor(1e3 / De) : Bn = m;
      }
      var fi = function() {
        if (zn !== null) {
          var De = o.unstable_now();
          Hr = De;
          var ft = !0, Yt = !0;
          try {
            Yt = zn(ft, De);
          } finally {
            Yt ? Br() : (Ie = !1, zn = null);
          }
        } else
          Ie = !1;
      }, Br;
      if (typeof N == "function")
        Br = function() {
          N(fi);
        };
      else if (typeof MessageChannel < "u") {
        var Yi = new MessageChannel(), Yr = Yi.port2;
        Yi.port1.onmessage = fi, Br = function() {
          Yr.postMessage(null);
        };
      } else
        Br = function() {
          le(fi, 0);
        };
      function Xr(De) {
        zn = De, Ie || (Ie = !0, Br());
      }
      function er(De, ft) {
        Xn = le(function() {
          De(o.unstable_now());
        }, ft);
      }
      function Jr() {
        Je(Xn), Xn = -1;
      }
      var Qa = Dr, Oi = null;
      o.unstable_IdlePriority = oe, o.unstable_ImmediatePriority = Z, o.unstable_LowPriority = J, o.unstable_NormalPriority = $, o.unstable_Profiling = Oi, o.unstable_UserBlockingPriority = H, o.unstable_cancelCallback = Ue, o.unstable_continueExecution = Sr, o.unstable_forceFrameRate = zr, o.unstable_getCurrentPriorityLevel = yn, o.unstable_getFirstCallbackNode = ur, o.unstable_next = Oe, o.unstable_pauseExecution = on, o.unstable_requestPaint = Qa, o.unstable_runWithPriority = qe, o.unstable_scheduleCallback = _t, o.unstable_shouldYield = ki, o.unstable_wrapCallback = Rt, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(gw)), gw;
}
var hx;
function Bx() {
  return hx || (hx = 1, process.env.NODE_ENV === "production" ? Pg.exports = KL() : Pg.exports = XL()), Pg.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var px;
function JL() {
  if (px)
    return Do;
  px = 1;
  var o = ic(), c = Bx();
  function d(n) {
    for (var i = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, l = 1; l < arguments.length; l++)
      i += "&args[]=" + encodeURIComponent(arguments[l]);
    return "Minified React error #" + n + "; visit " + i + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var m = /* @__PURE__ */ new Set(), w = {};
  function M(n, i) {
    C(n, i), C(n + "Capture", i);
  }
  function C(n, i) {
    for (w[n] = i, n = 0; n < i.length; n++)
      m.add(i[n]);
  }
  var W = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), z = Object.prototype.hasOwnProperty, j = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Z = {}, H = {};
  function $(n) {
    return z.call(H, n) ? !0 : z.call(Z, n) ? !1 : j.test(n) ? H[n] = !0 : (Z[n] = !0, !1);
  }
  function J(n, i, l, p) {
    if (l !== null && l.type === 0)
      return !1;
    switch (typeof i) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return p ? !1 : l !== null ? !l.acceptsBooleans : (n = n.toLowerCase().slice(0, 5), n !== "data-" && n !== "aria-");
      default:
        return !1;
    }
  }
  function oe(n, i, l, p) {
    if (i === null || typeof i > "u" || J(n, i, l, p))
      return !0;
    if (p)
      return !1;
    if (l !== null)
      switch (l.type) {
        case 3:
          return !i;
        case 4:
          return i === !1;
        case 5:
          return isNaN(i);
        case 6:
          return isNaN(i) || 1 > i;
      }
    return !1;
  }
  function ce(n, i, l, p, g, S, R) {
    this.acceptsBooleans = i === 2 || i === 3 || i === 4, this.attributeName = p, this.attributeNamespace = g, this.mustUseProperty = l, this.propertyName = n, this.type = i, this.sanitizeURL = S, this.removeEmptyString = R;
  }
  var ue = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(n) {
    ue[n] = new ce(n, 0, !1, n, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(n) {
    var i = n[0];
    ue[i] = new ce(i, 1, !1, n[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n) {
    ue[n] = new ce(n, 2, !1, n.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n) {
    ue[n] = new ce(n, 2, !1, n, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(n) {
    ue[n] = new ce(n, 3, !1, n.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(n) {
    ue[n] = new ce(n, 3, !0, n, null, !1, !1);
  }), ["capture", "download"].forEach(function(n) {
    ue[n] = new ce(n, 4, !1, n, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(n) {
    ue[n] = new ce(n, 6, !1, n, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(n) {
    ue[n] = new ce(n, 5, !1, n.toLowerCase(), null, !1, !1);
  });
  var Ke = /[\-:]([a-z])/g;
  function He(n) {
    return n[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(n) {
    var i = n.replace(
      Ke,
      He
    );
    ue[i] = new ce(i, 1, !1, n, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(n) {
    var i = n.replace(Ke, He);
    ue[i] = new ce(i, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(n) {
    var i = n.replace(Ke, He);
    ue[i] = new ce(i, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(n) {
    ue[n] = new ce(n, 1, !1, n.toLowerCase(), null, !1, !1);
  }), ue.xlinkHref = new ce("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(n) {
    ue[n] = new ce(n, 1, !1, n.toLowerCase(), null, !0, !0);
  });
  function ve(n, i, l, p) {
    var g = ue.hasOwnProperty(i) ? ue[i] : null;
    (g !== null ? g.type !== 0 : p || !(2 < i.length) || i[0] !== "o" && i[0] !== "O" || i[1] !== "n" && i[1] !== "N") && (oe(i, l, g, p) && (l = null), p || g === null ? $(i) && (l === null ? n.removeAttribute(i) : n.setAttribute(i, "" + l)) : g.mustUseProperty ? n[g.propertyName] = l === null ? g.type === 3 ? !1 : "" : l : (i = g.attributeName, p = g.attributeNamespace, l === null ? n.removeAttribute(i) : (g = g.type, l = g === 3 || g === 4 && l === !0 ? "" : "" + l, p ? n.setAttributeNS(p, i, l) : n.setAttribute(i, l))));
  }
  var ye = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, G = Symbol.for("react.element"), Me = Symbol.for("react.portal"), ze = Symbol.for("react.fragment"), kt = Symbol.for("react.strict_mode"), It = Symbol.for("react.profiler"), Nt = Symbol.for("react.provider"), Xe = Symbol.for("react.context"), Mt = Symbol.for("react.forward_ref"), ut = Symbol.for("react.suspense"), lt = Symbol.for("react.suspense_list"), tn = Symbol.for("react.memo"), vt = Symbol.for("react.lazy"), Ne = Symbol.for("react.offscreen"), le = Symbol.iterator;
  function Je(n) {
    return n === null || typeof n != "object" ? null : (n = le && n[le] || n["@@iterator"], typeof n == "function" ? n : null);
  }
  var N = Object.assign, se;
  function xe(n) {
    if (se === void 0)
      try {
        throw Error();
      } catch (l) {
        var i = l.stack.trim().match(/\n( *(at )?)/);
        se = i && i[1] || "";
      }
    return `
` + se + n;
  }
  var et = !1;
  function je(n, i) {
    if (!n || et)
      return "";
    et = !0;
    var l = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (i)
        if (i = function() {
          throw Error();
        }, Object.defineProperty(i.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(i, []);
          } catch (ae) {
            var p = ae;
          }
          Reflect.construct(n, [], i);
        } else {
          try {
            i.call();
          } catch (ae) {
            p = ae;
          }
          n.call(i.prototype);
        }
      else {
        try {
          throw Error();
        } catch (ae) {
          p = ae;
        }
        n();
      }
    } catch (ae) {
      if (ae && p && typeof ae.stack == "string") {
        for (var g = ae.stack.split(`
`), S = p.stack.split(`
`), R = g.length - 1, P = S.length - 1; 1 <= R && 0 <= P && g[R] !== S[P]; )
          P--;
        for (; 1 <= R && 0 <= P; R--, P--)
          if (g[R] !== S[P]) {
            if (R !== 1 || P !== 1)
              do
                if (R--, P--, 0 > P || g[R] !== S[P]) {
                  var F = `
` + g[R].replace(" at new ", " at ");
                  return n.displayName && F.includes("<anonymous>") && (F = F.replace("<anonymous>", n.displayName)), F;
                }
              while (1 <= R && 0 <= P);
            break;
          }
      }
    } finally {
      et = !1, Error.prepareStackTrace = l;
    }
    return (n = n ? n.displayName || n.name : "") ? xe(n) : "";
  }
  function qe(n) {
    switch (n.tag) {
      case 5:
        return xe(n.type);
      case 16:
        return xe("Lazy");
      case 13:
        return xe("Suspense");
      case 19:
        return xe("SuspenseList");
      case 0:
      case 2:
      case 15:
        return n = je(n.type, !1), n;
      case 11:
        return n = je(n.type.render, !1), n;
      case 1:
        return n = je(n.type, !0), n;
      default:
        return "";
    }
  }
  function Oe(n) {
    if (n == null)
      return null;
    if (typeof n == "function")
      return n.displayName || n.name || null;
    if (typeof n == "string")
      return n;
    switch (n) {
      case ze:
        return "Fragment";
      case Me:
        return "Portal";
      case It:
        return "Profiler";
      case kt:
        return "StrictMode";
      case ut:
        return "Suspense";
      case lt:
        return "SuspenseList";
    }
    if (typeof n == "object")
      switch (n.$$typeof) {
        case Xe:
          return (n.displayName || "Context") + ".Consumer";
        case Nt:
          return (n._context.displayName || "Context") + ".Provider";
        case Mt:
          var i = n.render;
          return n = n.displayName, n || (n = i.displayName || i.name || "", n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"), n;
        case tn:
          return i = n.displayName || null, i !== null ? i : Oe(n.type) || "Memo";
        case vt:
          i = n._payload, n = n._init;
          try {
            return Oe(n(i));
          } catch {
          }
      }
    return null;
  }
  function Rt(n) {
    var i = n.type;
    switch (n.tag) {
      case 24:
        return "Cache";
      case 9:
        return (i.displayName || "Context") + ".Consumer";
      case 10:
        return (i._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return n = i.render, n = n.displayName || n.name || "", i.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return i;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Oe(i);
      case 8:
        return i === kt ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof i == "function")
          return i.displayName || i.name || null;
        if (typeof i == "string")
          return i;
    }
    return null;
  }
  function _t(n) {
    switch (typeof n) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return n;
      case "object":
        return n;
      default:
        return "";
    }
  }
  function on(n) {
    var i = n.type;
    return (n = n.nodeName) && n.toLowerCase() === "input" && (i === "checkbox" || i === "radio");
  }
  function Sr(n) {
    var i = on(n) ? "checked" : "value", l = Object.getOwnPropertyDescriptor(n.constructor.prototype, i), p = "" + n[i];
    if (!n.hasOwnProperty(i) && typeof l < "u" && typeof l.get == "function" && typeof l.set == "function") {
      var g = l.get, S = l.set;
      return Object.defineProperty(n, i, { configurable: !0, get: function() {
        return g.call(this);
      }, set: function(R) {
        p = "" + R, S.call(this, R);
      } }), Object.defineProperty(n, i, { enumerable: l.enumerable }), { getValue: function() {
        return p;
      }, setValue: function(R) {
        p = "" + R;
      }, stopTracking: function() {
        n._valueTracker = null, delete n[i];
      } };
    }
  }
  function ur(n) {
    n._valueTracker || (n._valueTracker = Sr(n));
  }
  function Ue(n) {
    if (!n)
      return !1;
    var i = n._valueTracker;
    if (!i)
      return !0;
    var l = i.getValue(), p = "";
    return n && (p = on(n) ? n.checked ? "true" : "false" : n.value), n = p, n !== l ? (i.setValue(n), !0) : !1;
  }
  function yn(n) {
    if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u")
      return null;
    try {
      return n.activeElement || n.body;
    } catch {
      return n.body;
    }
  }
  function Ie(n, i) {
    var l = i.checked;
    return N({}, i, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: l ?? n._wrapperState.initialChecked });
  }
  function zn(n, i) {
    var l = i.defaultValue == null ? "" : i.defaultValue, p = i.checked != null ? i.checked : i.defaultChecked;
    l = _t(i.value != null ? i.value : l), n._wrapperState = { initialChecked: p, initialValue: l, controlled: i.type === "checkbox" || i.type === "radio" ? i.checked != null : i.value != null };
  }
  function Xn(n, i) {
    i = i.checked, i != null && ve(n, "checked", i, !1);
  }
  function Bn(n, i) {
    Xn(n, i);
    var l = _t(i.value), p = i.type;
    if (l != null)
      p === "number" ? (l === 0 && n.value === "" || n.value != l) && (n.value = "" + l) : n.value !== "" + l && (n.value = "" + l);
    else if (p === "submit" || p === "reset") {
      n.removeAttribute("value");
      return;
    }
    i.hasOwnProperty("value") ? ki(n, i.type, l) : i.hasOwnProperty("defaultValue") && ki(n, i.type, _t(i.defaultValue)), i.checked == null && i.defaultChecked != null && (n.defaultChecked = !!i.defaultChecked);
  }
  function Hr(n, i, l) {
    if (i.hasOwnProperty("value") || i.hasOwnProperty("defaultValue")) {
      var p = i.type;
      if (!(p !== "submit" && p !== "reset" || i.value !== void 0 && i.value !== null))
        return;
      i = "" + n._wrapperState.initialValue, l || i === n.value || (n.value = i), n.defaultValue = i;
    }
    l = n.name, l !== "" && (n.name = ""), n.defaultChecked = !!n._wrapperState.initialChecked, l !== "" && (n.name = l);
  }
  function ki(n, i, l) {
    (i !== "number" || yn(n.ownerDocument) !== n) && (l == null ? n.defaultValue = "" + n._wrapperState.initialValue : n.defaultValue !== "" + l && (n.defaultValue = "" + l));
  }
  var Dr = Array.isArray;
  function zr(n, i, l, p) {
    if (n = n.options, i) {
      i = {};
      for (var g = 0; g < l.length; g++)
        i["$" + l[g]] = !0;
      for (l = 0; l < n.length; l++)
        g = i.hasOwnProperty("$" + n[l].value), n[l].selected !== g && (n[l].selected = g), g && p && (n[l].defaultSelected = !0);
    } else {
      for (l = "" + _t(l), i = null, g = 0; g < n.length; g++) {
        if (n[g].value === l) {
          n[g].selected = !0, p && (n[g].defaultSelected = !0);
          return;
        }
        i !== null || n[g].disabled || (i = n[g]);
      }
      i !== null && (i.selected = !0);
    }
  }
  function fi(n, i) {
    if (i.dangerouslySetInnerHTML != null)
      throw Error(d(91));
    return N({}, i, { value: void 0, defaultValue: void 0, children: "" + n._wrapperState.initialValue });
  }
  function Br(n, i) {
    var l = i.value;
    if (l == null) {
      if (l = i.children, i = i.defaultValue, l != null) {
        if (i != null)
          throw Error(d(92));
        if (Dr(l)) {
          if (1 < l.length)
            throw Error(d(93));
          l = l[0];
        }
        i = l;
      }
      i == null && (i = ""), l = i;
    }
    n._wrapperState = { initialValue: _t(l) };
  }
  function Yi(n, i) {
    var l = _t(i.value), p = _t(i.defaultValue);
    l != null && (l = "" + l, l !== n.value && (n.value = l), i.defaultValue == null && n.defaultValue !== l && (n.defaultValue = l)), p != null && (n.defaultValue = "" + p);
  }
  function Yr(n) {
    var i = n.textContent;
    i === n._wrapperState.initialValue && i !== "" && i !== null && (n.value = i);
  }
  function Xr(n) {
    switch (n) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function er(n, i) {
    return n == null || n === "http://www.w3.org/1999/xhtml" ? Xr(i) : n === "http://www.w3.org/2000/svg" && i === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n;
  }
  var Jr, Qa = function(n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(i, l, p, g) {
      MSApp.execUnsafeLocalFunction(function() {
        return n(i, l, p, g);
      });
    } : n;
  }(function(n, i) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n)
      n.innerHTML = i;
    else {
      for (Jr = Jr || document.createElement("div"), Jr.innerHTML = "<svg>" + i.valueOf().toString() + "</svg>", i = Jr.firstChild; n.firstChild; )
        n.removeChild(n.firstChild);
      for (; i.firstChild; )
        n.appendChild(i.firstChild);
    }
  });
  function Oi(n, i) {
    if (i) {
      var l = n.firstChild;
      if (l && l === n.lastChild && l.nodeType === 3) {
        l.nodeValue = i;
        return;
      }
    }
    n.textContent = i;
  }
  var De = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, ft = ["Webkit", "ms", "Moz", "O"];
  Object.keys(De).forEach(function(n) {
    ft.forEach(function(i) {
      i = i + n.charAt(0).toUpperCase() + n.substring(1), De[i] = De[n];
    });
  });
  function Yt(n, i, l) {
    return i == null || typeof i == "boolean" || i === "" ? "" : l || typeof i != "number" || i === 0 || De.hasOwnProperty(n) && De[n] ? ("" + i).trim() : i + "px";
  }
  function dn(n, i) {
    n = n.style;
    for (var l in i)
      if (i.hasOwnProperty(l)) {
        var p = l.indexOf("--") === 0, g = Yt(l, i[l], p);
        l === "float" && (l = "cssFloat"), p ? n.setProperty(l, g) : n[l] = g;
      }
  }
  var gn = N({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function dr(n, i) {
    if (i) {
      if (gn[n] && (i.children != null || i.dangerouslySetInnerHTML != null))
        throw Error(d(137, n));
      if (i.dangerouslySetInnerHTML != null) {
        if (i.children != null)
          throw Error(d(60));
        if (typeof i.dangerouslySetInnerHTML != "object" || !("__html" in i.dangerouslySetInnerHTML))
          throw Error(d(61));
      }
      if (i.style != null && typeof i.style != "object")
        throw Error(d(62));
    }
  }
  function Un(n, i) {
    if (n.indexOf("-") === -1)
      return typeof i.is == "string";
    switch (n) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var ei = null;
  function bn(n) {
    return n = n.target || n.srcElement || window, n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === 3 ? n.parentNode : n;
  }
  var ti = null, _n = null, Sn = null;
  function Ma(n) {
    if (n = Hs(n)) {
      if (typeof ti != "function")
        throw Error(d(280));
      var i = n.stateNode;
      i && (i = pt(i), ti(n.stateNode, n.type, i));
    }
  }
  function ia(n) {
    _n ? Sn ? Sn.push(n) : Sn = [n] : _n = n;
  }
  function ns() {
    if (_n) {
      var n = _n, i = Sn;
      if (Sn = _n = null, Ma(n), i)
        for (n = 0; n < i.length; n++)
          Ma(i[n]);
    }
  }
  function Ls(n, i) {
    return n(i);
  }
  function hu() {
  }
  var Lo = !1;
  function qa(n, i, l) {
    if (Lo)
      return n(i, l);
    Lo = !0;
    try {
      return Ls(n, i, l);
    } finally {
      Lo = !1, (_n !== null || Sn !== null) && (hu(), ns());
    }
  }
  function Vi(n, i) {
    var l = n.stateNode;
    if (l === null)
      return null;
    var p = pt(l);
    if (p === null)
      return null;
    l = p[i];
    e:
      switch (i) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (p = !p.disabled) || (n = n.type, p = !(n === "button" || n === "input" || n === "select" || n === "textarea")), n = !p;
          break e;
        default:
          n = !1;
      }
    if (n)
      return null;
    if (l && typeof l != "function")
      throw Error(d(231, i, typeof l));
    return l;
  }
  var Ka = !1;
  if (W)
    try {
      var Wi = {};
      Object.defineProperty(Wi, "passive", { get: function() {
        Ka = !0;
      } }), window.addEventListener("test", Wi, Wi), window.removeEventListener("test", Wi, Wi);
    } catch {
      Ka = !1;
    }
  function Xa(n, i, l, p, g, S, R, P, F) {
    var ae = Array.prototype.slice.call(arguments, 3);
    try {
      i.apply(l, ae);
    } catch (we) {
      this.onError(we);
    }
  }
  var tr = !1, We = null, Ra = !1, U = null, _e = { onError: function(n) {
    tr = !0, We = n;
  } };
  function ke(n, i, l, p, g, S, R, P, F) {
    tr = !1, We = null, Xa.apply(_e, arguments);
  }
  function Be(n, i, l, p, g, S, R, P, F) {
    if (ke.apply(this, arguments), tr) {
      if (tr) {
        var ae = We;
        tr = !1, We = null;
      } else
        throw Error(d(198));
      Ra || (Ra = !0, U = ae);
    }
  }
  function Ut(n) {
    var i = n, l = n;
    if (n.alternate)
      for (; i.return; )
        i = i.return;
    else {
      n = i;
      do
        i = n, i.flags & 4098 && (l = i.return), n = i.return;
      while (n);
    }
    return i.tag === 3 ? l : null;
  }
  function $t(n) {
    if (n.tag === 13) {
      var i = n.memoizedState;
      if (i === null && (n = n.alternate, n !== null && (i = n.memoizedState)), i !== null)
        return i.dehydrated;
    }
    return null;
  }
  function jt(n) {
    if (Ut(n) !== n)
      throw Error(d(188));
  }
  function mt(n) {
    var i = n.alternate;
    if (!i) {
      if (i = Ut(n), i === null)
        throw Error(d(188));
      return i !== n ? null : n;
    }
    for (var l = n, p = i; ; ) {
      var g = l.return;
      if (g === null)
        break;
      var S = g.alternate;
      if (S === null) {
        if (p = g.return, p !== null) {
          l = p;
          continue;
        }
        break;
      }
      if (g.child === S.child) {
        for (S = g.child; S; ) {
          if (S === l)
            return jt(g), n;
          if (S === p)
            return jt(g), i;
          S = S.sibling;
        }
        throw Error(d(188));
      }
      if (l.return !== p.return)
        l = g, p = S;
      else {
        for (var R = !1, P = g.child; P; ) {
          if (P === l) {
            R = !0, l = g, p = S;
            break;
          }
          if (P === p) {
            R = !0, p = g, l = S;
            break;
          }
          P = P.sibling;
        }
        if (!R) {
          for (P = S.child; P; ) {
            if (P === l) {
              R = !0, l = S, p = g;
              break;
            }
            if (P === p) {
              R = !0, p = S, l = g;
              break;
            }
            P = P.sibling;
          }
          if (!R)
            throw Error(d(189));
        }
      }
      if (l.alternate !== p)
        throw Error(d(190));
    }
    if (l.tag !== 3)
      throw Error(d(188));
    return l.stateNode.current === l ? n : i;
  }
  function wr(n) {
    return n = mt(n), n !== null ? Yn(n) : null;
  }
  function Yn(n) {
    if (n.tag === 5 || n.tag === 6)
      return n;
    for (n = n.child; n !== null; ) {
      var i = Yn(n);
      if (i !== null)
        return i;
      n = n.sibling;
    }
    return null;
  }
  var Vn = c.unstable_scheduleCallback, Ur = c.unstable_cancelCallback, Ja = c.unstable_shouldYield, No = c.unstable_requestPaint, cn = c.unstable_now, yf = c.unstable_getCurrentPriorityLevel, Da = c.unstable_ImmediatePriority, Gt = c.unstable_UserBlockingPriority, eo = c.unstable_NormalPriority, to = c.unstable_LowPriority, no = c.unstable_IdlePriority, Po = null, di = null;
  function Ao(n) {
    if (di && typeof di.onCommitFiberRoot == "function")
      try {
        di.onCommitFiberRoot(Po, n, void 0, (n.current.flags & 128) === 128);
      } catch {
      }
  }
  var Pt = Math.clz32 ? Math.clz32 : zo, In = Math.log, rs = Math.LN2;
  function zo(n) {
    return n >>>= 0, n === 0 ? 32 : 31 - (In(n) / rs | 0) | 0;
  }
  var ka = 64, ro = 4194304;
  function xt(n) {
    switch (n & -n) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return n & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return n & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return n;
    }
  }
  function sn(n, i) {
    var l = n.pendingLanes;
    if (l === 0)
      return 0;
    var p = 0, g = n.suspendedLanes, S = n.pingedLanes, R = l & 268435455;
    if (R !== 0) {
      var P = R & ~g;
      P !== 0 ? p = xt(P) : (S &= R, S !== 0 && (p = xt(S)));
    } else
      R = l & ~g, R !== 0 ? p = xt(R) : S !== 0 && (p = xt(S));
    if (p === 0)
      return 0;
    if (i !== 0 && i !== p && !(i & g) && (g = p & -p, S = i & -i, g >= S || g === 16 && (S & 4194240) !== 0))
      return i;
    if (p & 4 && (p |= l & 16), i = n.entangledLanes, i !== 0)
      for (n = n.entanglements, i &= p; 0 < i; )
        l = 31 - Pt(i), g = 1 << l, p |= n[l], i &= ~g;
    return p;
  }
  function io(n, i) {
    switch (n) {
      case 1:
      case 2:
      case 4:
        return i + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Oa(n, i) {
    for (var l = n.suspendedLanes, p = n.pingedLanes, g = n.expirationTimes, S = n.pendingLanes; 0 < S; ) {
      var R = 31 - Pt(S), P = 1 << R, F = g[R];
      F === -1 ? (!(P & l) || P & p) && (g[R] = io(P, i)) : F <= i && (n.expiredLanes |= P), S &= ~P;
    }
  }
  function kr(n) {
    return n = n.pendingLanes & -1073741825, n !== 0 ? n : n & 1073741824 ? 1073741824 : 0;
  }
  function pu() {
    var n = ka;
    return ka <<= 1, !(ka & 4194240) && (ka = 64), n;
  }
  function Uo(n) {
    for (var i = [], l = 0; 31 > l; l++)
      i.push(n);
    return i;
  }
  function hi(n, i, l) {
    n.pendingLanes |= i, i !== 536870912 && (n.suspendedLanes = 0, n.pingedLanes = 0), n = n.eventTimes, i = 31 - Pt(i), n[i] = l;
  }
  function lr(n, i) {
    var l = n.pendingLanes & ~i;
    n.pendingLanes = i, n.suspendedLanes = 0, n.pingedLanes = 0, n.expiredLanes &= i, n.mutableReadLanes &= i, n.entangledLanes &= i, i = n.entanglements;
    var p = n.eventTimes;
    for (n = n.expirationTimes; 0 < l; ) {
      var g = 31 - Pt(l), S = 1 << g;
      i[g] = 0, p[g] = -1, n[g] = -1, l &= ~S;
    }
  }
  function ni(n, i) {
    var l = n.entangledLanes |= i;
    for (n = n.entanglements; l; ) {
      var p = 31 - Pt(l), g = 1 << p;
      g & i | n[p] & i && (n[p] |= i), l &= ~g;
    }
  }
  var nn = 0;
  function ao(n) {
    return n &= -n, 1 < n ? 4 < n ? n & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Io, oo, rn, is, jo, Ot = !1, Fo = [], Wn = null, pi = null, Vr = null, as = /* @__PURE__ */ new Map(), nt = /* @__PURE__ */ new Map(), Qt = [], Mn = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function vi(n, i) {
    switch (n) {
      case "focusin":
      case "focusout":
        Wn = null;
        break;
      case "dragenter":
      case "dragleave":
        pi = null;
        break;
      case "mouseover":
      case "mouseout":
        Vr = null;
        break;
      case "pointerover":
      case "pointerout":
        as.delete(i.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        nt.delete(i.pointerId);
    }
  }
  function Er(n, i, l, p, g, S) {
    return n === null || n.nativeEvent !== S ? (n = { blockedOn: i, domEventName: l, eventSystemFlags: p, nativeEvent: S, targetContainers: [g] }, i !== null && (i = Hs(i), i !== null && oo(i)), n) : (n.eventSystemFlags |= p, i = n.targetContainers, g !== null && i.indexOf(g) === -1 && i.push(g), n);
  }
  function aa(n, i, l, p, g) {
    switch (i) {
      case "focusin":
        return Wn = Er(Wn, n, i, l, p, g), !0;
      case "dragenter":
        return pi = Er(pi, n, i, l, p, g), !0;
      case "mouseover":
        return Vr = Er(Vr, n, i, l, p, g), !0;
      case "pointerover":
        var S = g.pointerId;
        return as.set(S, Er(as.get(S) || null, n, i, l, p, g)), !0;
      case "gotpointercapture":
        return S = g.pointerId, nt.set(S, Er(nt.get(S) || null, n, i, l, p, g)), !0;
    }
    return !1;
  }
  function vu(n) {
    var i = ca(n.target);
    if (i !== null) {
      var l = Ut(i);
      if (l !== null) {
        if (i = l.tag, i === 13) {
          if (i = $t(l), i !== null) {
            n.blockedOn = i, jo(n.priority, function() {
              rn(l);
            });
            return;
          }
        } else if (i === 3 && l.stateNode.current.memoizedState.isDehydrated) {
          n.blockedOn = l.tag === 3 ? l.stateNode.containerInfo : null;
          return;
        }
      }
    }
    n.blockedOn = null;
  }
  function mi(n) {
    if (n.blockedOn !== null)
      return !1;
    for (var i = n.targetContainers; 0 < i.length; ) {
      var l = Ps(n.domEventName, n.eventSystemFlags, i[0], n.nativeEvent);
      if (l === null) {
        l = n.nativeEvent;
        var p = new l.constructor(l.type, l);
        ei = p, l.target.dispatchEvent(p), ei = null;
      } else
        return i = Hs(l), i !== null && oo(i), n.blockedOn = l, !1;
      i.shift();
    }
    return !0;
  }
  function so(n, i, l) {
    mi(n) && l.delete(i);
  }
  function os() {
    Ot = !1, Wn !== null && mi(Wn) && (Wn = null), pi !== null && mi(pi) && (pi = null), Vr !== null && mi(Vr) && (Vr = null), as.forEach(so), nt.forEach(so);
  }
  function Dn(n, i) {
    n.blockedOn === i && (n.blockedOn = null, Ot || (Ot = !0, c.unstable_scheduleCallback(c.unstable_NormalPriority, os)));
  }
  function Li(n) {
    function i(g) {
      return Dn(g, n);
    }
    if (0 < Fo.length) {
      Dn(Fo[0], n);
      for (var l = 1; l < Fo.length; l++) {
        var p = Fo[l];
        p.blockedOn === n && (p.blockedOn = null);
      }
    }
    for (Wn !== null && Dn(Wn, n), pi !== null && Dn(pi, n), Vr !== null && Dn(Vr, n), as.forEach(i), nt.forEach(i), l = 0; l < Qt.length; l++)
      p = Qt[l], p.blockedOn === n && (p.blockedOn = null);
    for (; 0 < Qt.length && (l = Qt[0], l.blockedOn === null); )
      vu(l), l.blockedOn === null && Qt.shift();
  }
  var Ho = ye.ReactCurrentBatchConfig, Zi = !0;
  function mu(n, i, l, p) {
    var g = nn, S = Ho.transition;
    Ho.transition = null;
    try {
      nn = 1, uo(n, i, l, p);
    } finally {
      nn = g, Ho.transition = S;
    }
  }
  function Bo(n, i, l, p) {
    var g = nn, S = Ho.transition;
    Ho.transition = null;
    try {
      nn = 4, uo(n, i, l, p);
    } finally {
      nn = g, Ho.transition = S;
    }
  }
  function uo(n, i, l, p) {
    if (Zi) {
      var g = Ps(n, i, l, p);
      if (g === null)
        r(n, i, p, Ns, l), vi(n, p);
      else if (aa(g, n, i, l, p))
        p.stopPropagation();
      else if (vi(n, p), i & 4 && -1 < Mn.indexOf(n)) {
        for (; g !== null; ) {
          var S = Hs(g);
          if (S !== null && Io(S), S = Ps(n, i, l, p), S === null && r(n, i, p, Ns, l), S === g)
            break;
          g = S;
        }
        g !== null && p.stopPropagation();
      } else
        r(n, i, p, null, l);
    }
  }
  var Ns = null;
  function Ps(n, i, l, p) {
    if (Ns = null, n = bn(p), n = ca(n), n !== null)
      if (i = Ut(n), i === null)
        n = null;
      else if (l = i.tag, l === 13) {
        if (n = $t(i), n !== null)
          return n;
        n = null;
      } else if (l === 3) {
        if (i.stateNode.current.memoizedState.isDehydrated)
          return i.tag === 3 ? i.stateNode.containerInfo : null;
        n = null;
      } else
        i !== n && (n = null);
    return Ns = n, null;
  }
  function Kt(n) {
    switch (n) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (yf()) {
          case Da:
            return 1;
          case Gt:
            return 4;
          case eo:
          case to:
            return 16;
          case no:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var La = null, b = null, A = null;
  function te() {
    if (A)
      return A;
    var n, i = b, l = i.length, p, g = "value" in La ? La.value : La.textContent, S = g.length;
    for (n = 0; n < l && i[n] === g[n]; n++)
      ;
    var R = l - n;
    for (p = 1; p <= R && i[l - p] === g[S - p]; p++)
      ;
    return A = g.slice(n, 1 < p ? 1 - p : void 0);
  }
  function fe(n) {
    var i = n.keyCode;
    return "charCode" in n ? (n = n.charCode, n === 0 && i === 13 && (n = 13)) : n = i, n === 10 && (n = 13), 32 <= n || n === 13 ? n : 0;
  }
  function Ce() {
    return !0;
  }
  function St() {
    return !1;
  }
  function Le(n) {
    function i(l, p, g, S, R) {
      this._reactName = l, this._targetInst = g, this.type = p, this.nativeEvent = S, this.target = R, this.currentTarget = null;
      for (var P in n)
        n.hasOwnProperty(P) && (l = n[P], this[P] = l ? l(S) : S[P]);
      return this.isDefaultPrevented = (S.defaultPrevented != null ? S.defaultPrevented : S.returnValue === !1) ? Ce : St, this.isPropagationStopped = St, this;
    }
    return N(i.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var l = this.nativeEvent;
      l && (l.preventDefault ? l.preventDefault() : typeof l.returnValue != "unknown" && (l.returnValue = !1), this.isDefaultPrevented = Ce);
    }, stopPropagation: function() {
      var l = this.nativeEvent;
      l && (l.stopPropagation ? l.stopPropagation() : typeof l.cancelBubble != "unknown" && (l.cancelBubble = !0), this.isPropagationStopped = Ce);
    }, persist: function() {
    }, isPersistent: Ce }), i;
  }
  var gt = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(n) {
    return n.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, qt = Le(gt), an = N({}, gt, { view: 0, detail: 0 }), jn = Le(an), Xt, Fn, Hn, Ht = N({}, an, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Us, button: 0, buttons: 0, relatedTarget: function(n) {
    return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget;
  }, movementX: function(n) {
    return "movementX" in n ? n.movementX : (n !== Hn && (Hn && n.type === "mousemove" ? (Xt = n.screenX - Hn.screenX, Fn = n.screenY - Hn.screenY) : Fn = Xt = 0, Hn = n), Xt);
  }, movementY: function(n) {
    return "movementY" in n ? n.movementY : Fn;
  } }), lo = Le(Ht), As = N({}, Ht, { dataTransfer: 0 }), zs = Le(As), gf = N({}, an, { relatedTarget: 0 }), oa = Le(gf), yu = N({}, gt, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), al = Le(yu), _f = N({}, gt, { clipboardData: function(n) {
    return "clipboardData" in n ? n.clipboardData : window.clipboardData;
  } }), Sf = Le(_f), gp = N({}, gt, { data: 0 }), sc = Le(gp), uc = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, ol = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, ss = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Sd(n) {
    var i = this.nativeEvent;
    return i.getModifierState ? i.getModifierState(n) : (n = ss[n]) ? !!i[n] : !1;
  }
  function Us() {
    return Sd;
  }
  var Tr = N({}, an, { key: function(n) {
    if (n.key) {
      var i = uc[n.key] || n.key;
      if (i !== "Unidentified")
        return i;
    }
    return n.type === "keypress" ? (n = fe(n), n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? ol[n.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Us, charCode: function(n) {
    return n.type === "keypress" ? fe(n) : 0;
  }, keyCode: function(n) {
    return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
  }, which: function(n) {
    return n.type === "keypress" ? fe(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
  } }), wd = Le(Tr), lc = N({}, Ht, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), cc = Le(lc), sl = N({}, an, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Us }), wf = Le(sl), fc = N({}, gt, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Ed = Le(fc), yi = N({}, Ht, {
    deltaX: function(n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function(n) {
      return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Yo = Le(yi), En = [9, 13, 27, 32], ri = W && "CompositionEvent" in window, Is = null;
  W && "documentMode" in document && (Is = document.documentMode);
  var sa = W && "TextEvent" in window && !Is, Td = W && (!ri || Is && 8 < Is && 11 >= Is), Na = String.fromCharCode(32), Cd = !1;
  function gu(n, i) {
    switch (n) {
      case "keyup":
        return En.indexOf(i.keyCode) !== -1;
      case "keydown":
        return i.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function ul(n) {
    return n = n.detail, typeof n == "object" && "data" in n ? n.data : null;
  }
  var Vo = !1;
  function _p(n, i) {
    switch (n) {
      case "compositionend":
        return ul(i);
      case "keypress":
        return i.which !== 32 ? null : (Cd = !0, Na);
      case "textInput":
        return n = i.data, n === Na && Cd ? null : n;
      default:
        return null;
    }
  }
  function us(n, i) {
    if (Vo)
      return n === "compositionend" || !ri && gu(n, i) ? (n = te(), A = b = La = null, Vo = !1, n) : null;
    switch (n) {
      case "paste":
        return null;
      case "keypress":
        if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
          if (i.char && 1 < i.char.length)
            return i.char;
          if (i.which)
            return String.fromCharCode(i.which);
        }
        return null;
      case "compositionend":
        return Td && i.locale !== "ko" ? null : i.data;
      default:
        return null;
    }
  }
  var ll = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function xd(n) {
    var i = n && n.nodeName && n.nodeName.toLowerCase();
    return i === "input" ? !!ll[n.type] : i === "textarea";
  }
  function dc(n, i, l, p) {
    ia(p), i = h(i, "onChange"), 0 < i.length && (l = new qt("onChange", "change", null, l, p), n.push({ event: l, listeners: i }));
  }
  var cl = null, Ni = null;
  function _u(n) {
    ml(n, 0);
  }
  function Pa(n) {
    var i = Bs(n);
    if (Ue(i))
      return n;
  }
  function bd(n, i) {
    if (n === "change")
      return i;
  }
  var Aa = !1;
  if (W) {
    var Su;
    if (W) {
      var hc = "oninput" in document;
      if (!hc) {
        var pc = document.createElement("div");
        pc.setAttribute("oninput", "return;"), hc = typeof pc.oninput == "function";
      }
      Su = hc;
    } else
      Su = !1;
    Aa = Su && (!document.documentMode || 9 < document.documentMode);
  }
  function fl() {
    cl && (cl.detachEvent("onpropertychange", vc), Ni = cl = null);
  }
  function vc(n) {
    if (n.propertyName === "value" && Pa(Ni)) {
      var i = [];
      dc(i, Ni, n, bn(n)), qa(_u, i);
    }
  }
  function mc(n, i, l) {
    n === "focusin" ? (fl(), cl = i, Ni = l, cl.attachEvent("onpropertychange", vc)) : n === "focusout" && fl();
  }
  function wu(n) {
    if (n === "selectionchange" || n === "keyup" || n === "keydown")
      return Pa(Ni);
  }
  function yc(n, i) {
    if (n === "click")
      return Pa(i);
  }
  function gc(n, i) {
    if (n === "input" || n === "change")
      return Pa(i);
  }
  function Md(n, i) {
    return n === i && (n !== 0 || 1 / n === 1 / i) || n !== n && i !== i;
  }
  var ua = typeof Object.is == "function" ? Object.is : Md;
  function ls(n, i) {
    if (ua(n, i))
      return !0;
    if (typeof n != "object" || n === null || typeof i != "object" || i === null)
      return !1;
    var l = Object.keys(n), p = Object.keys(i);
    if (l.length !== p.length)
      return !1;
    for (p = 0; p < l.length; p++) {
      var g = l[p];
      if (!z.call(i, g) || !ua(n[g], i[g]))
        return !1;
    }
    return !0;
  }
  function Rd(n) {
    for (; n && n.firstChild; )
      n = n.firstChild;
    return n;
  }
  function Ef(n, i) {
    var l = Rd(n);
    n = 0;
    for (var p; l; ) {
      if (l.nodeType === 3) {
        if (p = n + l.textContent.length, n <= i && p >= i)
          return { node: l, offset: i - n };
        n = p;
      }
      e: {
        for (; l; ) {
          if (l.nextSibling) {
            l = l.nextSibling;
            break e;
          }
          l = l.parentNode;
        }
        l = void 0;
      }
      l = Rd(l);
    }
  }
  function Dd(n, i) {
    return n && i ? n === i ? !0 : n && n.nodeType === 3 ? !1 : i && i.nodeType === 3 ? Dd(n, i.parentNode) : "contains" in n ? n.contains(i) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(i) & 16) : !1 : !1;
  }
  function dl() {
    for (var n = window, i = yn(); i instanceof n.HTMLIFrameElement; ) {
      try {
        var l = typeof i.contentWindow.location.href == "string";
      } catch {
        l = !1;
      }
      if (l)
        n = i.contentWindow;
      else
        break;
      i = yn(n.document);
    }
    return i;
  }
  function Wo(n) {
    var i = n && n.nodeName && n.nodeName.toLowerCase();
    return i && (i === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || i === "textarea" || n.contentEditable === "true");
  }
  function $i(n) {
    var i = dl(), l = n.focusedElem, p = n.selectionRange;
    if (i !== l && l && l.ownerDocument && Dd(l.ownerDocument.documentElement, l)) {
      if (p !== null && Wo(l)) {
        if (i = p.start, n = p.end, n === void 0 && (n = i), "selectionStart" in l)
          l.selectionStart = i, l.selectionEnd = Math.min(n, l.value.length);
        else if (n = (i = l.ownerDocument || document) && i.defaultView || window, n.getSelection) {
          n = n.getSelection();
          var g = l.textContent.length, S = Math.min(p.start, g);
          p = p.end === void 0 ? S : Math.min(p.end, g), !n.extend && S > p && (g = p, p = S, S = g), g = Ef(l, S);
          var R = Ef(
            l,
            p
          );
          g && R && (n.rangeCount !== 1 || n.anchorNode !== g.node || n.anchorOffset !== g.offset || n.focusNode !== R.node || n.focusOffset !== R.offset) && (i = i.createRange(), i.setStart(g.node, g.offset), n.removeAllRanges(), S > p ? (n.addRange(i), n.extend(R.node, R.offset)) : (i.setEnd(R.node, R.offset), n.addRange(i)));
        }
      }
      for (i = [], n = l; n = n.parentNode; )
        n.nodeType === 1 && i.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
      for (typeof l.focus == "function" && l.focus(), l = 0; l < i.length; l++)
        n = i[l], n.element.scrollLeft = n.left, n.element.scrollTop = n.top;
    }
  }
  var hl = W && "documentMode" in document && 11 >= document.documentMode, za = null, Eu = null, pl = null, _c = !1;
  function kd(n, i, l) {
    var p = l.window === l ? l.document : l.nodeType === 9 ? l : l.ownerDocument;
    _c || za == null || za !== yn(p) || (p = za, "selectionStart" in p && Wo(p) ? p = { start: p.selectionStart, end: p.selectionEnd } : (p = (p.ownerDocument && p.ownerDocument.defaultView || window).getSelection(), p = { anchorNode: p.anchorNode, anchorOffset: p.anchorOffset, focusNode: p.focusNode, focusOffset: p.focusOffset }), pl && ls(pl, p) || (pl = p, p = h(Eu, "onSelect"), 0 < p.length && (i = new qt("onSelect", "select", null, i, l), n.push({ event: i, listeners: p }), i.target = za)));
  }
  function cs(n, i) {
    var l = {};
    return l[n.toLowerCase()] = i.toLowerCase(), l["Webkit" + n] = "webkit" + i, l["Moz" + n] = "moz" + i, l;
  }
  var js = { animationend: cs("Animation", "AnimationEnd"), animationiteration: cs("Animation", "AnimationIteration"), animationstart: cs("Animation", "AnimationStart"), transitionend: cs("Transition", "TransitionEnd") }, fs = {}, Sc = {};
  W && (Sc = document.createElement("div").style, "AnimationEvent" in window || (delete js.animationend.animation, delete js.animationiteration.animation, delete js.animationstart.animation), "TransitionEvent" in window || delete js.transitionend.transition);
  function Or(n) {
    if (fs[n])
      return fs[n];
    if (!js[n])
      return n;
    var i = js[n], l;
    for (l in i)
      if (i.hasOwnProperty(l) && l in Sc)
        return fs[n] = i[l];
    return n;
  }
  var Tf = Or("animationend"), co = Or("animationiteration"), Cf = Or("animationstart"), xf = Or("transitionend"), Tu = /* @__PURE__ */ new Map(), Od = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function la(n, i) {
    Tu.set(n, i), M(i, [n]);
  }
  for (var Zo = 0; Zo < Od.length; Zo++) {
    var ds = Od[Zo], Ld = ds.toLowerCase(), vl = ds[0].toUpperCase() + ds.slice(1);
    la(Ld, "on" + vl);
  }
  la(Tf, "onAnimationEnd"), la(co, "onAnimationIteration"), la(Cf, "onAnimationStart"), la("dblclick", "onDoubleClick"), la("focusin", "onFocus"), la("focusout", "onBlur"), la(xf, "onTransitionEnd"), C("onMouseEnter", ["mouseout", "mouseover"]), C("onMouseLeave", ["mouseout", "mouseover"]), C("onPointerEnter", ["pointerout", "pointerover"]), C("onPointerLeave", ["pointerout", "pointerover"]), M("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), M("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), M("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), M("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), M("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), M("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Cu = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Nd = new Set("cancel close invalid load scroll toggle".split(" ").concat(Cu));
  function bf(n, i, l) {
    var p = n.type || "unknown-event";
    n.currentTarget = l, Be(p, i, void 0, n), n.currentTarget = null;
  }
  function ml(n, i) {
    i = (i & 4) !== 0;
    for (var l = 0; l < n.length; l++) {
      var p = n[l], g = p.event;
      p = p.listeners;
      e: {
        var S = void 0;
        if (i)
          for (var R = p.length - 1; 0 <= R; R--) {
            var P = p[R], F = P.instance, ae = P.currentTarget;
            if (P = P.listener, F !== S && g.isPropagationStopped())
              break e;
            bf(g, P, ae), S = F;
          }
        else
          for (R = 0; R < p.length; R++) {
            if (P = p[R], F = P.instance, ae = P.currentTarget, P = P.listener, F !== S && g.isPropagationStopped())
              break e;
            bf(g, P, ae), S = F;
          }
      }
    }
    if (Ra)
      throw n = U, Ra = !1, U = null, n;
  }
  function kn(n, i) {
    var l = i[bu];
    l === void 0 && (l = i[bu] = /* @__PURE__ */ new Set());
    var p = n + "__bubble";
    l.has(p) || (Pd(i, n, 2, !1), l.add(p));
  }
  function hs(n, i, l) {
    var p = 0;
    i && (p |= 4), Pd(l, n, p, i);
  }
  var fo = "_reactListening" + Math.random().toString(36).slice(2);
  function Fs(n) {
    if (!n[fo]) {
      n[fo] = !0, m.forEach(function(l) {
        l !== "selectionchange" && (Nd.has(l) || hs(l, !1, n), hs(l, !0, n));
      });
      var i = n.nodeType === 9 ? n : n.ownerDocument;
      i === null || i[fo] || (i[fo] = !0, hs("selectionchange", !1, i));
    }
  }
  function Pd(n, i, l, p) {
    switch (Kt(i)) {
      case 1:
        var g = mu;
        break;
      case 4:
        g = Bo;
        break;
      default:
        g = uo;
    }
    l = g.bind(null, i, l, n), g = void 0, !Ka || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (g = !0), p ? g !== void 0 ? n.addEventListener(i, l, { capture: !0, passive: g }) : n.addEventListener(i, l, !0) : g !== void 0 ? n.addEventListener(i, l, { passive: g }) : n.addEventListener(i, l, !1);
  }
  function r(n, i, l, p, g) {
    var S = p;
    if (!(i & 1) && !(i & 2) && p !== null)
      e:
        for (; ; ) {
          if (p === null)
            return;
          var R = p.tag;
          if (R === 3 || R === 4) {
            var P = p.stateNode.containerInfo;
            if (P === g || P.nodeType === 8 && P.parentNode === g)
              break;
            if (R === 4)
              for (R = p.return; R !== null; ) {
                var F = R.tag;
                if ((F === 3 || F === 4) && (F = R.stateNode.containerInfo, F === g || F.nodeType === 8 && F.parentNode === g))
                  return;
                R = R.return;
              }
            for (; P !== null; ) {
              if (R = ca(P), R === null)
                return;
              if (F = R.tag, F === 5 || F === 6) {
                p = S = R;
                continue e;
              }
              P = P.parentNode;
            }
          }
          p = p.return;
        }
    qa(function() {
      var ae = S, we = bn(l), Ee = [];
      e: {
        var Se = Tu.get(n);
        if (Se !== void 0) {
          var Ze = qt, it = n;
          switch (n) {
            case "keypress":
              if (fe(l) === 0)
                break e;
            case "keydown":
            case "keyup":
              Ze = wd;
              break;
            case "focusin":
              it = "focus", Ze = oa;
              break;
            case "focusout":
              it = "blur", Ze = oa;
              break;
            case "beforeblur":
            case "afterblur":
              Ze = oa;
              break;
            case "click":
              if (l.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Ze = lo;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Ze = zs;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Ze = wf;
              break;
            case Tf:
            case co:
            case Cf:
              Ze = al;
              break;
            case xf:
              Ze = Ed;
              break;
            case "scroll":
              Ze = jn;
              break;
            case "wheel":
              Ze = Yo;
              break;
            case "copy":
            case "cut":
            case "paste":
              Ze = Sf;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Ze = cc;
          }
          var st = (i & 4) !== 0, Pr = !st && n === "scroll", q = st ? Se !== null ? Se + "Capture" : null : Se;
          st = [];
          for (var Y = ae, ee; Y !== null; ) {
            ee = Y;
            var Re = ee.stateNode;
            if (ee.tag === 5 && Re !== null && (ee = Re, q !== null && (Re = Vi(Y, q), Re != null && st.push(u(Y, Re, ee)))), Pr)
              break;
            Y = Y.return;
          }
          0 < st.length && (Se = new Ze(Se, it, null, l, we), Ee.push({ event: Se, listeners: st }));
        }
      }
      if (!(i & 7)) {
        e: {
          if (Se = n === "mouseover" || n === "pointerover", Ze = n === "mouseout" || n === "pointerout", Se && l !== ei && (it = l.relatedTarget || l.fromElement) && (ca(it) || it[On]))
            break e;
          if ((Ze || Se) && (Se = we.window === we ? we : (Se = we.ownerDocument) ? Se.defaultView || Se.parentWindow : window, Ze ? (it = l.relatedTarget || l.toElement, Ze = ae, it = it ? ca(it) : null, it !== null && (Pr = Ut(it), it !== Pr || it.tag !== 5 && it.tag !== 6) && (it = null)) : (Ze = null, it = ae), Ze !== it)) {
            if (st = lo, Re = "onMouseLeave", q = "onMouseEnter", Y = "mouse", (n === "pointerout" || n === "pointerover") && (st = cc, Re = "onPointerLeave", q = "onPointerEnter", Y = "pointer"), Pr = Ze == null ? Se : Bs(Ze), ee = it == null ? Se : Bs(it), Se = new st(Re, Y + "leave", Ze, l, we), Se.target = Pr, Se.relatedTarget = ee, Re = null, ca(we) === ae && (st = new st(q, Y + "enter", it, l, we), st.target = ee, st.relatedTarget = Pr, Re = st), Pr = Re, Ze && it)
              t: {
                for (st = Ze, q = it, Y = 0, ee = st; ee; ee = y(ee))
                  Y++;
                for (ee = 0, Re = q; Re; Re = y(Re))
                  ee++;
                for (; 0 < Y - ee; )
                  st = y(st), Y--;
                for (; 0 < ee - Y; )
                  q = y(q), ee--;
                for (; Y--; ) {
                  if (st === q || q !== null && st === q.alternate)
                    break t;
                  st = y(st), q = y(q);
                }
                st = null;
              }
            else
              st = null;
            Ze !== null && T(Ee, Se, Ze, st, !1), it !== null && Pr !== null && T(Ee, Pr, it, st, !0);
          }
        }
        e: {
          if (Se = ae ? Bs(ae) : window, Ze = Se.nodeName && Se.nodeName.toLowerCase(), Ze === "select" || Ze === "input" && Se.type === "file")
            var ct = bd;
          else if (xd(Se))
            if (Aa)
              ct = gc;
            else {
              ct = wu;
              var at = mc;
            }
          else
            (Ze = Se.nodeName) && Ze.toLowerCase() === "input" && (Se.type === "checkbox" || Se.type === "radio") && (ct = yc);
          if (ct && (ct = ct(n, ae))) {
            dc(Ee, ct, l, we);
            break e;
          }
          at && at(n, Se, ae), n === "focusout" && (at = Se._wrapperState) && at.controlled && Se.type === "number" && ki(Se, "number", Se.value);
        }
        switch (at = ae ? Bs(ae) : window, n) {
          case "focusin":
            (xd(at) || at.contentEditable === "true") && (za = at, Eu = ae, pl = null);
            break;
          case "focusout":
            pl = Eu = za = null;
            break;
          case "mousedown":
            _c = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            _c = !1, kd(Ee, l, we);
            break;
          case "selectionchange":
            if (hl)
              break;
          case "keydown":
          case "keyup":
            kd(Ee, l, we);
        }
        var yt;
        if (ri)
          e: {
            switch (n) {
              case "compositionstart":
                var zt = "onCompositionStart";
                break e;
              case "compositionend":
                zt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                zt = "onCompositionUpdate";
                break e;
            }
            zt = void 0;
          }
        else
          Vo ? gu(n, l) && (zt = "onCompositionEnd") : n === "keydown" && l.keyCode === 229 && (zt = "onCompositionStart");
        zt && (Td && l.locale !== "ko" && (Vo || zt !== "onCompositionStart" ? zt === "onCompositionEnd" && Vo && (yt = te()) : (La = we, b = "value" in La ? La.value : La.textContent, Vo = !0)), at = h(ae, zt), 0 < at.length && (zt = new sc(zt, n, null, l, we), Ee.push({ event: zt, listeners: at }), yt ? zt.data = yt : (yt = ul(l), yt !== null && (zt.data = yt)))), (yt = sa ? _p(n, l) : us(n, l)) && (ae = h(ae, "onBeforeInput"), 0 < ae.length && (we = new sc("onBeforeInput", "beforeinput", null, l, we), Ee.push({ event: we, listeners: ae }), we.data = yt));
      }
      ml(Ee, i);
    });
  }
  function u(n, i, l) {
    return { instance: n, listener: i, currentTarget: l };
  }
  function h(n, i) {
    for (var l = i + "Capture", p = []; n !== null; ) {
      var g = n, S = g.stateNode;
      g.tag === 5 && S !== null && (g = S, S = Vi(n, l), S != null && p.unshift(u(n, S, g)), S = Vi(n, i), S != null && p.push(u(n, S, g))), n = n.return;
    }
    return p;
  }
  function y(n) {
    if (n === null)
      return null;
    do
      n = n.return;
    while (n && n.tag !== 5);
    return n || null;
  }
  function T(n, i, l, p, g) {
    for (var S = i._reactName, R = []; l !== null && l !== p; ) {
      var P = l, F = P.alternate, ae = P.stateNode;
      if (F !== null && F === p)
        break;
      P.tag === 5 && ae !== null && (P = ae, g ? (F = Vi(l, S), F != null && R.unshift(u(l, F, P))) : g || (F = Vi(l, S), F != null && R.push(u(l, F, P)))), l = l.return;
    }
    R.length !== 0 && n.push({ event: i, listeners: R });
  }
  var D = /\r\n?/g, I = /\u0000|\uFFFD/g;
  function Q(n) {
    return (typeof n == "string" ? n : "" + n).replace(D, `
`).replace(I, "");
  }
  function ie(n, i, l) {
    if (i = Q(i), Q(n) !== i && l)
      throw Error(d(425));
  }
  function ge() {
  }
  var Fe = null, ht = null;
  function Vt(n, i) {
    return n === "textarea" || n === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null;
  }
  var hr = typeof setTimeout == "function" ? setTimeout : void 0, Lr = typeof clearTimeout == "function" ? clearTimeout : void 0, Pi = typeof Promise == "function" ? Promise : void 0, ii = typeof queueMicrotask == "function" ? queueMicrotask : typeof Pi < "u" ? function(n) {
    return Pi.resolve(null).then(n).catch(xu);
  } : hr;
  function xu(n) {
    setTimeout(function() {
      throw n;
    });
  }
  function ps(n, i) {
    var l = i, p = 0;
    do {
      var g = l.nextSibling;
      if (n.removeChild(l), g && g.nodeType === 8)
        if (l = g.data, l === "/$") {
          if (p === 0) {
            n.removeChild(g), Li(i);
            return;
          }
          p--;
        } else
          l !== "$" && l !== "$?" && l !== "$!" || p++;
      l = g;
    } while (l);
    Li(i);
  }
  function Ua(n) {
    for (; n != null; n = n.nextSibling) {
      var i = n.nodeType;
      if (i === 1 || i === 3)
        break;
      if (i === 8) {
        if (i = n.data, i === "$" || i === "$!" || i === "$?")
          break;
        if (i === "/$")
          return null;
      }
    }
    return n;
  }
  function yl(n) {
    n = n.previousSibling;
    for (var i = 0; n; ) {
      if (n.nodeType === 8) {
        var l = n.data;
        if (l === "$" || l === "$!" || l === "$?") {
          if (i === 0)
            return n;
          i--;
        } else
          l === "/$" && i++;
      }
      n = n.previousSibling;
    }
    return null;
  }
  var $o = Math.random().toString(36).slice(2), ho = "__reactFiber$" + $o, vs = "__reactProps$" + $o, On = "__reactContainer$" + $o, bu = "__reactEvents$" + $o, Sp = "__reactListeners$" + $o, Mf = "__reactHandles$" + $o;
  function ca(n) {
    var i = n[ho];
    if (i)
      return i;
    for (var l = n.parentNode; l; ) {
      if (i = l[On] || l[ho]) {
        if (l = i.alternate, i.child !== null || l !== null && l.child !== null)
          for (n = yl(n); n !== null; ) {
            if (l = n[ho])
              return l;
            n = yl(n);
          }
        return i;
      }
      n = l, l = n.parentNode;
    }
    return null;
  }
  function Hs(n) {
    return n = n[ho] || n[On], !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3 ? null : n;
  }
  function Bs(n) {
    if (n.tag === 5 || n.tag === 6)
      return n.stateNode;
    throw Error(d(33));
  }
  function pt(n) {
    return n[vs] || null;
  }
  var Mu = [], rr = -1;
  function Wt(n) {
    return { current: n };
  }
  function Rn(n) {
    0 > rr || (n.current = Mu[rr], Mu[rr] = null, rr--);
  }
  function Ln(n, i) {
    rr++, Mu[rr] = n.current, n.current = i;
  }
  var ms = {}, At = Wt(ms), Cr = Wt(!1), fa = ms;
  function po(n, i) {
    var l = n.type.contextTypes;
    if (!l)
      return ms;
    var p = n.stateNode;
    if (p && p.__reactInternalMemoizedUnmaskedChildContext === i)
      return p.__reactInternalMemoizedMaskedChildContext;
    var g = {}, S;
    for (S in l)
      g[S] = i[S];
    return p && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = i, n.__reactInternalMemoizedMaskedChildContext = g), g;
  }
  function cr(n) {
    return n = n.childContextTypes, n != null;
  }
  function vo() {
    Rn(Cr), Rn(At);
  }
  function Ru(n, i, l) {
    if (At.current !== ms)
      throw Error(d(168));
    Ln(At, i), Ln(Cr, l);
  }
  function Rf(n, i, l) {
    var p = n.stateNode;
    if (i = i.childContextTypes, typeof p.getChildContext != "function")
      return l;
    p = p.getChildContext();
    for (var g in p)
      if (!(g in i))
        throw Error(d(108, Rt(n) || "Unknown", g));
    return N({}, l, p);
  }
  function Ad(n) {
    return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || ms, fa = At.current, Ln(At, n), Ln(Cr, Cr.current), !0;
  }
  function Em(n, i, l) {
    var p = n.stateNode;
    if (!p)
      throw Error(d(169));
    l ? (n = Rf(n, i, fa), p.__reactInternalMemoizedMergedChildContext = n, Rn(Cr), Rn(At), Ln(At, n)) : Rn(Cr), Ln(Cr, l);
  }
  var Ia = null, ai = !1, Df = !1;
  function wp(n) {
    Ia === null ? Ia = [n] : Ia.push(n);
  }
  function Ep(n) {
    ai = !0, wp(n);
  }
  function da() {
    if (!Df && Ia !== null) {
      Df = !0;
      var n = 0, i = nn;
      try {
        var l = Ia;
        for (nn = 1; n < l.length; n++) {
          var p = l[n];
          do
            p = p(!0);
          while (p !== null);
        }
        Ia = null, ai = !1;
      } catch (g) {
        throw Ia !== null && (Ia = Ia.slice(n + 1)), Vn(Da, da), g;
      } finally {
        nn = i, Df = !1;
      }
    }
    return null;
  }
  var Du = [], ha = 0, gl = null, wc = 0, pa = [], Ai = 0, mo = null, gi = 1, Ys = "";
  function ja(n, i) {
    Du[ha++] = wc, Du[ha++] = gl, gl = n, wc = i;
  }
  function Tp(n, i, l) {
    pa[Ai++] = gi, pa[Ai++] = Ys, pa[Ai++] = mo, mo = n;
    var p = gi;
    n = Ys;
    var g = 32 - Pt(p) - 1;
    p &= ~(1 << g), l += 1;
    var S = 32 - Pt(i) + g;
    if (30 < S) {
      var R = g - g % 5;
      S = (p & (1 << R) - 1).toString(32), p >>= R, g -= R, gi = 1 << 32 - Pt(i) + g | l << g | p, Ys = S + n;
    } else
      gi = 1 << S | l << g | p, Ys = n;
  }
  function zd(n) {
    n.return !== null && (ja(n, 1), Tp(n, 1, 0));
  }
  function Cp(n) {
    for (; n === gl; )
      gl = Du[--ha], Du[ha] = null, wc = Du[--ha], Du[ha] = null;
    for (; n === mo; )
      mo = pa[--Ai], pa[Ai] = null, Ys = pa[--Ai], pa[Ai] = null, gi = pa[--Ai], pa[Ai] = null;
  }
  var Fa = null, va = null, ir = !1, yo = null;
  function xp(n, i) {
    var l = To(5, null, null, 0);
    l.elementType = "DELETED", l.stateNode = i, l.return = n, i = n.deletions, i === null ? (n.deletions = [l], n.flags |= 16) : i.push(l);
  }
  function Tm(n, i) {
    switch (n.tag) {
      case 5:
        var l = n.type;
        return i = i.nodeType !== 1 || l.toLowerCase() !== i.nodeName.toLowerCase() ? null : i, i !== null ? (n.stateNode = i, Fa = n, va = Ua(i.firstChild), !0) : !1;
      case 6:
        return i = n.pendingProps === "" || i.nodeType !== 3 ? null : i, i !== null ? (n.stateNode = i, Fa = n, va = null, !0) : !1;
      case 13:
        return i = i.nodeType !== 8 ? null : i, i !== null ? (l = mo !== null ? { id: gi, overflow: Ys } : null, n.memoizedState = { dehydrated: i, treeContext: l, retryLane: 1073741824 }, l = To(18, null, null, 0), l.stateNode = i, l.return = n, n.child = l, Fa = n, va = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Ud(n) {
    return (n.mode & 1) !== 0 && (n.flags & 128) === 0;
  }
  function Id(n) {
    if (ir) {
      var i = va;
      if (i) {
        var l = i;
        if (!Tm(n, i)) {
          if (Ud(n))
            throw Error(d(418));
          i = Ua(l.nextSibling);
          var p = Fa;
          i && Tm(n, i) ? xp(p, l) : (n.flags = n.flags & -4097 | 2, ir = !1, Fa = n);
        }
      } else {
        if (Ud(n))
          throw Error(d(418));
        n.flags = n.flags & -4097 | 2, ir = !1, Fa = n;
      }
    }
  }
  function Cm(n) {
    for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
      n = n.return;
    Fa = n;
  }
  function jd(n) {
    if (n !== Fa)
      return !1;
    if (!ir)
      return Cm(n), ir = !0, !1;
    var i;
    if ((i = n.tag !== 3) && !(i = n.tag !== 5) && (i = n.type, i = i !== "head" && i !== "body" && !Vt(n.type, n.memoizedProps)), i && (i = va)) {
      if (Ud(n))
        throw xm(), Error(d(418));
      for (; i; )
        xp(n, i), i = Ua(i.nextSibling);
    }
    if (Cm(n), n.tag === 13) {
      if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n)
        throw Error(d(317));
      e: {
        for (n = n.nextSibling, i = 0; n; ) {
          if (n.nodeType === 8) {
            var l = n.data;
            if (l === "/$") {
              if (i === 0) {
                va = Ua(n.nextSibling);
                break e;
              }
              i--;
            } else
              l !== "$" && l !== "$!" && l !== "$?" || i++;
          }
          n = n.nextSibling;
        }
        va = null;
      }
    } else
      va = Fa ? Ua(n.stateNode.nextSibling) : null;
    return !0;
  }
  function xm() {
    for (var n = va; n; )
      n = Ua(n.nextSibling);
  }
  function pr() {
    va = Fa = null, ir = !1;
  }
  function bp(n) {
    yo === null ? yo = [n] : yo.push(n);
  }
  var Fd = ye.ReactCurrentBatchConfig;
  function Ha(n, i) {
    if (n && n.defaultProps) {
      i = N({}, i), n = n.defaultProps;
      for (var l in n)
        i[l] === void 0 && (i[l] = n[l]);
      return i;
    }
    return i;
  }
  var ys = Wt(null), Hd = null, ku = null, Mp = null;
  function Rp() {
    Mp = ku = Hd = null;
  }
  function Ou(n) {
    var i = ys.current;
    Rn(ys), n._currentValue = i;
  }
  function oi(n, i, l) {
    for (; n !== null; ) {
      var p = n.alternate;
      if ((n.childLanes & i) !== i ? (n.childLanes |= i, p !== null && (p.childLanes |= i)) : p !== null && (p.childLanes & i) !== i && (p.childLanes |= i), n === l)
        break;
      n = n.return;
    }
  }
  function Pe(n, i) {
    Hd = n, Mp = ku = null, n = n.dependencies, n !== null && n.firstContext !== null && (n.lanes & i && (Ir = !0), n.firstContext = null);
  }
  function Nr(n) {
    var i = n._currentValue;
    if (Mp !== n)
      if (n = { context: n, memoizedValue: i, next: null }, ku === null) {
        if (Hd === null)
          throw Error(d(308));
        ku = n, Hd.dependencies = { lanes: 0, firstContext: n };
      } else
        ku = ku.next = n;
    return i;
  }
  var _i = null;
  function Dp(n) {
    _i === null ? _i = [n] : _i.push(n);
  }
  function bm(n, i, l, p) {
    var g = i.interleaved;
    return g === null ? (l.next = l, Dp(i)) : (l.next = g.next, g.next = l), i.interleaved = l, Vs(n, p);
  }
  function Vs(n, i) {
    n.lanes |= i;
    var l = n.alternate;
    for (l !== null && (l.lanes |= i), l = n, n = n.return; n !== null; )
      n.childLanes |= i, l = n.alternate, l !== null && (l.childLanes |= i), l = n, n = n.return;
    return l.tag === 3 ? l.stateNode : null;
  }
  var Lu = !1;
  function kp(n) {
    n.updateQueue = { baseState: n.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Wr(n, i) {
    n = n.updateQueue, i.updateQueue === n && (i.updateQueue = { baseState: n.baseState, firstBaseUpdate: n.firstBaseUpdate, lastBaseUpdate: n.lastBaseUpdate, shared: n.shared, effects: n.effects });
  }
  function Ws(n, i) {
    return { eventTime: n, lane: i, tag: 0, payload: null, callback: null, next: null };
  }
  function Nu(n, i, l) {
    var p = n.updateQueue;
    if (p === null)
      return null;
    if (p = p.shared, un & 2) {
      var g = p.pending;
      return g === null ? i.next = i : (i.next = g.next, g.next = i), p.pending = i, Vs(n, l);
    }
    return g = p.interleaved, g === null ? (i.next = i, Dp(p)) : (i.next = g.next, g.next = i), p.interleaved = i, Vs(n, l);
  }
  function Bd(n, i, l) {
    if (i = i.updateQueue, i !== null && (i = i.shared, (l & 4194240) !== 0)) {
      var p = i.lanes;
      p &= n.pendingLanes, l |= p, i.lanes = l, ni(n, l);
    }
  }
  function Op(n, i) {
    var l = n.updateQueue, p = n.alternate;
    if (p !== null && (p = p.updateQueue, l === p)) {
      var g = null, S = null;
      if (l = l.firstBaseUpdate, l !== null) {
        do {
          var R = { eventTime: l.eventTime, lane: l.lane, tag: l.tag, payload: l.payload, callback: l.callback, next: null };
          S === null ? g = S = R : S = S.next = R, l = l.next;
        } while (l !== null);
        S === null ? g = S = i : S = S.next = i;
      } else
        g = S = i;
      l = { baseState: p.baseState, firstBaseUpdate: g, lastBaseUpdate: S, shared: p.shared, effects: p.effects }, n.updateQueue = l;
      return;
    }
    n = l.lastBaseUpdate, n === null ? l.firstBaseUpdate = i : n.next = i, l.lastBaseUpdate = i;
  }
  function Pu(n, i, l, p) {
    var g = n.updateQueue;
    Lu = !1;
    var S = g.firstBaseUpdate, R = g.lastBaseUpdate, P = g.shared.pending;
    if (P !== null) {
      g.shared.pending = null;
      var F = P, ae = F.next;
      F.next = null, R === null ? S = ae : R.next = ae, R = F;
      var we = n.alternate;
      we !== null && (we = we.updateQueue, P = we.lastBaseUpdate, P !== R && (P === null ? we.firstBaseUpdate = ae : P.next = ae, we.lastBaseUpdate = F));
    }
    if (S !== null) {
      var Ee = g.baseState;
      R = 0, we = ae = F = null, P = S;
      do {
        var Se = P.lane, Ze = P.eventTime;
        if ((p & Se) === Se) {
          we !== null && (we = we.next = {
            eventTime: Ze,
            lane: 0,
            tag: P.tag,
            payload: P.payload,
            callback: P.callback,
            next: null
          });
          e: {
            var it = n, st = P;
            switch (Se = i, Ze = l, st.tag) {
              case 1:
                if (it = st.payload, typeof it == "function") {
                  Ee = it.call(Ze, Ee, Se);
                  break e;
                }
                Ee = it;
                break e;
              case 3:
                it.flags = it.flags & -65537 | 128;
              case 0:
                if (it = st.payload, Se = typeof it == "function" ? it.call(Ze, Ee, Se) : it, Se == null)
                  break e;
                Ee = N({}, Ee, Se);
                break e;
              case 2:
                Lu = !0;
            }
          }
          P.callback !== null && P.lane !== 0 && (n.flags |= 64, Se = g.effects, Se === null ? g.effects = [P] : Se.push(P));
        } else
          Ze = { eventTime: Ze, lane: Se, tag: P.tag, payload: P.payload, callback: P.callback, next: null }, we === null ? (ae = we = Ze, F = Ee) : we = we.next = Ze, R |= Se;
        if (P = P.next, P === null) {
          if (P = g.shared.pending, P === null)
            break;
          Se = P, P = Se.next, Se.next = null, g.lastBaseUpdate = Se, g.shared.pending = null;
        }
      } while (1);
      if (we === null && (F = Ee), g.baseState = F, g.firstBaseUpdate = ae, g.lastBaseUpdate = we, i = g.shared.interleaved, i !== null) {
        g = i;
        do
          R |= g.lane, g = g.next;
        while (g !== i);
      } else
        S === null && (g.shared.lanes = 0);
      Qs |= R, n.lanes = R, n.memoizedState = Ee;
    }
  }
  function _l(n, i, l) {
    if (n = i.effects, i.effects = null, n !== null)
      for (i = 0; i < n.length; i++) {
        var p = n[i], g = p.callback;
        if (g !== null) {
          if (p.callback = null, p = l, typeof g != "function")
            throw Error(d(191, g));
          g.call(p);
        }
      }
  }
  var Mm = new o.Component().refs;
  function Lp(n, i, l, p) {
    i = n.memoizedState, l = l(p, i), l = l == null ? i : N({}, i, l), n.memoizedState = l, n.lanes === 0 && (n.updateQueue.baseState = l);
  }
  var Yd = { isMounted: function(n) {
    return (n = n._reactInternals) ? Ut(n) === n : !1;
  }, enqueueSetState: function(n, i, l) {
    n = n._reactInternals;
    var p = ji(), g = jr(n), S = Ws(p, g);
    S.payload = i, l != null && (S.callback = l), i = Nu(n, S, g), i !== null && (Fi(i, n, g, p), Bd(i, n, g));
  }, enqueueReplaceState: function(n, i, l) {
    n = n._reactInternals;
    var p = ji(), g = jr(n), S = Ws(p, g);
    S.tag = 1, S.payload = i, l != null && (S.callback = l), i = Nu(n, S, g), i !== null && (Fi(i, n, g, p), Bd(i, n, g));
  }, enqueueForceUpdate: function(n, i) {
    n = n._reactInternals;
    var l = ji(), p = jr(n), g = Ws(l, p);
    g.tag = 2, i != null && (g.callback = i), i = Nu(n, g, p), i !== null && (Fi(i, n, p, l), Bd(i, n, p));
  } };
  function Rm(n, i, l, p, g, S, R) {
    return n = n.stateNode, typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(p, S, R) : i.prototype && i.prototype.isPureReactComponent ? !ls(l, p) || !ls(g, S) : !0;
  }
  function Dm(n, i, l) {
    var p = !1, g = ms, S = i.contextType;
    return typeof S == "object" && S !== null ? S = Nr(S) : (g = cr(i) ? fa : At.current, p = i.contextTypes, S = (p = p != null) ? po(n, g) : ms), i = new i(l, S), n.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, i.updater = Yd, n.stateNode = i, i._reactInternals = n, p && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = g, n.__reactInternalMemoizedMaskedChildContext = S), i;
  }
  function km(n, i, l, p) {
    n = i.state, typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(l, p), typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(l, p), i.state !== n && Yd.enqueueReplaceState(i, i.state, null);
  }
  function Vd(n, i, l, p) {
    var g = n.stateNode;
    g.props = l, g.state = n.memoizedState, g.refs = Mm, kp(n);
    var S = i.contextType;
    typeof S == "object" && S !== null ? g.context = Nr(S) : (S = cr(i) ? fa : At.current, g.context = po(n, S)), g.state = n.memoizedState, S = i.getDerivedStateFromProps, typeof S == "function" && (Lp(n, i, S, l), g.state = n.memoizedState), typeof i.getDerivedStateFromProps == "function" || typeof g.getSnapshotBeforeUpdate == "function" || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (i = g.state, typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount(), i !== g.state && Yd.enqueueReplaceState(g, g.state, null), Pu(n, l, g, p), g.state = n.memoizedState), typeof g.componentDidMount == "function" && (n.flags |= 4194308);
  }
  function Ec(n, i, l) {
    if (n = l.ref, n !== null && typeof n != "function" && typeof n != "object") {
      if (l._owner) {
        if (l = l._owner, l) {
          if (l.tag !== 1)
            throw Error(d(309));
          var p = l.stateNode;
        }
        if (!p)
          throw Error(d(147, n));
        var g = p, S = "" + n;
        return i !== null && i.ref !== null && typeof i.ref == "function" && i.ref._stringRef === S ? i.ref : (i = function(R) {
          var P = g.refs;
          P === Mm && (P = g.refs = {}), R === null ? delete P[S] : P[S] = R;
        }, i._stringRef = S, i);
      }
      if (typeof n != "string")
        throw Error(d(284));
      if (!l._owner)
        throw Error(d(290, n));
    }
    return n;
  }
  function Wd(n, i) {
    throw n = Object.prototype.toString.call(i), Error(d(31, n === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : n));
  }
  function Om(n) {
    var i = n._init;
    return i(n._payload);
  }
  function Lm(n) {
    function i(q, Y) {
      if (n) {
        var ee = q.deletions;
        ee === null ? (q.deletions = [Y], q.flags |= 16) : ee.push(Y);
      }
    }
    function l(q, Y) {
      if (!n)
        return null;
      for (; Y !== null; )
        i(q, Y), Y = Y.sibling;
      return null;
    }
    function p(q, Y) {
      for (q = /* @__PURE__ */ new Map(); Y !== null; )
        Y.key !== null ? q.set(Y.key, Y) : q.set(Y.index, Y), Y = Y.sibling;
      return q;
    }
    function g(q, Y) {
      return q = Bu(q, Y), q.index = 0, q.sibling = null, q;
    }
    function S(q, Y, ee) {
      return q.index = ee, n ? (ee = q.alternate, ee !== null ? (ee = ee.index, ee < Y ? (q.flags |= 2, Y) : ee) : (q.flags |= 2, Y)) : (q.flags |= 1048576, Y);
    }
    function R(q) {
      return n && q.alternate === null && (q.flags |= 2), q;
    }
    function P(q, Y, ee, Re) {
      return Y === null || Y.tag !== 6 ? (Y = Gf(ee, q.mode, Re), Y.return = q, Y) : (Y = g(Y, ee), Y.return = q, Y);
    }
    function F(q, Y, ee, Re) {
      var ct = ee.type;
      return ct === ze ? we(q, Y, ee.props.children, Re, ee.key) : Y !== null && (Y.elementType === ct || typeof ct == "object" && ct !== null && ct.$$typeof === vt && Om(ct) === Y.type) ? (Re = g(Y, ee.props), Re.ref = Ec(q, Y, ee), Re.return = q, Re) : (Re = Th(ee.type, ee.key, ee.props, null, q.mode, Re), Re.ref = Ec(q, Y, ee), Re.return = q, Re);
    }
    function ae(q, Y, ee, Re) {
      return Y === null || Y.tag !== 4 || Y.stateNode.containerInfo !== ee.containerInfo || Y.stateNode.implementation !== ee.implementation ? (Y = Il(ee, q.mode, Re), Y.return = q, Y) : (Y = g(Y, ee.children || []), Y.return = q, Y);
    }
    function we(q, Y, ee, Re, ct) {
      return Y === null || Y.tag !== 7 ? (Y = Ul(ee, q.mode, Re, ct), Y.return = q, Y) : (Y = g(Y, ee), Y.return = q, Y);
    }
    function Ee(q, Y, ee) {
      if (typeof Y == "string" && Y !== "" || typeof Y == "number")
        return Y = Gf("" + Y, q.mode, ee), Y.return = q, Y;
      if (typeof Y == "object" && Y !== null) {
        switch (Y.$$typeof) {
          case G:
            return ee = Th(Y.type, Y.key, Y.props, null, q.mode, ee), ee.ref = Ec(q, null, Y), ee.return = q, ee;
          case Me:
            return Y = Il(Y, q.mode, ee), Y.return = q, Y;
          case vt:
            var Re = Y._init;
            return Ee(q, Re(Y._payload), ee);
        }
        if (Dr(Y) || Je(Y))
          return Y = Ul(Y, q.mode, ee, null), Y.return = q, Y;
        Wd(q, Y);
      }
      return null;
    }
    function Se(q, Y, ee, Re) {
      var ct = Y !== null ? Y.key : null;
      if (typeof ee == "string" && ee !== "" || typeof ee == "number")
        return ct !== null ? null : P(q, Y, "" + ee, Re);
      if (typeof ee == "object" && ee !== null) {
        switch (ee.$$typeof) {
          case G:
            return ee.key === ct ? F(q, Y, ee, Re) : null;
          case Me:
            return ee.key === ct ? ae(q, Y, ee, Re) : null;
          case vt:
            return ct = ee._init, Se(
              q,
              Y,
              ct(ee._payload),
              Re
            );
        }
        if (Dr(ee) || Je(ee))
          return ct !== null ? null : we(q, Y, ee, Re, null);
        Wd(q, ee);
      }
      return null;
    }
    function Ze(q, Y, ee, Re, ct) {
      if (typeof Re == "string" && Re !== "" || typeof Re == "number")
        return q = q.get(ee) || null, P(Y, q, "" + Re, ct);
      if (typeof Re == "object" && Re !== null) {
        switch (Re.$$typeof) {
          case G:
            return q = q.get(Re.key === null ? ee : Re.key) || null, F(Y, q, Re, ct);
          case Me:
            return q = q.get(Re.key === null ? ee : Re.key) || null, ae(Y, q, Re, ct);
          case vt:
            var at = Re._init;
            return Ze(q, Y, ee, at(Re._payload), ct);
        }
        if (Dr(Re) || Je(Re))
          return q = q.get(ee) || null, we(Y, q, Re, ct, null);
        Wd(Y, Re);
      }
      return null;
    }
    function it(q, Y, ee, Re) {
      for (var ct = null, at = null, yt = Y, zt = Y = 0, li = null; yt !== null && zt < ee.length; zt++) {
        yt.index > zt ? (li = yt, yt = null) : li = yt.sibling;
        var wn = Se(q, yt, ee[zt], Re);
        if (wn === null) {
          yt === null && (yt = li);
          break;
        }
        n && yt && wn.alternate === null && i(q, yt), Y = S(wn, Y, zt), at === null ? ct = wn : at.sibling = wn, at = wn, yt = li;
      }
      if (zt === ee.length)
        return l(q, yt), ir && ja(q, zt), ct;
      if (yt === null) {
        for (; zt < ee.length; zt++)
          yt = Ee(q, ee[zt], Re), yt !== null && (Y = S(yt, Y, zt), at === null ? ct = yt : at.sibling = yt, at = yt);
        return ir && ja(q, zt), ct;
      }
      for (yt = p(q, yt); zt < ee.length; zt++)
        li = Ze(yt, q, zt, ee[zt], Re), li !== null && (n && li.alternate !== null && yt.delete(li.key === null ? zt : li.key), Y = S(li, Y, zt), at === null ? ct = li : at.sibling = li, at = li);
      return n && yt.forEach(function(Yu) {
        return i(q, Yu);
      }), ir && ja(q, zt), ct;
    }
    function st(q, Y, ee, Re) {
      var ct = Je(ee);
      if (typeof ct != "function")
        throw Error(d(150));
      if (ee = ct.call(ee), ee == null)
        throw Error(d(151));
      for (var at = ct = null, yt = Y, zt = Y = 0, li = null, wn = ee.next(); yt !== null && !wn.done; zt++, wn = ee.next()) {
        yt.index > zt ? (li = yt, yt = null) : li = yt.sibling;
        var Yu = Se(q, yt, wn.value, Re);
        if (Yu === null) {
          yt === null && (yt = li);
          break;
        }
        n && yt && Yu.alternate === null && i(q, yt), Y = S(Yu, Y, zt), at === null ? ct = Yu : at.sibling = Yu, at = Yu, yt = li;
      }
      if (wn.done)
        return l(
          q,
          yt
        ), ir && ja(q, zt), ct;
      if (yt === null) {
        for (; !wn.done; zt++, wn = ee.next())
          wn = Ee(q, wn.value, Re), wn !== null && (Y = S(wn, Y, zt), at === null ? ct = wn : at.sibling = wn, at = wn);
        return ir && ja(q, zt), ct;
      }
      for (yt = p(q, yt); !wn.done; zt++, wn = ee.next())
        wn = Ze(yt, q, zt, wn.value, Re), wn !== null && (n && wn.alternate !== null && yt.delete(wn.key === null ? zt : wn.key), Y = S(wn, Y, zt), at === null ? ct = wn : at.sibling = wn, at = wn);
      return n && yt.forEach(function(b_) {
        return i(q, b_);
      }), ir && ja(q, zt), ct;
    }
    function Pr(q, Y, ee, Re) {
      if (typeof ee == "object" && ee !== null && ee.type === ze && ee.key === null && (ee = ee.props.children), typeof ee == "object" && ee !== null) {
        switch (ee.$$typeof) {
          case G:
            e: {
              for (var ct = ee.key, at = Y; at !== null; ) {
                if (at.key === ct) {
                  if (ct = ee.type, ct === ze) {
                    if (at.tag === 7) {
                      l(q, at.sibling), Y = g(at, ee.props.children), Y.return = q, q = Y;
                      break e;
                    }
                  } else if (at.elementType === ct || typeof ct == "object" && ct !== null && ct.$$typeof === vt && Om(ct) === at.type) {
                    l(q, at.sibling), Y = g(at, ee.props), Y.ref = Ec(q, at, ee), Y.return = q, q = Y;
                    break e;
                  }
                  l(q, at);
                  break;
                } else
                  i(q, at);
                at = at.sibling;
              }
              ee.type === ze ? (Y = Ul(ee.props.children, q.mode, Re, ee.key), Y.return = q, q = Y) : (Re = Th(ee.type, ee.key, ee.props, null, q.mode, Re), Re.ref = Ec(q, Y, ee), Re.return = q, q = Re);
            }
            return R(q);
          case Me:
            e: {
              for (at = ee.key; Y !== null; ) {
                if (Y.key === at)
                  if (Y.tag === 4 && Y.stateNode.containerInfo === ee.containerInfo && Y.stateNode.implementation === ee.implementation) {
                    l(q, Y.sibling), Y = g(Y, ee.children || []), Y.return = q, q = Y;
                    break e;
                  } else {
                    l(q, Y);
                    break;
                  }
                else
                  i(q, Y);
                Y = Y.sibling;
              }
              Y = Il(ee, q.mode, Re), Y.return = q, q = Y;
            }
            return R(q);
          case vt:
            return at = ee._init, Pr(q, Y, at(ee._payload), Re);
        }
        if (Dr(ee))
          return it(q, Y, ee, Re);
        if (Je(ee))
          return st(q, Y, ee, Re);
        Wd(q, ee);
      }
      return typeof ee == "string" && ee !== "" || typeof ee == "number" ? (ee = "" + ee, Y !== null && Y.tag === 6 ? (l(q, Y.sibling), Y = g(Y, ee), Y.return = q, q = Y) : (l(q, Y), Y = Gf(ee, q.mode, Re), Y.return = q, q = Y), R(q)) : l(q, Y);
    }
    return Pr;
  }
  var Tc = Lm(!0), Nm = Lm(!1), kf = {}, Go = Wt(kf), Of = Wt(kf), Cc = Wt(kf);
  function Sl(n) {
    if (n === kf)
      throw Error(d(174));
    return n;
  }
  function Np(n, i) {
    switch (Ln(Cc, i), Ln(Of, n), Ln(Go, kf), n = i.nodeType, n) {
      case 9:
      case 11:
        i = (i = i.documentElement) ? i.namespaceURI : er(null, "");
        break;
      default:
        n = n === 8 ? i.parentNode : i, i = n.namespaceURI || null, n = n.tagName, i = er(i, n);
    }
    Rn(Go), Ln(Go, i);
  }
  function Au() {
    Rn(Go), Rn(Of), Rn(Cc);
  }
  function Tt(n) {
    Sl(Cc.current);
    var i = Sl(Go.current), l = er(i, n.type);
    i !== l && (Ln(Of, n), Ln(Go, l));
  }
  function Jt(n) {
    Of.current === n && (Rn(Go), Rn(Of));
  }
  var bt = Wt(0);
  function vr(n) {
    for (var i = n; i !== null; ) {
      if (i.tag === 13) {
        var l = i.memoizedState;
        if (l !== null && (l = l.dehydrated, l === null || l.data === "$?" || l.data === "$!"))
          return i;
      } else if (i.tag === 19 && i.memoizedProps.revealOrder !== void 0) {
        if (i.flags & 128)
          return i;
      } else if (i.child !== null) {
        i.child.return = i, i = i.child;
        continue;
      }
      if (i === n)
        break;
      for (; i.sibling === null; ) {
        if (i.return === null || i.return === n)
          return null;
        i = i.return;
      }
      i.sibling.return = i.return, i = i.sibling;
    }
    return null;
  }
  var go = [];
  function Zd() {
    for (var n = 0; n < go.length; n++)
      go[n]._workInProgressVersionPrimary = null;
    go.length = 0;
  }
  var $d = ye.ReactCurrentDispatcher, Pp = ye.ReactCurrentBatchConfig, wl = 0, ar = null, pe = null, hn = null, Dt = !1, gs = !1, Ba = 0, El = 0;
  function or() {
    throw Error(d(321));
  }
  function Tl(n, i) {
    if (i === null)
      return !1;
    for (var l = 0; l < i.length && l < n.length; l++)
      if (!ua(n[l], i[l]))
        return !1;
    return !0;
  }
  function zu(n, i, l, p, g, S) {
    if (wl = S, ar = i, i.memoizedState = null, i.updateQueue = null, i.lanes = 0, $d.current = n === null || n.memoizedState === null ? u_ : l_, n = l(p, g), gs) {
      S = 0;
      do {
        if (gs = !1, Ba = 0, 25 <= S)
          throw Error(d(301));
        S += 1, hn = pe = null, i.updateQueue = null, $d.current = zp, n = l(p, g);
      } while (gs);
    }
    if ($d.current = lh, i = pe !== null && pe.next !== null, wl = 0, hn = pe = ar = null, Dt = !1, i)
      throw Error(d(300));
    return n;
  }
  function Cl() {
    var n = Ba !== 0;
    return Ba = 0, n;
  }
  function _o() {
    var n = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return hn === null ? ar.memoizedState = hn = n : hn = hn.next = n, hn;
  }
  function ma() {
    if (pe === null) {
      var n = ar.alternate;
      n = n !== null ? n.memoizedState : null;
    } else
      n = pe.next;
    var i = hn === null ? ar.memoizedState : hn.next;
    if (i !== null)
      hn = i, pe = n;
    else {
      if (n === null)
        throw Error(d(310));
      pe = n, n = { memoizedState: pe.memoizedState, baseState: pe.baseState, baseQueue: pe.baseQueue, queue: pe.queue, next: null }, hn === null ? ar.memoizedState = hn = n : hn = hn.next = n;
    }
    return hn;
  }
  function xl(n, i) {
    return typeof i == "function" ? i(n) : i;
  }
  function Lf(n) {
    var i = ma(), l = i.queue;
    if (l === null)
      throw Error(d(311));
    l.lastRenderedReducer = n;
    var p = pe, g = p.baseQueue, S = l.pending;
    if (S !== null) {
      if (g !== null) {
        var R = g.next;
        g.next = S.next, S.next = R;
      }
      p.baseQueue = g = S, l.pending = null;
    }
    if (g !== null) {
      S = g.next, p = p.baseState;
      var P = R = null, F = null, ae = S;
      do {
        var we = ae.lane;
        if ((wl & we) === we)
          F !== null && (F = F.next = { lane: 0, action: ae.action, hasEagerState: ae.hasEagerState, eagerState: ae.eagerState, next: null }), p = ae.hasEagerState ? ae.eagerState : n(p, ae.action);
        else {
          var Ee = {
            lane: we,
            action: ae.action,
            hasEagerState: ae.hasEagerState,
            eagerState: ae.eagerState,
            next: null
          };
          F === null ? (P = F = Ee, R = p) : F = F.next = Ee, ar.lanes |= we, Qs |= we;
        }
        ae = ae.next;
      } while (ae !== null && ae !== S);
      F === null ? R = p : F.next = P, ua(p, i.memoizedState) || (Ir = !0), i.memoizedState = p, i.baseState = R, i.baseQueue = F, l.lastRenderedState = p;
    }
    if (n = l.interleaved, n !== null) {
      g = n;
      do
        S = g.lane, ar.lanes |= S, Qs |= S, g = g.next;
      while (g !== n);
    } else
      g === null && (l.lanes = 0);
    return [i.memoizedState, l.dispatch];
  }
  function Nf(n) {
    var i = ma(), l = i.queue;
    if (l === null)
      throw Error(d(311));
    l.lastRenderedReducer = n;
    var p = l.dispatch, g = l.pending, S = i.memoizedState;
    if (g !== null) {
      l.pending = null;
      var R = g = g.next;
      do
        S = n(S, R.action), R = R.next;
      while (R !== g);
      ua(S, i.memoizedState) || (Ir = !0), i.memoizedState = S, i.baseQueue === null && (i.baseState = S), l.lastRenderedState = S;
    }
    return [S, p];
  }
  function Gd() {
  }
  function Qd(n, i) {
    var l = ar, p = ma(), g = i(), S = !ua(p.memoizedState, g);
    if (S && (p.memoizedState = g, Ir = !0), p = p.queue, Pf(Xd.bind(null, l, p, n), [n]), p.getSnapshot !== i || S || hn !== null && hn.memoizedState.tag & 1) {
      if (l.flags |= 2048, bl(9, Kd.bind(null, l, p, g, i), void 0, null), mr === null)
        throw Error(d(349));
      wl & 30 || qd(l, i, g);
    }
    return g;
  }
  function qd(n, i, l) {
    n.flags |= 16384, n = { getSnapshot: i, value: l }, i = ar.updateQueue, i === null ? (i = { lastEffect: null, stores: null }, ar.updateQueue = i, i.stores = [n]) : (l = i.stores, l === null ? i.stores = [n] : l.push(n));
  }
  function Kd(n, i, l, p) {
    i.value = l, i.getSnapshot = p, Jd(i) && eh(n);
  }
  function Xd(n, i, l) {
    return l(function() {
      Jd(i) && eh(n);
    });
  }
  function Jd(n) {
    var i = n.getSnapshot;
    n = n.value;
    try {
      var l = i();
      return !ua(n, l);
    } catch {
      return !0;
    }
  }
  function eh(n) {
    var i = Vs(n, 1);
    i !== null && Fi(i, n, 1, -1);
  }
  function th(n) {
    var i = _o();
    return typeof n == "function" && (n = n()), i.memoizedState = i.baseState = n, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: xl, lastRenderedState: n }, i.queue = n, n = n.dispatch = uh.bind(null, ar, n), [i.memoizedState, n];
  }
  function bl(n, i, l, p) {
    return n = { tag: n, create: i, destroy: l, deps: p, next: null }, i = ar.updateQueue, i === null ? (i = { lastEffect: null, stores: null }, ar.updateQueue = i, i.lastEffect = n.next = n) : (l = i.lastEffect, l === null ? i.lastEffect = n.next = n : (p = l.next, l.next = n, n.next = p, i.lastEffect = n)), n;
  }
  function nh() {
    return ma().memoizedState;
  }
  function Ml(n, i, l, p) {
    var g = _o();
    ar.flags |= n, g.memoizedState = bl(1 | i, l, void 0, p === void 0 ? null : p);
  }
  function Zs(n, i, l, p) {
    var g = ma();
    p = p === void 0 ? null : p;
    var S = void 0;
    if (pe !== null) {
      var R = pe.memoizedState;
      if (S = R.destroy, p !== null && Tl(p, R.deps)) {
        g.memoizedState = bl(i, l, S, p);
        return;
      }
    }
    ar.flags |= n, g.memoizedState = bl(1 | i, l, S, p);
  }
  function rh(n, i) {
    return Ml(8390656, 8, n, i);
  }
  function Pf(n, i) {
    return Zs(2048, 8, n, i);
  }
  function ih(n, i) {
    return Zs(4, 2, n, i);
  }
  function ah(n, i) {
    return Zs(4, 4, n, i);
  }
  function Ap(n, i) {
    if (typeof i == "function")
      return n = n(), i(n), function() {
        i(null);
      };
    if (i != null)
      return n = n(), i.current = n, function() {
        i.current = null;
      };
  }
  function xc(n, i, l) {
    return l = l != null ? l.concat([n]) : null, Zs(4, 4, Ap.bind(null, i, n), l);
  }
  function oh() {
  }
  function bc(n, i) {
    var l = ma();
    i = i === void 0 ? null : i;
    var p = l.memoizedState;
    return p !== null && i !== null && Tl(i, p[1]) ? p[0] : (l.memoizedState = [n, i], n);
  }
  function Uu(n, i) {
    var l = ma();
    i = i === void 0 ? null : i;
    var p = l.memoizedState;
    return p !== null && i !== null && Tl(i, p[1]) ? p[0] : (n = n(), l.memoizedState = [n, i], n);
  }
  function ya(n, i, l) {
    return wl & 21 ? (ua(l, i) || (l = pu(), ar.lanes |= l, Qs |= l, n.baseState = !0), i) : (n.baseState && (n.baseState = !1, Ir = !0), n.memoizedState = l);
  }
  function s_(n, i) {
    var l = nn;
    nn = l !== 0 && 4 > l ? l : 4, n(!0);
    var p = Pp.transition;
    Pp.transition = {};
    try {
      n(!1), i();
    } finally {
      nn = l, Pp.transition = p;
    }
  }
  function Jn() {
    return ma().memoizedState;
  }
  function sh(n, i, l) {
    var p = jr(n);
    if (l = { lane: p, action: l, hasEagerState: !1, eagerState: null, next: null }, Mc(n))
      Af(i, l);
    else if (l = bm(n, i, l, p), l !== null) {
      var g = ji();
      Fi(l, n, p, g), Pm(l, i, p);
    }
  }
  function uh(n, i, l) {
    var p = jr(n), g = { lane: p, action: l, hasEagerState: !1, eagerState: null, next: null };
    if (Mc(n))
      Af(i, g);
    else {
      var S = n.alternate;
      if (n.lanes === 0 && (S === null || S.lanes === 0) && (S = i.lastRenderedReducer, S !== null))
        try {
          var R = i.lastRenderedState, P = S(R, l);
          if (g.hasEagerState = !0, g.eagerState = P, ua(P, R)) {
            var F = i.interleaved;
            F === null ? (g.next = g, Dp(i)) : (g.next = F.next, F.next = g), i.interleaved = g;
            return;
          }
        } catch {
        } finally {
        }
      l = bm(n, i, g, p), l !== null && (g = ji(), Fi(l, n, p, g), Pm(l, i, p));
    }
  }
  function Mc(n) {
    var i = n.alternate;
    return n === ar || i !== null && i === ar;
  }
  function Af(n, i) {
    gs = Dt = !0;
    var l = n.pending;
    l === null ? i.next = i : (i.next = l.next, l.next = i), n.pending = i;
  }
  function Pm(n, i, l) {
    if (l & 4194240) {
      var p = i.lanes;
      p &= n.pendingLanes, l |= p, i.lanes = l, ni(n, l);
    }
  }
  var lh = { readContext: Nr, useCallback: or, useContext: or, useEffect: or, useImperativeHandle: or, useInsertionEffect: or, useLayoutEffect: or, useMemo: or, useReducer: or, useRef: or, useState: or, useDebugValue: or, useDeferredValue: or, useTransition: or, useMutableSource: or, useSyncExternalStore: or, useId: or, unstable_isNewReconciler: !1 }, u_ = { readContext: Nr, useCallback: function(n, i) {
    return _o().memoizedState = [n, i === void 0 ? null : i], n;
  }, useContext: Nr, useEffect: rh, useImperativeHandle: function(n, i, l) {
    return l = l != null ? l.concat([n]) : null, Ml(
      4194308,
      4,
      Ap.bind(null, i, n),
      l
    );
  }, useLayoutEffect: function(n, i) {
    return Ml(4194308, 4, n, i);
  }, useInsertionEffect: function(n, i) {
    return Ml(4, 2, n, i);
  }, useMemo: function(n, i) {
    var l = _o();
    return i = i === void 0 ? null : i, n = n(), l.memoizedState = [n, i], n;
  }, useReducer: function(n, i, l) {
    var p = _o();
    return i = l !== void 0 ? l(i) : i, p.memoizedState = p.baseState = i, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: n, lastRenderedState: i }, p.queue = n, n = n.dispatch = sh.bind(null, ar, n), [p.memoizedState, n];
  }, useRef: function(n) {
    var i = _o();
    return n = { current: n }, i.memoizedState = n;
  }, useState: th, useDebugValue: oh, useDeferredValue: function(n) {
    return _o().memoizedState = n;
  }, useTransition: function() {
    var n = th(!1), i = n[0];
    return n = s_.bind(null, n[1]), _o().memoizedState = n, [i, n];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(n, i, l) {
    var p = ar, g = _o();
    if (ir) {
      if (l === void 0)
        throw Error(d(407));
      l = l();
    } else {
      if (l = i(), mr === null)
        throw Error(d(349));
      wl & 30 || qd(p, i, l);
    }
    g.memoizedState = l;
    var S = { value: l, getSnapshot: i };
    return g.queue = S, rh(Xd.bind(
      null,
      p,
      S,
      n
    ), [n]), p.flags |= 2048, bl(9, Kd.bind(null, p, S, l, i), void 0, null), l;
  }, useId: function() {
    var n = _o(), i = mr.identifierPrefix;
    if (ir) {
      var l = Ys, p = gi;
      l = (p & ~(1 << 32 - Pt(p) - 1)).toString(32) + l, i = ":" + i + "R" + l, l = Ba++, 0 < l && (i += "H" + l.toString(32)), i += ":";
    } else
      l = El++, i = ":" + i + "r" + l.toString(32) + ":";
    return n.memoizedState = i;
  }, unstable_isNewReconciler: !1 }, l_ = {
    readContext: Nr,
    useCallback: bc,
    useContext: Nr,
    useEffect: Pf,
    useImperativeHandle: xc,
    useInsertionEffect: ih,
    useLayoutEffect: ah,
    useMemo: Uu,
    useReducer: Lf,
    useRef: nh,
    useState: function() {
      return Lf(xl);
    },
    useDebugValue: oh,
    useDeferredValue: function(n) {
      var i = ma();
      return ya(i, pe.memoizedState, n);
    },
    useTransition: function() {
      var n = Lf(xl)[0], i = ma().memoizedState;
      return [n, i];
    },
    useMutableSource: Gd,
    useSyncExternalStore: Qd,
    useId: Jn,
    unstable_isNewReconciler: !1
  }, zp = { readContext: Nr, useCallback: bc, useContext: Nr, useEffect: Pf, useImperativeHandle: xc, useInsertionEffect: ih, useLayoutEffect: ah, useMemo: Uu, useReducer: Nf, useRef: nh, useState: function() {
    return Nf(xl);
  }, useDebugValue: oh, useDeferredValue: function(n) {
    var i = ma();
    return pe === null ? i.memoizedState = n : ya(i, pe.memoizedState, n);
  }, useTransition: function() {
    var n = Nf(xl)[0], i = ma().memoizedState;
    return [n, i];
  }, useMutableSource: Gd, useSyncExternalStore: Qd, useId: Jn, unstable_isNewReconciler: !1 };
  function Rc(n, i) {
    try {
      var l = "", p = i;
      do
        l += qe(p), p = p.return;
      while (p);
      var g = l;
    } catch (S) {
      g = `
Error generating stack: ` + S.message + `
` + S.stack;
    }
    return { value: n, source: i, stack: g, digest: null };
  }
  function zf(n, i, l) {
    return { value: n, source: null, stack: l ?? null, digest: i ?? null };
  }
  function ch(n, i) {
    try {
      console.error(i.value);
    } catch (l) {
      setTimeout(function() {
        throw l;
      });
    }
  }
  var c_ = typeof WeakMap == "function" ? WeakMap : Map;
  function Am(n, i, l) {
    l = Ws(-1, l), l.tag = 3, l.payload = { element: null };
    var p = i.value;
    return l.callback = function() {
      yh || (yh = !0, Ll = p), ch(n, i);
    }, l;
  }
  function Uf(n, i, l) {
    l = Ws(-1, l), l.tag = 3;
    var p = n.type.getDerivedStateFromError;
    if (typeof p == "function") {
      var g = i.value;
      l.payload = function() {
        return p(g);
      }, l.callback = function() {
        ch(n, i);
      };
    }
    var S = n.stateNode;
    return S !== null && typeof S.componentDidCatch == "function" && (l.callback = function() {
      ch(n, i), typeof p != "function" && (ws === null ? ws = /* @__PURE__ */ new Set([this]) : ws.add(this));
      var R = i.stack;
      this.componentDidCatch(i.value, { componentStack: R !== null ? R : "" });
    }), l;
  }
  function zm(n, i, l) {
    var p = n.pingCache;
    if (p === null) {
      p = n.pingCache = new c_();
      var g = /* @__PURE__ */ new Set();
      p.set(i, g);
    } else
      g = p.get(i), g === void 0 && (g = /* @__PURE__ */ new Set(), p.set(i, g));
    g.has(l) || (g.add(l), n = y_.bind(null, n, i, l), i.then(n, n));
  }
  function Up(n) {
    do {
      var i;
      if ((i = n.tag === 13) && (i = n.memoizedState, i = i !== null ? i.dehydrated !== null : !0), i)
        return n;
      n = n.return;
    } while (n !== null);
    return null;
  }
  function Ip(n, i, l, p, g) {
    return n.mode & 1 ? (n.flags |= 65536, n.lanes = g, n) : (n === i ? n.flags |= 65536 : (n.flags |= 128, l.flags |= 131072, l.flags &= -52805, l.tag === 1 && (l.alternate === null ? l.tag = 17 : (i = Ws(-1, 1), i.tag = 2, Nu(l, i, 1))), l.lanes |= 1), n);
  }
  var f_ = ye.ReactCurrentOwner, Ir = !1;
  function Zr(n, i, l, p) {
    i.child = n === null ? Nm(i, null, l, p) : Tc(i, n.child, l, p);
  }
  function Iu(n, i, l, p, g) {
    l = l.render;
    var S = i.ref;
    return Pe(i, g), p = zu(n, i, l, p, S, g), l = Cl(), n !== null && !Ir ? (i.updateQueue = n.updateQueue, i.flags &= -2053, n.lanes &= ~g, Si(n, i, g)) : (ir && l && zd(i), i.flags |= 1, Zr(n, i, p, g), i.child);
  }
  function fh(n, i, l, p, g) {
    if (n === null) {
      var S = l.type;
      return typeof S == "function" && !rv(S) && S.defaultProps === void 0 && l.compare === null && l.defaultProps === void 0 ? (i.tag = 15, i.type = S, ga(n, i, S, p, g)) : (n = Th(l.type, null, p, i, i.mode, g), n.ref = i.ref, n.return = i, i.child = n);
    }
    if (S = n.child, !(n.lanes & g)) {
      var R = S.memoizedProps;
      if (l = l.compare, l = l !== null ? l : ls, l(R, p) && n.ref === i.ref)
        return Si(n, i, g);
    }
    return i.flags |= 1, n = Bu(S, p), n.ref = i.ref, n.return = i, i.child = n;
  }
  function ga(n, i, l, p, g) {
    if (n !== null) {
      var S = n.memoizedProps;
      if (ls(S, p) && n.ref === i.ref)
        if (Ir = !1, i.pendingProps = p = S, (n.lanes & g) !== 0)
          n.flags & 131072 && (Ir = !0);
        else
          return i.lanes = n.lanes, Si(n, i, g);
    }
    return Dc(n, i, l, p, g);
  }
  function Rl(n, i, l) {
    var p = i.pendingProps, g = p.children, S = n !== null ? n.memoizedState : null;
    if (p.mode === "hidden")
      if (!(i.mode & 1))
        i.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ln(Ac, Ya), Ya |= l;
      else {
        if (!(l & 1073741824))
          return n = S !== null ? S.baseLanes | l : l, i.lanes = i.childLanes = 1073741824, i.memoizedState = { baseLanes: n, cachePool: null, transitions: null }, i.updateQueue = null, Ln(Ac, Ya), Ya |= n, null;
        i.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, p = S !== null ? S.baseLanes : l, Ln(Ac, Ya), Ya |= p;
      }
    else
      S !== null ? (p = S.baseLanes | l, i.memoizedState = null) : p = l, Ln(Ac, Ya), Ya |= p;
    return Zr(n, i, g, l), i.child;
  }
  function Zt(n, i) {
    var l = i.ref;
    (n === null && l !== null || n !== null && n.ref !== l) && (i.flags |= 512, i.flags |= 2097152);
  }
  function Dc(n, i, l, p, g) {
    var S = cr(l) ? fa : At.current;
    return S = po(i, S), Pe(i, g), l = zu(n, i, l, p, S, g), p = Cl(), n !== null && !Ir ? (i.updateQueue = n.updateQueue, i.flags &= -2053, n.lanes &= ~g, Si(n, i, g)) : (ir && p && zd(i), i.flags |= 1, Zr(n, i, l, g), i.child);
  }
  function jp(n, i, l, p, g) {
    if (cr(l)) {
      var S = !0;
      Ad(i);
    } else
      S = !1;
    if (Pe(i, g), i.stateNode === null)
      zi(n, i), Dm(i, l, p), Vd(i, l, p, g), p = !0;
    else if (n === null) {
      var R = i.stateNode, P = i.memoizedProps;
      R.props = P;
      var F = R.context, ae = l.contextType;
      typeof ae == "object" && ae !== null ? ae = Nr(ae) : (ae = cr(l) ? fa : At.current, ae = po(i, ae));
      var we = l.getDerivedStateFromProps, Ee = typeof we == "function" || typeof R.getSnapshotBeforeUpdate == "function";
      Ee || typeof R.UNSAFE_componentWillReceiveProps != "function" && typeof R.componentWillReceiveProps != "function" || (P !== p || F !== ae) && km(i, R, p, ae), Lu = !1;
      var Se = i.memoizedState;
      R.state = Se, Pu(i, p, R, g), F = i.memoizedState, P !== p || Se !== F || Cr.current || Lu ? (typeof we == "function" && (Lp(i, l, we, p), F = i.memoizedState), (P = Lu || Rm(i, l, P, p, Se, F, ae)) ? (Ee || typeof R.UNSAFE_componentWillMount != "function" && typeof R.componentWillMount != "function" || (typeof R.componentWillMount == "function" && R.componentWillMount(), typeof R.UNSAFE_componentWillMount == "function" && R.UNSAFE_componentWillMount()), typeof R.componentDidMount == "function" && (i.flags |= 4194308)) : (typeof R.componentDidMount == "function" && (i.flags |= 4194308), i.memoizedProps = p, i.memoizedState = F), R.props = p, R.state = F, R.context = ae, p = P) : (typeof R.componentDidMount == "function" && (i.flags |= 4194308), p = !1);
    } else {
      R = i.stateNode, Wr(n, i), P = i.memoizedProps, ae = i.type === i.elementType ? P : Ha(i.type, P), R.props = ae, Ee = i.pendingProps, Se = R.context, F = l.contextType, typeof F == "object" && F !== null ? F = Nr(F) : (F = cr(l) ? fa : At.current, F = po(i, F));
      var Ze = l.getDerivedStateFromProps;
      (we = typeof Ze == "function" || typeof R.getSnapshotBeforeUpdate == "function") || typeof R.UNSAFE_componentWillReceiveProps != "function" && typeof R.componentWillReceiveProps != "function" || (P !== Ee || Se !== F) && km(i, R, p, F), Lu = !1, Se = i.memoizedState, R.state = Se, Pu(i, p, R, g);
      var it = i.memoizedState;
      P !== Ee || Se !== it || Cr.current || Lu ? (typeof Ze == "function" && (Lp(i, l, Ze, p), it = i.memoizedState), (ae = Lu || Rm(i, l, ae, p, Se, it, F) || !1) ? (we || typeof R.UNSAFE_componentWillUpdate != "function" && typeof R.componentWillUpdate != "function" || (typeof R.componentWillUpdate == "function" && R.componentWillUpdate(p, it, F), typeof R.UNSAFE_componentWillUpdate == "function" && R.UNSAFE_componentWillUpdate(p, it, F)), typeof R.componentDidUpdate == "function" && (i.flags |= 4), typeof R.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof R.componentDidUpdate != "function" || P === n.memoizedProps && Se === n.memoizedState || (i.flags |= 4), typeof R.getSnapshotBeforeUpdate != "function" || P === n.memoizedProps && Se === n.memoizedState || (i.flags |= 1024), i.memoizedProps = p, i.memoizedState = it), R.props = p, R.state = it, R.context = F, p = ae) : (typeof R.componentDidUpdate != "function" || P === n.memoizedProps && Se === n.memoizedState || (i.flags |= 4), typeof R.getSnapshotBeforeUpdate != "function" || P === n.memoizedProps && Se === n.memoizedState || (i.flags |= 1024), p = !1);
    }
    return Um(n, i, l, p, S, g);
  }
  function Um(n, i, l, p, g, S) {
    Zt(n, i);
    var R = (i.flags & 128) !== 0;
    if (!p && !R)
      return g && Em(i, l, !1), Si(n, i, S);
    p = i.stateNode, f_.current = i;
    var P = R && typeof l.getDerivedStateFromError != "function" ? null : p.render();
    return i.flags |= 1, n !== null && R ? (i.child = Tc(i, n.child, null, S), i.child = Tc(i, null, P, S)) : Zr(n, i, P, S), i.memoizedState = p.state, g && Em(i, l, !0), i.child;
  }
  function Im(n) {
    var i = n.stateNode;
    i.pendingContext ? Ru(n, i.pendingContext, i.pendingContext !== i.context) : i.context && Ru(n, i.context, !1), Np(n, i.containerInfo);
  }
  function dh(n, i, l, p, g) {
    return pr(), bp(g), i.flags |= 256, Zr(n, i, l, p), i.child;
  }
  var Dl = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Fp(n) {
    return { baseLanes: n, cachePool: null, transitions: null };
  }
  function Hp(n, i, l) {
    var p = i.pendingProps, g = bt.current, S = !1, R = (i.flags & 128) !== 0, P;
    if ((P = R) || (P = n !== null && n.memoizedState === null ? !1 : (g & 2) !== 0), P ? (S = !0, i.flags &= -129) : (n === null || n.memoizedState !== null) && (g |= 1), Ln(bt, g & 1), n === null)
      return Id(i), n = i.memoizedState, n !== null && (n = n.dehydrated, n !== null) ? (i.mode & 1 ? n.data === "$!" ? i.lanes = 8 : i.lanes = 1073741824 : i.lanes = 1, null) : (R = p.children, n = p.fallback, S ? (p = i.mode, S = i.child, R = { mode: "hidden", children: R }, !(p & 1) && S !== null ? (S.childLanes = 0, S.pendingProps = R) : S = $f(R, p, 0, null), n = Ul(n, p, l, null), S.return = i, n.return = i, S.sibling = n, i.child = S, i.child.memoizedState = Fp(l), i.memoizedState = Dl, n) : Bp(i, R));
    if (g = n.memoizedState, g !== null && (P = g.dehydrated, P !== null))
      return d_(n, i, R, p, P, g, l);
    if (S) {
      S = p.fallback, R = i.mode, g = n.child, P = g.sibling;
      var F = { mode: "hidden", children: p.children };
      return !(R & 1) && i.child !== g ? (p = i.child, p.childLanes = 0, p.pendingProps = F, i.deletions = null) : (p = Bu(g, F), p.subtreeFlags = g.subtreeFlags & 14680064), P !== null ? S = Bu(P, S) : (S = Ul(S, R, l, null), S.flags |= 2), S.return = i, p.return = i, p.sibling = S, i.child = p, p = S, S = i.child, R = n.child.memoizedState, R = R === null ? Fp(l) : { baseLanes: R.baseLanes | l, cachePool: null, transitions: R.transitions }, S.memoizedState = R, S.childLanes = n.childLanes & ~l, i.memoizedState = Dl, p;
    }
    return S = n.child, n = S.sibling, p = Bu(S, { mode: "visible", children: p.children }), !(i.mode & 1) && (p.lanes = l), p.return = i, p.sibling = null, n !== null && (l = i.deletions, l === null ? (i.deletions = [n], i.flags |= 16) : l.push(n)), i.child = p, i.memoizedState = null, p;
  }
  function Bp(n, i) {
    return i = $f({ mode: "visible", children: i }, n.mode, 0, null), i.return = n, n.child = i;
  }
  function kc(n, i, l, p) {
    return p !== null && bp(p), Tc(i, n.child, null, l), n = Bp(i, i.pendingProps.children), n.flags |= 2, i.memoizedState = null, n;
  }
  function d_(n, i, l, p, g, S, R) {
    if (l)
      return i.flags & 256 ? (i.flags &= -257, p = zf(Error(d(422))), kc(n, i, R, p)) : i.memoizedState !== null ? (i.child = n.child, i.flags |= 128, null) : (S = p.fallback, g = i.mode, p = $f({ mode: "visible", children: p.children }, g, 0, null), S = Ul(S, g, R, null), S.flags |= 2, p.return = i, S.return = i, p.sibling = S, i.child = p, i.mode & 1 && Tc(i, n.child, null, R), i.child.memoizedState = Fp(R), i.memoizedState = Dl, S);
    if (!(i.mode & 1))
      return kc(n, i, R, null);
    if (g.data === "$!") {
      if (p = g.nextSibling && g.nextSibling.dataset, p)
        var P = p.dgst;
      return p = P, S = Error(d(419)), p = zf(S, p, void 0), kc(n, i, R, p);
    }
    if (P = (R & n.childLanes) !== 0, Ir || P) {
      if (p = mr, p !== null) {
        switch (R & -R) {
          case 4:
            g = 2;
            break;
          case 16:
            g = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            g = 32;
            break;
          case 536870912:
            g = 268435456;
            break;
          default:
            g = 0;
        }
        g = g & (p.suspendedLanes | R) ? 0 : g, g !== 0 && g !== S.retryLane && (S.retryLane = g, Vs(n, g), Fi(p, n, g, -1));
      }
      return ev(), p = zf(Error(d(421))), kc(n, i, R, p);
    }
    return g.data === "$?" ? (i.flags |= 128, i.child = n.child, i = g_.bind(null, n), g._reactRetry = i, null) : (n = S.treeContext, va = Ua(g.nextSibling), Fa = i, ir = !0, yo = null, n !== null && (pa[Ai++] = gi, pa[Ai++] = Ys, pa[Ai++] = mo, gi = n.id, Ys = n.overflow, mo = i), i = Bp(i, p.children), i.flags |= 4096, i);
  }
  function Yp(n, i, l) {
    n.lanes |= i;
    var p = n.alternate;
    p !== null && (p.lanes |= i), oi(n.return, i, l);
  }
  function hh(n, i, l, p, g) {
    var S = n.memoizedState;
    S === null ? n.memoizedState = { isBackwards: i, rendering: null, renderingStartTime: 0, last: p, tail: l, tailMode: g } : (S.isBackwards = i, S.rendering = null, S.renderingStartTime = 0, S.last = p, S.tail = l, S.tailMode = g);
  }
  function Vp(n, i, l) {
    var p = i.pendingProps, g = p.revealOrder, S = p.tail;
    if (Zr(n, i, p.children, l), p = bt.current, p & 2)
      p = p & 1 | 2, i.flags |= 128;
    else {
      if (n !== null && n.flags & 128)
        e:
          for (n = i.child; n !== null; ) {
            if (n.tag === 13)
              n.memoizedState !== null && Yp(n, l, i);
            else if (n.tag === 19)
              Yp(n, l, i);
            else if (n.child !== null) {
              n.child.return = n, n = n.child;
              continue;
            }
            if (n === i)
              break e;
            for (; n.sibling === null; ) {
              if (n.return === null || n.return === i)
                break e;
              n = n.return;
            }
            n.sibling.return = n.return, n = n.sibling;
          }
      p &= 1;
    }
    if (Ln(bt, p), !(i.mode & 1))
      i.memoizedState = null;
    else
      switch (g) {
        case "forwards":
          for (l = i.child, g = null; l !== null; )
            n = l.alternate, n !== null && vr(n) === null && (g = l), l = l.sibling;
          l = g, l === null ? (g = i.child, i.child = null) : (g = l.sibling, l.sibling = null), hh(i, !1, g, l, S);
          break;
        case "backwards":
          for (l = null, g = i.child, i.child = null; g !== null; ) {
            if (n = g.alternate, n !== null && vr(n) === null) {
              i.child = g;
              break;
            }
            n = g.sibling, g.sibling = l, l = g, g = n;
          }
          hh(i, !0, l, null, S);
          break;
        case "together":
          hh(i, !1, null, null, void 0);
          break;
        default:
          i.memoizedState = null;
      }
    return i.child;
  }
  function zi(n, i) {
    !(i.mode & 1) && n !== null && (n.alternate = null, i.alternate = null, i.flags |= 2);
  }
  function Si(n, i, l) {
    if (n !== null && (i.dependencies = n.dependencies), Qs |= i.lanes, !(l & i.childLanes))
      return null;
    if (n !== null && i.child !== n.child)
      throw Error(d(153));
    if (i.child !== null) {
      for (n = i.child, l = Bu(n, n.pendingProps), i.child = l, l.return = i; n.sibling !== null; )
        n = n.sibling, l = l.sibling = Bu(n, n.pendingProps), l.return = i;
      l.sibling = null;
    }
    return i.child;
  }
  function $s(n, i, l) {
    switch (i.tag) {
      case 3:
        Im(i), pr();
        break;
      case 5:
        Tt(i);
        break;
      case 1:
        cr(i.type) && Ad(i);
        break;
      case 4:
        Np(i, i.stateNode.containerInfo);
        break;
      case 10:
        var p = i.type._context, g = i.memoizedProps.value;
        Ln(ys, p._currentValue), p._currentValue = g;
        break;
      case 13:
        if (p = i.memoizedState, p !== null)
          return p.dehydrated !== null ? (Ln(bt, bt.current & 1), i.flags |= 128, null) : l & i.child.childLanes ? Hp(n, i, l) : (Ln(bt, bt.current & 1), n = Si(n, i, l), n !== null ? n.sibling : null);
        Ln(bt, bt.current & 1);
        break;
      case 19:
        if (p = (l & i.childLanes) !== 0, n.flags & 128) {
          if (p)
            return Vp(n, i, l);
          i.flags |= 128;
        }
        if (g = i.memoizedState, g !== null && (g.rendering = null, g.tail = null, g.lastEffect = null), Ln(bt, bt.current), p)
          break;
        return null;
      case 22:
      case 23:
        return i.lanes = 0, Rl(n, i, l);
    }
    return Si(n, i, l);
  }
  var If, kl, So, $r;
  If = function(n, i) {
    for (var l = i.child; l !== null; ) {
      if (l.tag === 5 || l.tag === 6)
        n.appendChild(l.stateNode);
      else if (l.tag !== 4 && l.child !== null) {
        l.child.return = l, l = l.child;
        continue;
      }
      if (l === i)
        break;
      for (; l.sibling === null; ) {
        if (l.return === null || l.return === i)
          return;
        l = l.return;
      }
      l.sibling.return = l.return, l = l.sibling;
    }
  }, kl = function() {
  }, So = function(n, i, l, p) {
    var g = n.memoizedProps;
    if (g !== p) {
      n = i.stateNode, Sl(Go.current);
      var S = null;
      switch (l) {
        case "input":
          g = Ie(n, g), p = Ie(n, p), S = [];
          break;
        case "select":
          g = N({}, g, { value: void 0 }), p = N({}, p, { value: void 0 }), S = [];
          break;
        case "textarea":
          g = fi(n, g), p = fi(n, p), S = [];
          break;
        default:
          typeof g.onClick != "function" && typeof p.onClick == "function" && (n.onclick = ge);
      }
      dr(l, p);
      var R;
      l = null;
      for (ae in g)
        if (!p.hasOwnProperty(ae) && g.hasOwnProperty(ae) && g[ae] != null)
          if (ae === "style") {
            var P = g[ae];
            for (R in P)
              P.hasOwnProperty(R) && (l || (l = {}), l[R] = "");
          } else
            ae !== "dangerouslySetInnerHTML" && ae !== "children" && ae !== "suppressContentEditableWarning" && ae !== "suppressHydrationWarning" && ae !== "autoFocus" && (w.hasOwnProperty(ae) ? S || (S = []) : (S = S || []).push(ae, null));
      for (ae in p) {
        var F = p[ae];
        if (P = g != null ? g[ae] : void 0, p.hasOwnProperty(ae) && F !== P && (F != null || P != null))
          if (ae === "style")
            if (P) {
              for (R in P)
                !P.hasOwnProperty(R) || F && F.hasOwnProperty(R) || (l || (l = {}), l[R] = "");
              for (R in F)
                F.hasOwnProperty(R) && P[R] !== F[R] && (l || (l = {}), l[R] = F[R]);
            } else
              l || (S || (S = []), S.push(
                ae,
                l
              )), l = F;
          else
            ae === "dangerouslySetInnerHTML" ? (F = F ? F.__html : void 0, P = P ? P.__html : void 0, F != null && P !== F && (S = S || []).push(ae, F)) : ae === "children" ? typeof F != "string" && typeof F != "number" || (S = S || []).push(ae, "" + F) : ae !== "suppressContentEditableWarning" && ae !== "suppressHydrationWarning" && (w.hasOwnProperty(ae) ? (F != null && ae === "onScroll" && kn("scroll", n), S || P === F || (S = [])) : (S = S || []).push(ae, F));
      }
      l && (S = S || []).push("style", l);
      var ae = S;
      (i.updateQueue = ae) && (i.flags |= 4);
    }
  }, $r = function(n, i, l, p) {
    l !== p && (i.flags |= 4);
  };
  function jf(n, i) {
    if (!ir)
      switch (n.tailMode) {
        case "hidden":
          i = n.tail;
          for (var l = null; i !== null; )
            i.alternate !== null && (l = i), i = i.sibling;
          l === null ? n.tail = null : l.sibling = null;
          break;
        case "collapsed":
          l = n.tail;
          for (var p = null; l !== null; )
            l.alternate !== null && (p = l), l = l.sibling;
          p === null ? i || n.tail === null ? n.tail = null : n.tail.sibling = null : p.sibling = null;
      }
  }
  function Ui(n) {
    var i = n.alternate !== null && n.alternate.child === n.child, l = 0, p = 0;
    if (i)
      for (var g = n.child; g !== null; )
        l |= g.lanes | g.childLanes, p |= g.subtreeFlags & 14680064, p |= g.flags & 14680064, g.return = n, g = g.sibling;
    else
      for (g = n.child; g !== null; )
        l |= g.lanes | g.childLanes, p |= g.subtreeFlags, p |= g.flags, g.return = n, g = g.sibling;
    return n.subtreeFlags |= p, n.childLanes = l, i;
  }
  function h_(n, i, l) {
    var p = i.pendingProps;
    switch (Cp(i), i.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Ui(i), null;
      case 1:
        return cr(i.type) && vo(), Ui(i), null;
      case 3:
        return p = i.stateNode, Au(), Rn(Cr), Rn(At), Zd(), p.pendingContext && (p.context = p.pendingContext, p.pendingContext = null), (n === null || n.child === null) && (jd(i) ? i.flags |= 4 : n === null || n.memoizedState.isDehydrated && !(i.flags & 256) || (i.flags |= 1024, yo !== null && (Zf(yo), yo = null))), kl(n, i), Ui(i), null;
      case 5:
        Jt(i);
        var g = Sl(Cc.current);
        if (l = i.type, n !== null && i.stateNode != null)
          So(n, i, l, p, g), n.ref !== i.ref && (i.flags |= 512, i.flags |= 2097152);
        else {
          if (!p) {
            if (i.stateNode === null)
              throw Error(d(166));
            return Ui(i), null;
          }
          if (n = Sl(Go.current), jd(i)) {
            p = i.stateNode, l = i.type;
            var S = i.memoizedProps;
            switch (p[ho] = i, p[vs] = S, n = (i.mode & 1) !== 0, l) {
              case "dialog":
                kn("cancel", p), kn("close", p);
                break;
              case "iframe":
              case "object":
              case "embed":
                kn("load", p);
                break;
              case "video":
              case "audio":
                for (g = 0; g < Cu.length; g++)
                  kn(Cu[g], p);
                break;
              case "source":
                kn("error", p);
                break;
              case "img":
              case "image":
              case "link":
                kn(
                  "error",
                  p
                ), kn("load", p);
                break;
              case "details":
                kn("toggle", p);
                break;
              case "input":
                zn(p, S), kn("invalid", p);
                break;
              case "select":
                p._wrapperState = { wasMultiple: !!S.multiple }, kn("invalid", p);
                break;
              case "textarea":
                Br(p, S), kn("invalid", p);
            }
            dr(l, S), g = null;
            for (var R in S)
              if (S.hasOwnProperty(R)) {
                var P = S[R];
                R === "children" ? typeof P == "string" ? p.textContent !== P && (S.suppressHydrationWarning !== !0 && ie(p.textContent, P, n), g = ["children", P]) : typeof P == "number" && p.textContent !== "" + P && (S.suppressHydrationWarning !== !0 && ie(
                  p.textContent,
                  P,
                  n
                ), g = ["children", "" + P]) : w.hasOwnProperty(R) && P != null && R === "onScroll" && kn("scroll", p);
              }
            switch (l) {
              case "input":
                ur(p), Hr(p, S, !0);
                break;
              case "textarea":
                ur(p), Yr(p);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof S.onClick == "function" && (p.onclick = ge);
            }
            p = g, i.updateQueue = p, p !== null && (i.flags |= 4);
          } else {
            R = g.nodeType === 9 ? g : g.ownerDocument, n === "http://www.w3.org/1999/xhtml" && (n = Xr(l)), n === "http://www.w3.org/1999/xhtml" ? l === "script" ? (n = R.createElement("div"), n.innerHTML = "<script><\/script>", n = n.removeChild(n.firstChild)) : typeof p.is == "string" ? n = R.createElement(l, { is: p.is }) : (n = R.createElement(l), l === "select" && (R = n, p.multiple ? R.multiple = !0 : p.size && (R.size = p.size))) : n = R.createElementNS(n, l), n[ho] = i, n[vs] = p, If(n, i, !1, !1), i.stateNode = n;
            e: {
              switch (R = Un(l, p), l) {
                case "dialog":
                  kn("cancel", n), kn("close", n), g = p;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  kn("load", n), g = p;
                  break;
                case "video":
                case "audio":
                  for (g = 0; g < Cu.length; g++)
                    kn(Cu[g], n);
                  g = p;
                  break;
                case "source":
                  kn("error", n), g = p;
                  break;
                case "img":
                case "image":
                case "link":
                  kn(
                    "error",
                    n
                  ), kn("load", n), g = p;
                  break;
                case "details":
                  kn("toggle", n), g = p;
                  break;
                case "input":
                  zn(n, p), g = Ie(n, p), kn("invalid", n);
                  break;
                case "option":
                  g = p;
                  break;
                case "select":
                  n._wrapperState = { wasMultiple: !!p.multiple }, g = N({}, p, { value: void 0 }), kn("invalid", n);
                  break;
                case "textarea":
                  Br(n, p), g = fi(n, p), kn("invalid", n);
                  break;
                default:
                  g = p;
              }
              dr(l, g), P = g;
              for (S in P)
                if (P.hasOwnProperty(S)) {
                  var F = P[S];
                  S === "style" ? dn(n, F) : S === "dangerouslySetInnerHTML" ? (F = F ? F.__html : void 0, F != null && Qa(n, F)) : S === "children" ? typeof F == "string" ? (l !== "textarea" || F !== "") && Oi(n, F) : typeof F == "number" && Oi(n, "" + F) : S !== "suppressContentEditableWarning" && S !== "suppressHydrationWarning" && S !== "autoFocus" && (w.hasOwnProperty(S) ? F != null && S === "onScroll" && kn("scroll", n) : F != null && ve(n, S, F, R));
                }
              switch (l) {
                case "input":
                  ur(n), Hr(n, p, !1);
                  break;
                case "textarea":
                  ur(n), Yr(n);
                  break;
                case "option":
                  p.value != null && n.setAttribute("value", "" + _t(p.value));
                  break;
                case "select":
                  n.multiple = !!p.multiple, S = p.value, S != null ? zr(n, !!p.multiple, S, !1) : p.defaultValue != null && zr(
                    n,
                    !!p.multiple,
                    p.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof g.onClick == "function" && (n.onclick = ge);
              }
              switch (l) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  p = !!p.autoFocus;
                  break e;
                case "img":
                  p = !0;
                  break e;
                default:
                  p = !1;
              }
            }
            p && (i.flags |= 4);
          }
          i.ref !== null && (i.flags |= 512, i.flags |= 2097152);
        }
        return Ui(i), null;
      case 6:
        if (n && i.stateNode != null)
          $r(n, i, n.memoizedProps, p);
        else {
          if (typeof p != "string" && i.stateNode === null)
            throw Error(d(166));
          if (l = Sl(Cc.current), Sl(Go.current), jd(i)) {
            if (p = i.stateNode, l = i.memoizedProps, p[ho] = i, (S = p.nodeValue !== l) && (n = Fa, n !== null))
              switch (n.tag) {
                case 3:
                  ie(p.nodeValue, l, (n.mode & 1) !== 0);
                  break;
                case 5:
                  n.memoizedProps.suppressHydrationWarning !== !0 && ie(p.nodeValue, l, (n.mode & 1) !== 0);
              }
            S && (i.flags |= 4);
          } else
            p = (l.nodeType === 9 ? l : l.ownerDocument).createTextNode(p), p[ho] = i, i.stateNode = p;
        }
        return Ui(i), null;
      case 13:
        if (Rn(bt), p = i.memoizedState, n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
          if (ir && va !== null && i.mode & 1 && !(i.flags & 128))
            xm(), pr(), i.flags |= 98560, S = !1;
          else if (S = jd(i), p !== null && p.dehydrated !== null) {
            if (n === null) {
              if (!S)
                throw Error(d(318));
              if (S = i.memoizedState, S = S !== null ? S.dehydrated : null, !S)
                throw Error(d(317));
              S[ho] = i;
            } else
              pr(), !(i.flags & 128) && (i.memoizedState = null), i.flags |= 4;
            Ui(i), S = !1;
          } else
            yo !== null && (Zf(yo), yo = null), S = !0;
          if (!S)
            return i.flags & 65536 ? i : null;
        }
        return i.flags & 128 ? (i.lanes = l, i) : (p = p !== null, p !== (n !== null && n.memoizedState !== null) && p && (i.child.flags |= 8192, i.mode & 1 && (n === null || bt.current & 1 ? Qr === 0 && (Qr = 3) : ev())), i.updateQueue !== null && (i.flags |= 4), Ui(i), null);
      case 4:
        return Au(), kl(n, i), n === null && Fs(i.stateNode.containerInfo), Ui(i), null;
      case 10:
        return Ou(i.type._context), Ui(i), null;
      case 17:
        return cr(i.type) && vo(), Ui(i), null;
      case 19:
        if (Rn(bt), S = i.memoizedState, S === null)
          return Ui(i), null;
        if (p = (i.flags & 128) !== 0, R = S.rendering, R === null)
          if (p)
            jf(S, !1);
          else {
            if (Qr !== 0 || n !== null && n.flags & 128)
              for (n = i.child; n !== null; ) {
                if (R = vr(n), R !== null) {
                  for (i.flags |= 128, jf(S, !1), p = R.updateQueue, p !== null && (i.updateQueue = p, i.flags |= 4), i.subtreeFlags = 0, p = l, l = i.child; l !== null; )
                    S = l, n = p, S.flags &= 14680066, R = S.alternate, R === null ? (S.childLanes = 0, S.lanes = n, S.child = null, S.subtreeFlags = 0, S.memoizedProps = null, S.memoizedState = null, S.updateQueue = null, S.dependencies = null, S.stateNode = null) : (S.childLanes = R.childLanes, S.lanes = R.lanes, S.child = R.child, S.subtreeFlags = 0, S.deletions = null, S.memoizedProps = R.memoizedProps, S.memoizedState = R.memoizedState, S.updateQueue = R.updateQueue, S.type = R.type, n = R.dependencies, S.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }), l = l.sibling;
                  return Ln(bt, bt.current & 1 | 2), i.child;
                }
                n = n.sibling;
              }
            S.tail !== null && cn() > Uc && (i.flags |= 128, p = !0, jf(S, !1), i.lanes = 4194304);
          }
        else {
          if (!p)
            if (n = vr(R), n !== null) {
              if (i.flags |= 128, p = !0, l = n.updateQueue, l !== null && (i.updateQueue = l, i.flags |= 4), jf(S, !0), S.tail === null && S.tailMode === "hidden" && !R.alternate && !ir)
                return Ui(i), null;
            } else
              2 * cn() - S.renderingStartTime > Uc && l !== 1073741824 && (i.flags |= 128, p = !0, jf(S, !1), i.lanes = 4194304);
          S.isBackwards ? (R.sibling = i.child, i.child = R) : (l = S.last, l !== null ? l.sibling = R : i.child = R, S.last = R);
        }
        return S.tail !== null ? (i = S.tail, S.rendering = i, S.tail = i.sibling, S.renderingStartTime = cn(), i.sibling = null, l = bt.current, Ln(bt, p ? l & 1 | 2 : l & 1), i) : (Ui(i), null);
      case 22:
      case 23:
        return Jp(), p = i.memoizedState !== null, n !== null && n.memoizedState !== null !== p && (i.flags |= 8192), p && i.mode & 1 ? Ya & 1073741824 && (Ui(i), i.subtreeFlags & 6 && (i.flags |= 8192)) : Ui(i), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(d(156, i.tag));
  }
  function Wp(n, i) {
    switch (Cp(i), i.tag) {
      case 1:
        return cr(i.type) && vo(), n = i.flags, n & 65536 ? (i.flags = n & -65537 | 128, i) : null;
      case 3:
        return Au(), Rn(Cr), Rn(At), Zd(), n = i.flags, n & 65536 && !(n & 128) ? (i.flags = n & -65537 | 128, i) : null;
      case 5:
        return Jt(i), null;
      case 13:
        if (Rn(bt), n = i.memoizedState, n !== null && n.dehydrated !== null) {
          if (i.alternate === null)
            throw Error(d(340));
          pr();
        }
        return n = i.flags, n & 65536 ? (i.flags = n & -65537 | 128, i) : null;
      case 19:
        return Rn(bt), null;
      case 4:
        return Au(), null;
      case 10:
        return Ou(i.type._context), null;
      case 22:
      case 23:
        return Jp(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Ff = !1, Gr = !1, jm = typeof WeakSet == "function" ? WeakSet : Set, tt = null;
  function Oc(n, i) {
    var l = n.ref;
    if (l !== null)
      if (typeof l == "function")
        try {
          l(null);
        } catch (p) {
          br(n, i, p);
        }
      else
        l.current = null;
  }
  function Hf(n, i, l) {
    try {
      l();
    } catch (p) {
      br(n, i, p);
    }
  }
  var Fm = !1;
  function Hm(n, i) {
    if (Fe = Zi, n = dl(), Wo(n)) {
      if ("selectionStart" in n)
        var l = { start: n.selectionStart, end: n.selectionEnd };
      else
        e: {
          l = (l = n.ownerDocument) && l.defaultView || window;
          var p = l.getSelection && l.getSelection();
          if (p && p.rangeCount !== 0) {
            l = p.anchorNode;
            var g = p.anchorOffset, S = p.focusNode;
            p = p.focusOffset;
            try {
              l.nodeType, S.nodeType;
            } catch {
              l = null;
              break e;
            }
            var R = 0, P = -1, F = -1, ae = 0, we = 0, Ee = n, Se = null;
            t:
              for (; ; ) {
                for (var Ze; Ee !== l || g !== 0 && Ee.nodeType !== 3 || (P = R + g), Ee !== S || p !== 0 && Ee.nodeType !== 3 || (F = R + p), Ee.nodeType === 3 && (R += Ee.nodeValue.length), (Ze = Ee.firstChild) !== null; )
                  Se = Ee, Ee = Ze;
                for (; ; ) {
                  if (Ee === n)
                    break t;
                  if (Se === l && ++ae === g && (P = R), Se === S && ++we === p && (F = R), (Ze = Ee.nextSibling) !== null)
                    break;
                  Ee = Se, Se = Ee.parentNode;
                }
                Ee = Ze;
              }
            l = P === -1 || F === -1 ? null : { start: P, end: F };
          } else
            l = null;
        }
      l = l || { start: 0, end: 0 };
    } else
      l = null;
    for (ht = { focusedElem: n, selectionRange: l }, Zi = !1, tt = i; tt !== null; )
      if (i = tt, n = i.child, (i.subtreeFlags & 1028) !== 0 && n !== null)
        n.return = i, tt = n;
      else
        for (; tt !== null; ) {
          i = tt;
          try {
            var it = i.alternate;
            if (i.flags & 1024)
              switch (i.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (it !== null) {
                    var st = it.memoizedProps, Pr = it.memoizedState, q = i.stateNode, Y = q.getSnapshotBeforeUpdate(i.elementType === i.type ? st : Ha(i.type, st), Pr);
                    q.__reactInternalSnapshotBeforeUpdate = Y;
                  }
                  break;
                case 3:
                  var ee = i.stateNode.containerInfo;
                  ee.nodeType === 1 ? ee.textContent = "" : ee.nodeType === 9 && ee.documentElement && ee.removeChild(ee.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(d(163));
              }
          } catch (Re) {
            br(i, i.return, Re);
          }
          if (n = i.sibling, n !== null) {
            n.return = i.return, tt = n;
            break;
          }
          tt = i.return;
        }
    return it = Fm, Fm = !1, it;
  }
  function Bf(n, i, l) {
    var p = i.updateQueue;
    if (p = p !== null ? p.lastEffect : null, p !== null) {
      var g = p = p.next;
      do {
        if ((g.tag & n) === n) {
          var S = g.destroy;
          g.destroy = void 0, S !== void 0 && Hf(i, l, S);
        }
        g = g.next;
      } while (g !== p);
    }
  }
  function Yf(n, i) {
    if (i = i.updateQueue, i = i !== null ? i.lastEffect : null, i !== null) {
      var l = i = i.next;
      do {
        if ((l.tag & n) === n) {
          var p = l.create;
          l.destroy = p();
        }
        l = l.next;
      } while (l !== i);
    }
  }
  function Zp(n) {
    var i = n.ref;
    if (i !== null) {
      var l = n.stateNode;
      switch (n.tag) {
        case 5:
          n = l;
          break;
        default:
          n = l;
      }
      typeof i == "function" ? i(n) : i.current = n;
    }
  }
  function $p(n) {
    var i = n.alternate;
    i !== null && (n.alternate = null, $p(i)), n.child = null, n.deletions = null, n.sibling = null, n.tag === 5 && (i = n.stateNode, i !== null && (delete i[ho], delete i[vs], delete i[bu], delete i[Sp], delete i[Mf])), n.stateNode = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null;
  }
  function Bm(n) {
    return n.tag === 5 || n.tag === 3 || n.tag === 4;
  }
  function ph(n) {
    e:
      for (; ; ) {
        for (; n.sibling === null; ) {
          if (n.return === null || Bm(n.return))
            return null;
          n = n.return;
        }
        for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18; ) {
          if (n.flags & 2 || n.child === null || n.tag === 4)
            continue e;
          n.child.return = n, n = n.child;
        }
        if (!(n.flags & 2))
          return n.stateNode;
      }
  }
  function Lc(n, i, l) {
    var p = n.tag;
    if (p === 5 || p === 6)
      n = n.stateNode, i ? l.nodeType === 8 ? l.parentNode.insertBefore(n, i) : l.insertBefore(n, i) : (l.nodeType === 8 ? (i = l.parentNode, i.insertBefore(n, l)) : (i = l, i.appendChild(n)), l = l._reactRootContainer, l != null || i.onclick !== null || (i.onclick = ge));
    else if (p !== 4 && (n = n.child, n !== null))
      for (Lc(n, i, l), n = n.sibling; n !== null; )
        Lc(n, i, l), n = n.sibling;
  }
  function _s(n, i, l) {
    var p = n.tag;
    if (p === 5 || p === 6)
      n = n.stateNode, i ? l.insertBefore(n, i) : l.appendChild(n);
    else if (p !== 4 && (n = n.child, n !== null))
      for (_s(n, i, l), n = n.sibling; n !== null; )
        _s(n, i, l), n = n.sibling;
  }
  var fr = null, si = !1;
  function wo(n, i, l) {
    for (l = l.child; l !== null; )
      Nc(n, i, l), l = l.sibling;
  }
  function Nc(n, i, l) {
    if (di && typeof di.onCommitFiberUnmount == "function")
      try {
        di.onCommitFiberUnmount(Po, l);
      } catch {
      }
    switch (l.tag) {
      case 5:
        Gr || Oc(l, i);
      case 6:
        var p = fr, g = si;
        fr = null, wo(n, i, l), fr = p, si = g, fr !== null && (si ? (n = fr, l = l.stateNode, n.nodeType === 8 ? n.parentNode.removeChild(l) : n.removeChild(l)) : fr.removeChild(l.stateNode));
        break;
      case 18:
        fr !== null && (si ? (n = fr, l = l.stateNode, n.nodeType === 8 ? ps(n.parentNode, l) : n.nodeType === 1 && ps(n, l), Li(n)) : ps(fr, l.stateNode));
        break;
      case 4:
        p = fr, g = si, fr = l.stateNode.containerInfo, si = !0, wo(n, i, l), fr = p, si = g;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Gr && (p = l.updateQueue, p !== null && (p = p.lastEffect, p !== null))) {
          g = p = p.next;
          do {
            var S = g, R = S.destroy;
            S = S.tag, R !== void 0 && (S & 2 || S & 4) && Hf(l, i, R), g = g.next;
          } while (g !== p);
        }
        wo(n, i, l);
        break;
      case 1:
        if (!Gr && (Oc(l, i), p = l.stateNode, typeof p.componentWillUnmount == "function"))
          try {
            p.props = l.memoizedProps, p.state = l.memoizedState, p.componentWillUnmount();
          } catch (P) {
            br(l, i, P);
          }
        wo(n, i, l);
        break;
      case 21:
        wo(n, i, l);
        break;
      case 22:
        l.mode & 1 ? (Gr = (p = Gr) || l.memoizedState !== null, wo(n, i, l), Gr = p) : wo(n, i, l);
        break;
      default:
        wo(n, i, l);
    }
  }
  function Gs(n) {
    var i = n.updateQueue;
    if (i !== null) {
      n.updateQueue = null;
      var l = n.stateNode;
      l === null && (l = n.stateNode = new jm()), i.forEach(function(p) {
        var g = __.bind(null, n, p);
        l.has(p) || (l.add(p), p.then(g, g));
      });
    }
  }
  function Qo(n, i) {
    var l = i.deletions;
    if (l !== null)
      for (var p = 0; p < l.length; p++) {
        var g = l[p];
        try {
          var S = n, R = i, P = R;
          e:
            for (; P !== null; ) {
              switch (P.tag) {
                case 5:
                  fr = P.stateNode, si = !1;
                  break e;
                case 3:
                  fr = P.stateNode.containerInfo, si = !0;
                  break e;
                case 4:
                  fr = P.stateNode.containerInfo, si = !0;
                  break e;
              }
              P = P.return;
            }
          if (fr === null)
            throw Error(d(160));
          Nc(S, R, g), fr = null, si = !1;
          var F = g.alternate;
          F !== null && (F.return = null), g.return = null;
        } catch (ae) {
          br(g, i, ae);
        }
      }
    if (i.subtreeFlags & 12854)
      for (i = i.child; i !== null; )
        Ym(i, n), i = i.sibling;
  }
  function Ym(n, i) {
    var l = n.alternate, p = n.flags;
    switch (n.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Qo(i, n), Ss(n), p & 4) {
          try {
            Bf(3, n, n.return), Yf(3, n);
          } catch (st) {
            br(n, n.return, st);
          }
          try {
            Bf(5, n, n.return);
          } catch (st) {
            br(n, n.return, st);
          }
        }
        break;
      case 1:
        Qo(i, n), Ss(n), p & 512 && l !== null && Oc(l, l.return);
        break;
      case 5:
        if (Qo(i, n), Ss(n), p & 512 && l !== null && Oc(l, l.return), n.flags & 32) {
          var g = n.stateNode;
          try {
            Oi(g, "");
          } catch (st) {
            br(n, n.return, st);
          }
        }
        if (p & 4 && (g = n.stateNode, g != null)) {
          var S = n.memoizedProps, R = l !== null ? l.memoizedProps : S, P = n.type, F = n.updateQueue;
          if (n.updateQueue = null, F !== null)
            try {
              P === "input" && S.type === "radio" && S.name != null && Xn(g, S), Un(P, R);
              var ae = Un(P, S);
              for (R = 0; R < F.length; R += 2) {
                var we = F[R], Ee = F[R + 1];
                we === "style" ? dn(g, Ee) : we === "dangerouslySetInnerHTML" ? Qa(g, Ee) : we === "children" ? Oi(g, Ee) : ve(g, we, Ee, ae);
              }
              switch (P) {
                case "input":
                  Bn(g, S);
                  break;
                case "textarea":
                  Yi(g, S);
                  break;
                case "select":
                  var Se = g._wrapperState.wasMultiple;
                  g._wrapperState.wasMultiple = !!S.multiple;
                  var Ze = S.value;
                  Ze != null ? zr(g, !!S.multiple, Ze, !1) : Se !== !!S.multiple && (S.defaultValue != null ? zr(
                    g,
                    !!S.multiple,
                    S.defaultValue,
                    !0
                  ) : zr(g, !!S.multiple, S.multiple ? [] : "", !1));
              }
              g[vs] = S;
            } catch (st) {
              br(n, n.return, st);
            }
        }
        break;
      case 6:
        if (Qo(i, n), Ss(n), p & 4) {
          if (n.stateNode === null)
            throw Error(d(162));
          g = n.stateNode, S = n.memoizedProps;
          try {
            g.nodeValue = S;
          } catch (st) {
            br(n, n.return, st);
          }
        }
        break;
      case 3:
        if (Qo(i, n), Ss(n), p & 4 && l !== null && l.memoizedState.isDehydrated)
          try {
            Li(i.containerInfo);
          } catch (st) {
            br(n, n.return, st);
          }
        break;
      case 4:
        Qo(i, n), Ss(n);
        break;
      case 13:
        Qo(i, n), Ss(n), g = n.child, g.flags & 8192 && (S = g.memoizedState !== null, g.stateNode.isHidden = S, !S || g.alternate !== null && g.alternate.memoizedState !== null || (qp = cn())), p & 4 && Gs(n);
        break;
      case 22:
        if (we = l !== null && l.memoizedState !== null, n.mode & 1 ? (Gr = (ae = Gr) || we, Qo(i, n), Gr = ae) : Qo(i, n), Ss(n), p & 8192) {
          if (ae = n.memoizedState !== null, (n.stateNode.isHidden = ae) && !we && n.mode & 1)
            for (tt = n, we = n.child; we !== null; ) {
              for (Ee = tt = we; tt !== null; ) {
                switch (Se = tt, Ze = Se.child, Se.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Bf(4, Se, Se.return);
                    break;
                  case 1:
                    Oc(Se, Se.return);
                    var it = Se.stateNode;
                    if (typeof it.componentWillUnmount == "function") {
                      p = Se, l = Se.return;
                      try {
                        i = p, it.props = i.memoizedProps, it.state = i.memoizedState, it.componentWillUnmount();
                      } catch (st) {
                        br(p, l, st);
                      }
                    }
                    break;
                  case 5:
                    Oc(Se, Se.return);
                    break;
                  case 22:
                    if (Se.memoizedState !== null) {
                      Gp(Ee);
                      continue;
                    }
                }
                Ze !== null ? (Ze.return = Se, tt = Ze) : Gp(Ee);
              }
              we = we.sibling;
            }
          e:
            for (we = null, Ee = n; ; ) {
              if (Ee.tag === 5) {
                if (we === null) {
                  we = Ee;
                  try {
                    g = Ee.stateNode, ae ? (S = g.style, typeof S.setProperty == "function" ? S.setProperty("display", "none", "important") : S.display = "none") : (P = Ee.stateNode, F = Ee.memoizedProps.style, R = F != null && F.hasOwnProperty("display") ? F.display : null, P.style.display = Yt("display", R));
                  } catch (st) {
                    br(n, n.return, st);
                  }
                }
              } else if (Ee.tag === 6) {
                if (we === null)
                  try {
                    Ee.stateNode.nodeValue = ae ? "" : Ee.memoizedProps;
                  } catch (st) {
                    br(n, n.return, st);
                  }
              } else if ((Ee.tag !== 22 && Ee.tag !== 23 || Ee.memoizedState === null || Ee === n) && Ee.child !== null) {
                Ee.child.return = Ee, Ee = Ee.child;
                continue;
              }
              if (Ee === n)
                break e;
              for (; Ee.sibling === null; ) {
                if (Ee.return === null || Ee.return === n)
                  break e;
                we === Ee && (we = null), Ee = Ee.return;
              }
              we === Ee && (we = null), Ee.sibling.return = Ee.return, Ee = Ee.sibling;
            }
        }
        break;
      case 19:
        Qo(i, n), Ss(n), p & 4 && Gs(n);
        break;
      case 21:
        break;
      default:
        Qo(
          i,
          n
        ), Ss(n);
    }
  }
  function Ss(n) {
    var i = n.flags;
    if (i & 2) {
      try {
        e: {
          for (var l = n.return; l !== null; ) {
            if (Bm(l)) {
              var p = l;
              break e;
            }
            l = l.return;
          }
          throw Error(d(160));
        }
        switch (p.tag) {
          case 5:
            var g = p.stateNode;
            p.flags & 32 && (Oi(g, ""), p.flags &= -33);
            var S = ph(n);
            _s(n, S, g);
            break;
          case 3:
          case 4:
            var R = p.stateNode.containerInfo, P = ph(n);
            Lc(n, P, R);
            break;
          default:
            throw Error(d(161));
        }
      } catch (F) {
        br(n, n.return, F);
      }
      n.flags &= -3;
    }
    i & 4096 && (n.flags &= -4097);
  }
  function Vm(n, i, l) {
    tt = n, Pc(n);
  }
  function Pc(n, i, l) {
    for (var p = (n.mode & 1) !== 0; tt !== null; ) {
      var g = tt, S = g.child;
      if (g.tag === 22 && p) {
        var R = g.memoizedState !== null || Ff;
        if (!R) {
          var P = g.alternate, F = P !== null && P.memoizedState !== null || Gr;
          P = Ff;
          var ae = Gr;
          if (Ff = R, (Gr = F) && !ae)
            for (tt = g; tt !== null; )
              R = tt, F = R.child, R.tag === 22 && R.memoizedState !== null ? Zm(g) : F !== null ? (F.return = R, tt = F) : Zm(g);
          for (; S !== null; )
            tt = S, Pc(S), S = S.sibling;
          tt = g, Ff = P, Gr = ae;
        }
        Wm(n);
      } else
        g.subtreeFlags & 8772 && S !== null ? (S.return = g, tt = S) : Wm(n);
    }
  }
  function Wm(n) {
    for (; tt !== null; ) {
      var i = tt;
      if (i.flags & 8772) {
        var l = i.alternate;
        try {
          if (i.flags & 8772)
            switch (i.tag) {
              case 0:
              case 11:
              case 15:
                Gr || Yf(5, i);
                break;
              case 1:
                var p = i.stateNode;
                if (i.flags & 4 && !Gr)
                  if (l === null)
                    p.componentDidMount();
                  else {
                    var g = i.elementType === i.type ? l.memoizedProps : Ha(i.type, l.memoizedProps);
                    p.componentDidUpdate(g, l.memoizedState, p.__reactInternalSnapshotBeforeUpdate);
                  }
                var S = i.updateQueue;
                S !== null && _l(i, S, p);
                break;
              case 3:
                var R = i.updateQueue;
                if (R !== null) {
                  if (l = null, i.child !== null)
                    switch (i.child.tag) {
                      case 5:
                        l = i.child.stateNode;
                        break;
                      case 1:
                        l = i.child.stateNode;
                    }
                  _l(i, R, l);
                }
                break;
              case 5:
                var P = i.stateNode;
                if (l === null && i.flags & 4) {
                  l = P;
                  var F = i.memoizedProps;
                  switch (i.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      F.autoFocus && l.focus();
                      break;
                    case "img":
                      F.src && (l.src = F.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (i.memoizedState === null) {
                  var ae = i.alternate;
                  if (ae !== null) {
                    var we = ae.memoizedState;
                    if (we !== null) {
                      var Ee = we.dehydrated;
                      Ee !== null && Li(Ee);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(d(163));
            }
          Gr || i.flags & 512 && Zp(i);
        } catch (Se) {
          br(i, i.return, Se);
        }
      }
      if (i === n) {
        tt = null;
        break;
      }
      if (l = i.sibling, l !== null) {
        l.return = i.return, tt = l;
        break;
      }
      tt = i.return;
    }
  }
  function Gp(n) {
    for (; tt !== null; ) {
      var i = tt;
      if (i === n) {
        tt = null;
        break;
      }
      var l = i.sibling;
      if (l !== null) {
        l.return = i.return, tt = l;
        break;
      }
      tt = i.return;
    }
  }
  function Zm(n) {
    for (; tt !== null; ) {
      var i = tt;
      try {
        switch (i.tag) {
          case 0:
          case 11:
          case 15:
            var l = i.return;
            try {
              Yf(4, i);
            } catch (F) {
              br(i, l, F);
            }
            break;
          case 1:
            var p = i.stateNode;
            if (typeof p.componentDidMount == "function") {
              var g = i.return;
              try {
                p.componentDidMount();
              } catch (F) {
                br(i, g, F);
              }
            }
            var S = i.return;
            try {
              Zp(i);
            } catch (F) {
              br(i, S, F);
            }
            break;
          case 5:
            var R = i.return;
            try {
              Zp(i);
            } catch (F) {
              br(i, R, F);
            }
        }
      } catch (F) {
        br(i, i.return, F);
      }
      if (i === n) {
        tt = null;
        break;
      }
      var P = i.sibling;
      if (P !== null) {
        P.return = i.return, tt = P;
        break;
      }
      tt = i.return;
    }
  }
  var vh = Math.ceil, Vf = ye.ReactCurrentDispatcher, Qp = ye.ReactCurrentOwner, Ii = ye.ReactCurrentBatchConfig, un = 0, mr = null, xr = null, ui = 0, Ya = 0, Ac = Wt(0), Qr = 0, Wf = null, Qs = 0, mh = 0, zc = 0, Ol = null, Gi = null, qp = 0, Uc = 1 / 0, qs = null, yh = !1, Ll = null, ws = null, ju = !1, Fu = null, gh = 0, Ic = 0, _h = null, Nl = -1, Pl = 0;
  function ji() {
    return un & 6 ? cn() : Nl !== -1 ? Nl : Nl = cn();
  }
  function jr(n) {
    return n.mode & 1 ? un & 2 && ui !== 0 ? ui & -ui : Fd.transition !== null ? (Pl === 0 && (Pl = pu()), Pl) : (n = nn, n !== 0 || (n = window.event, n = n === void 0 ? 16 : Kt(n.type)), n) : 1;
  }
  function Fi(n, i, l, p) {
    if (50 < Ic)
      throw Ic = 0, _h = null, Error(d(185));
    hi(n, l, p), (!(un & 2) || n !== mr) && (n === mr && (!(un & 2) && (mh |= l), Qr === 4 && Eo(n, ui)), Hi(n, p), l === 1 && un === 0 && !(i.mode & 1) && (Uc = cn() + 500, ai && da()));
  }
  function Hi(n, i) {
    var l = n.callbackNode;
    Oa(n, i);
    var p = sn(n, n === mr ? ui : 0);
    if (p === 0)
      l !== null && Ur(l), n.callbackNode = null, n.callbackPriority = 0;
    else if (i = p & -p, n.callbackPriority !== i) {
      if (l != null && Ur(l), i === 1)
        n.tag === 0 ? Ep($m.bind(null, n)) : wp($m.bind(null, n)), ii(function() {
          !(un & 6) && da();
        }), l = null;
      else {
        switch (ao(p)) {
          case 1:
            l = Da;
            break;
          case 4:
            l = Gt;
            break;
          case 16:
            l = eo;
            break;
          case 536870912:
            l = no;
            break;
          default:
            l = eo;
        }
        l = nv(l, jc.bind(null, n));
      }
      n.callbackPriority = i, n.callbackNode = l;
    }
  }
  function jc(n, i) {
    if (Nl = -1, Pl = 0, un & 6)
      throw Error(d(327));
    var l = n.callbackNode;
    if (Hc() && n.callbackNode !== l)
      return null;
    var p = sn(n, n === mr ? ui : 0);
    if (p === 0)
      return null;
    if (p & 30 || p & n.expiredLanes || i)
      i = wh(n, p);
    else {
      i = p;
      var g = un;
      un |= 2;
      var S = Sh();
      (mr !== n || ui !== i) && (qs = null, Uc = cn() + 500, Al(n, i));
      do
        try {
          v_();
          break;
        } catch (P) {
          Gm(n, P);
        }
      while (1);
      Rp(), Vf.current = S, un = g, xr !== null ? i = 0 : (mr = null, ui = 0, i = Qr);
    }
    if (i !== 0) {
      if (i === 2 && (g = kr(n), g !== 0 && (p = g, i = Kp(n, g))), i === 1)
        throw l = Wf, Al(n, 0), Eo(n, p), Hi(n, cn()), l;
      if (i === 6)
        Eo(n, p);
      else {
        if (g = n.current.alternate, !(p & 30) && !Xp(g) && (i = wh(n, p), i === 2 && (S = kr(n), S !== 0 && (p = S, i = Kp(n, S))), i === 1))
          throw l = Wf, Al(n, 0), Eo(n, p), Hi(n, cn()), l;
        switch (n.finishedWork = g, n.finishedLanes = p, i) {
          case 0:
          case 1:
            throw Error(d(345));
          case 2:
            zl(n, Gi, qs);
            break;
          case 3:
            if (Eo(n, p), (p & 130023424) === p && (i = qp + 500 - cn(), 10 < i)) {
              if (sn(n, 0) !== 0)
                break;
              if (g = n.suspendedLanes, (g & p) !== p) {
                ji(), n.pingedLanes |= n.suspendedLanes & g;
                break;
              }
              n.timeoutHandle = hr(zl.bind(null, n, Gi, qs), i);
              break;
            }
            zl(n, Gi, qs);
            break;
          case 4:
            if (Eo(n, p), (p & 4194240) === p)
              break;
            for (i = n.eventTimes, g = -1; 0 < p; ) {
              var R = 31 - Pt(p);
              S = 1 << R, R = i[R], R > g && (g = R), p &= ~S;
            }
            if (p = g, p = cn() - p, p = (120 > p ? 120 : 480 > p ? 480 : 1080 > p ? 1080 : 1920 > p ? 1920 : 3e3 > p ? 3e3 : 4320 > p ? 4320 : 1960 * vh(p / 1960)) - p, 10 < p) {
              n.timeoutHandle = hr(zl.bind(null, n, Gi, qs), p);
              break;
            }
            zl(n, Gi, qs);
            break;
          case 5:
            zl(n, Gi, qs);
            break;
          default:
            throw Error(d(329));
        }
      }
    }
    return Hi(n, cn()), n.callbackNode === l ? jc.bind(null, n) : null;
  }
  function Kp(n, i) {
    var l = Ol;
    return n.current.memoizedState.isDehydrated && (Al(n, i).flags |= 256), n = wh(n, i), n !== 2 && (i = Gi, Gi = l, i !== null && Zf(i)), n;
  }
  function Zf(n) {
    Gi === null ? Gi = n : Gi.push.apply(Gi, n);
  }
  function Xp(n) {
    for (var i = n; ; ) {
      if (i.flags & 16384) {
        var l = i.updateQueue;
        if (l !== null && (l = l.stores, l !== null))
          for (var p = 0; p < l.length; p++) {
            var g = l[p], S = g.getSnapshot;
            g = g.value;
            try {
              if (!ua(S(), g))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (l = i.child, i.subtreeFlags & 16384 && l !== null)
        l.return = i, i = l;
      else {
        if (i === n)
          break;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === n)
            return !0;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
    }
    return !0;
  }
  function Eo(n, i) {
    for (i &= ~zc, i &= ~mh, n.suspendedLanes |= i, n.pingedLanes &= ~i, n = n.expirationTimes; 0 < i; ) {
      var l = 31 - Pt(i), p = 1 << l;
      n[l] = -1, i &= ~p;
    }
  }
  function $m(n) {
    if (un & 6)
      throw Error(d(327));
    Hc();
    var i = sn(n, 0);
    if (!(i & 1))
      return Hi(n, cn()), null;
    var l = wh(n, i);
    if (n.tag !== 0 && l === 2) {
      var p = kr(n);
      p !== 0 && (i = p, l = Kp(n, p));
    }
    if (l === 1)
      throw l = Wf, Al(n, 0), Eo(n, i), Hi(n, cn()), l;
    if (l === 6)
      throw Error(d(345));
    return n.finishedWork = n.current.alternate, n.finishedLanes = i, zl(n, Gi, qs), Hi(n, cn()), null;
  }
  function Fc(n, i) {
    var l = un;
    un |= 1;
    try {
      return n(i);
    } finally {
      un = l, un === 0 && (Uc = cn() + 500, ai && da());
    }
  }
  function Hu(n) {
    Fu !== null && Fu.tag === 0 && !(un & 6) && Hc();
    var i = un;
    un |= 1;
    var l = Ii.transition, p = nn;
    try {
      if (Ii.transition = null, nn = 1, n)
        return n();
    } finally {
      nn = p, Ii.transition = l, un = i, !(un & 6) && da();
    }
  }
  function Jp() {
    Ya = Ac.current, Rn(Ac);
  }
  function Al(n, i) {
    n.finishedWork = null, n.finishedLanes = 0;
    var l = n.timeoutHandle;
    if (l !== -1 && (n.timeoutHandle = -1, Lr(l)), xr !== null)
      for (l = xr.return; l !== null; ) {
        var p = l;
        switch (Cp(p), p.tag) {
          case 1:
            p = p.type.childContextTypes, p != null && vo();
            break;
          case 3:
            Au(), Rn(Cr), Rn(At), Zd();
            break;
          case 5:
            Jt(p);
            break;
          case 4:
            Au();
            break;
          case 13:
            Rn(bt);
            break;
          case 19:
            Rn(bt);
            break;
          case 10:
            Ou(p.type._context);
            break;
          case 22:
          case 23:
            Jp();
        }
        l = l.return;
      }
    if (mr = n, xr = n = Bu(n.current, null), ui = Ya = i, Qr = 0, Wf = null, zc = mh = Qs = 0, Gi = Ol = null, _i !== null) {
      for (i = 0; i < _i.length; i++)
        if (l = _i[i], p = l.interleaved, p !== null) {
          l.interleaved = null;
          var g = p.next, S = l.pending;
          if (S !== null) {
            var R = S.next;
            S.next = g, p.next = R;
          }
          l.pending = p;
        }
      _i = null;
    }
    return n;
  }
  function Gm(n, i) {
    do {
      var l = xr;
      try {
        if (Rp(), $d.current = lh, Dt) {
          for (var p = ar.memoizedState; p !== null; ) {
            var g = p.queue;
            g !== null && (g.pending = null), p = p.next;
          }
          Dt = !1;
        }
        if (wl = 0, hn = pe = ar = null, gs = !1, Ba = 0, Qp.current = null, l === null || l.return === null) {
          Qr = 1, Wf = i, xr = null;
          break;
        }
        e: {
          var S = n, R = l.return, P = l, F = i;
          if (i = ui, P.flags |= 32768, F !== null && typeof F == "object" && typeof F.then == "function") {
            var ae = F, we = P, Ee = we.tag;
            if (!(we.mode & 1) && (Ee === 0 || Ee === 11 || Ee === 15)) {
              var Se = we.alternate;
              Se ? (we.updateQueue = Se.updateQueue, we.memoizedState = Se.memoizedState, we.lanes = Se.lanes) : (we.updateQueue = null, we.memoizedState = null);
            }
            var Ze = Up(R);
            if (Ze !== null) {
              Ze.flags &= -257, Ip(Ze, R, P, S, i), Ze.mode & 1 && zm(S, ae, i), i = Ze, F = ae;
              var it = i.updateQueue;
              if (it === null) {
                var st = /* @__PURE__ */ new Set();
                st.add(F), i.updateQueue = st;
              } else
                it.add(F);
              break e;
            } else {
              if (!(i & 1)) {
                zm(S, ae, i), ev();
                break e;
              }
              F = Error(d(426));
            }
          } else if (ir && P.mode & 1) {
            var Pr = Up(R);
            if (Pr !== null) {
              !(Pr.flags & 65536) && (Pr.flags |= 256), Ip(Pr, R, P, S, i), bp(Rc(F, P));
              break e;
            }
          }
          S = F = Rc(F, P), Qr !== 4 && (Qr = 2), Ol === null ? Ol = [S] : Ol.push(S), S = R;
          do {
            switch (S.tag) {
              case 3:
                S.flags |= 65536, i &= -i, S.lanes |= i;
                var q = Am(S, F, i);
                Op(S, q);
                break e;
              case 1:
                P = F;
                var Y = S.type, ee = S.stateNode;
                if (!(S.flags & 128) && (typeof Y.getDerivedStateFromError == "function" || ee !== null && typeof ee.componentDidCatch == "function" && (ws === null || !ws.has(ee)))) {
                  S.flags |= 65536, i &= -i, S.lanes |= i;
                  var Re = Uf(S, P, i);
                  Op(S, Re);
                  break e;
                }
            }
            S = S.return;
          } while (S !== null);
        }
        tv(l);
      } catch (ct) {
        i = ct, xr === l && l !== null && (xr = l = l.return);
        continue;
      }
      break;
    } while (1);
  }
  function Sh() {
    var n = Vf.current;
    return Vf.current = lh, n === null ? lh : n;
  }
  function ev() {
    (Qr === 0 || Qr === 3 || Qr === 2) && (Qr = 4), mr === null || !(Qs & 268435455) && !(mh & 268435455) || Eo(mr, ui);
  }
  function wh(n, i) {
    var l = un;
    un |= 2;
    var p = Sh();
    (mr !== n || ui !== i) && (qs = null, Al(n, i));
    do
      try {
        p_();
        break;
      } catch (g) {
        Gm(n, g);
      }
    while (1);
    if (Rp(), un = l, Vf.current = p, xr !== null)
      throw Error(d(261));
    return mr = null, ui = 0, Qr;
  }
  function p_() {
    for (; xr !== null; )
      Qm(xr);
  }
  function v_() {
    for (; xr !== null && !Ja(); )
      Qm(xr);
  }
  function Qm(n) {
    var i = Km(n.alternate, n, Ya);
    n.memoizedProps = n.pendingProps, i === null ? tv(n) : xr = i, Qp.current = null;
  }
  function tv(n) {
    var i = n;
    do {
      var l = i.alternate;
      if (n = i.return, i.flags & 32768) {
        if (l = Wp(l, i), l !== null) {
          l.flags &= 32767, xr = l;
          return;
        }
        if (n !== null)
          n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null;
        else {
          Qr = 6, xr = null;
          return;
        }
      } else if (l = h_(l, i, Ya), l !== null) {
        xr = l;
        return;
      }
      if (i = i.sibling, i !== null) {
        xr = i;
        return;
      }
      xr = i = n;
    } while (i !== null);
    Qr === 0 && (Qr = 5);
  }
  function zl(n, i, l) {
    var p = nn, g = Ii.transition;
    try {
      Ii.transition = null, nn = 1, m_(n, i, l, p);
    } finally {
      Ii.transition = g, nn = p;
    }
    return null;
  }
  function m_(n, i, l, p) {
    do
      Hc();
    while (Fu !== null);
    if (un & 6)
      throw Error(d(327));
    l = n.finishedWork;
    var g = n.finishedLanes;
    if (l === null)
      return null;
    if (n.finishedWork = null, n.finishedLanes = 0, l === n.current)
      throw Error(d(177));
    n.callbackNode = null, n.callbackPriority = 0;
    var S = l.lanes | l.childLanes;
    if (lr(n, S), n === mr && (xr = mr = null, ui = 0), !(l.subtreeFlags & 2064) && !(l.flags & 2064) || ju || (ju = !0, nv(eo, function() {
      return Hc(), null;
    })), S = (l.flags & 15990) !== 0, l.subtreeFlags & 15990 || S) {
      S = Ii.transition, Ii.transition = null;
      var R = nn;
      nn = 1;
      var P = un;
      un |= 4, Qp.current = null, Hm(n, l), Ym(l, n), $i(ht), Zi = !!Fe, ht = Fe = null, n.current = l, Vm(l), No(), un = P, nn = R, Ii.transition = S;
    } else
      n.current = l;
    if (ju && (ju = !1, Fu = n, gh = g), S = n.pendingLanes, S === 0 && (ws = null), Ao(l.stateNode), Hi(n, cn()), i !== null)
      for (p = n.onRecoverableError, l = 0; l < i.length; l++)
        g = i[l], p(g.value, { componentStack: g.stack, digest: g.digest });
    if (yh)
      throw yh = !1, n = Ll, Ll = null, n;
    return gh & 1 && n.tag !== 0 && Hc(), S = n.pendingLanes, S & 1 ? n === _h ? Ic++ : (Ic = 0, _h = n) : Ic = 0, da(), null;
  }
  function Hc() {
    if (Fu !== null) {
      var n = ao(gh), i = Ii.transition, l = nn;
      try {
        if (Ii.transition = null, nn = 16 > n ? 16 : n, Fu === null)
          var p = !1;
        else {
          if (n = Fu, Fu = null, gh = 0, un & 6)
            throw Error(d(331));
          var g = un;
          for (un |= 4, tt = n.current; tt !== null; ) {
            var S = tt, R = S.child;
            if (tt.flags & 16) {
              var P = S.deletions;
              if (P !== null) {
                for (var F = 0; F < P.length; F++) {
                  var ae = P[F];
                  for (tt = ae; tt !== null; ) {
                    var we = tt;
                    switch (we.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Bf(8, we, S);
                    }
                    var Ee = we.child;
                    if (Ee !== null)
                      Ee.return = we, tt = Ee;
                    else
                      for (; tt !== null; ) {
                        we = tt;
                        var Se = we.sibling, Ze = we.return;
                        if ($p(we), we === ae) {
                          tt = null;
                          break;
                        }
                        if (Se !== null) {
                          Se.return = Ze, tt = Se;
                          break;
                        }
                        tt = Ze;
                      }
                  }
                }
                var it = S.alternate;
                if (it !== null) {
                  var st = it.child;
                  if (st !== null) {
                    it.child = null;
                    do {
                      var Pr = st.sibling;
                      st.sibling = null, st = Pr;
                    } while (st !== null);
                  }
                }
                tt = S;
              }
            }
            if (S.subtreeFlags & 2064 && R !== null)
              R.return = S, tt = R;
            else
              e:
                for (; tt !== null; ) {
                  if (S = tt, S.flags & 2048)
                    switch (S.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Bf(9, S, S.return);
                    }
                  var q = S.sibling;
                  if (q !== null) {
                    q.return = S.return, tt = q;
                    break e;
                  }
                  tt = S.return;
                }
          }
          var Y = n.current;
          for (tt = Y; tt !== null; ) {
            R = tt;
            var ee = R.child;
            if (R.subtreeFlags & 2064 && ee !== null)
              ee.return = R, tt = ee;
            else
              e:
                for (R = Y; tt !== null; ) {
                  if (P = tt, P.flags & 2048)
                    try {
                      switch (P.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Yf(9, P);
                      }
                    } catch (ct) {
                      br(P, P.return, ct);
                    }
                  if (P === R) {
                    tt = null;
                    break e;
                  }
                  var Re = P.sibling;
                  if (Re !== null) {
                    Re.return = P.return, tt = Re;
                    break e;
                  }
                  tt = P.return;
                }
          }
          if (un = g, da(), di && typeof di.onPostCommitFiberRoot == "function")
            try {
              di.onPostCommitFiberRoot(Po, n);
            } catch {
            }
          p = !0;
        }
        return p;
      } finally {
        nn = l, Ii.transition = i;
      }
    }
    return !1;
  }
  function qm(n, i, l) {
    i = Rc(l, i), i = Am(n, i, 1), n = Nu(n, i, 1), i = ji(), n !== null && (hi(n, 1, i), Hi(n, i));
  }
  function br(n, i, l) {
    if (n.tag === 3)
      qm(n, n, l);
    else
      for (; i !== null; ) {
        if (i.tag === 3) {
          qm(i, n, l);
          break;
        } else if (i.tag === 1) {
          var p = i.stateNode;
          if (typeof i.type.getDerivedStateFromError == "function" || typeof p.componentDidCatch == "function" && (ws === null || !ws.has(p))) {
            n = Rc(l, n), n = Uf(i, n, 1), i = Nu(i, n, 1), n = ji(), i !== null && (hi(i, 1, n), Hi(i, n));
            break;
          }
        }
        i = i.return;
      }
  }
  function y_(n, i, l) {
    var p = n.pingCache;
    p !== null && p.delete(i), i = ji(), n.pingedLanes |= n.suspendedLanes & l, mr === n && (ui & l) === l && (Qr === 4 || Qr === 3 && (ui & 130023424) === ui && 500 > cn() - qp ? Al(n, 0) : zc |= l), Hi(n, i);
  }
  function Eh(n, i) {
    i === 0 && (n.mode & 1 ? (i = ro, ro <<= 1, !(ro & 130023424) && (ro = 4194304)) : i = 1);
    var l = ji();
    n = Vs(n, i), n !== null && (hi(n, i, l), Hi(n, l));
  }
  function g_(n) {
    var i = n.memoizedState, l = 0;
    i !== null && (l = i.retryLane), Eh(n, l);
  }
  function __(n, i) {
    var l = 0;
    switch (n.tag) {
      case 13:
        var p = n.stateNode, g = n.memoizedState;
        g !== null && (l = g.retryLane);
        break;
      case 19:
        p = n.stateNode;
        break;
      default:
        throw Error(d(314));
    }
    p !== null && p.delete(i), Eh(n, l);
  }
  var Km;
  Km = function(n, i, l) {
    if (n !== null)
      if (n.memoizedProps !== i.pendingProps || Cr.current)
        Ir = !0;
      else {
        if (!(n.lanes & l) && !(i.flags & 128))
          return Ir = !1, $s(n, i, l);
        Ir = !!(n.flags & 131072);
      }
    else
      Ir = !1, ir && i.flags & 1048576 && Tp(i, wc, i.index);
    switch (i.lanes = 0, i.tag) {
      case 2:
        var p = i.type;
        zi(n, i), n = i.pendingProps;
        var g = po(i, At.current);
        Pe(i, l), g = zu(null, i, p, n, g, l);
        var S = Cl();
        return i.flags |= 1, typeof g == "object" && g !== null && typeof g.render == "function" && g.$$typeof === void 0 ? (i.tag = 1, i.memoizedState = null, i.updateQueue = null, cr(p) ? (S = !0, Ad(i)) : S = !1, i.memoizedState = g.state !== null && g.state !== void 0 ? g.state : null, kp(i), g.updater = Yd, i.stateNode = g, g._reactInternals = i, Vd(i, p, n, l), i = Um(null, i, p, !0, S, l)) : (i.tag = 0, ir && S && zd(i), Zr(null, i, g, l), i = i.child), i;
      case 16:
        p = i.elementType;
        e: {
          switch (zi(n, i), n = i.pendingProps, g = p._init, p = g(p._payload), i.type = p, g = i.tag = w_(p), n = Ha(p, n), g) {
            case 0:
              i = Dc(null, i, p, n, l);
              break e;
            case 1:
              i = jp(null, i, p, n, l);
              break e;
            case 11:
              i = Iu(null, i, p, n, l);
              break e;
            case 14:
              i = fh(null, i, p, Ha(p.type, n), l);
              break e;
          }
          throw Error(d(
            306,
            p,
            ""
          ));
        }
        return i;
      case 0:
        return p = i.type, g = i.pendingProps, g = i.elementType === p ? g : Ha(p, g), Dc(n, i, p, g, l);
      case 1:
        return p = i.type, g = i.pendingProps, g = i.elementType === p ? g : Ha(p, g), jp(n, i, p, g, l);
      case 3:
        e: {
          if (Im(i), n === null)
            throw Error(d(387));
          p = i.pendingProps, S = i.memoizedState, g = S.element, Wr(n, i), Pu(i, p, null, l);
          var R = i.memoizedState;
          if (p = R.element, S.isDehydrated)
            if (S = { element: p, isDehydrated: !1, cache: R.cache, pendingSuspenseBoundaries: R.pendingSuspenseBoundaries, transitions: R.transitions }, i.updateQueue.baseState = S, i.memoizedState = S, i.flags & 256) {
              g = Rc(Error(d(423)), i), i = dh(n, i, p, l, g);
              break e;
            } else if (p !== g) {
              g = Rc(Error(d(424)), i), i = dh(n, i, p, l, g);
              break e;
            } else
              for (va = Ua(i.stateNode.containerInfo.firstChild), Fa = i, ir = !0, yo = null, l = Nm(i, null, p, l), i.child = l; l; )
                l.flags = l.flags & -3 | 4096, l = l.sibling;
          else {
            if (pr(), p === g) {
              i = Si(n, i, l);
              break e;
            }
            Zr(n, i, p, l);
          }
          i = i.child;
        }
        return i;
      case 5:
        return Tt(i), n === null && Id(i), p = i.type, g = i.pendingProps, S = n !== null ? n.memoizedProps : null, R = g.children, Vt(p, g) ? R = null : S !== null && Vt(p, S) && (i.flags |= 32), Zt(n, i), Zr(n, i, R, l), i.child;
      case 6:
        return n === null && Id(i), null;
      case 13:
        return Hp(n, i, l);
      case 4:
        return Np(i, i.stateNode.containerInfo), p = i.pendingProps, n === null ? i.child = Tc(i, null, p, l) : Zr(n, i, p, l), i.child;
      case 11:
        return p = i.type, g = i.pendingProps, g = i.elementType === p ? g : Ha(p, g), Iu(n, i, p, g, l);
      case 7:
        return Zr(n, i, i.pendingProps, l), i.child;
      case 8:
        return Zr(n, i, i.pendingProps.children, l), i.child;
      case 12:
        return Zr(n, i, i.pendingProps.children, l), i.child;
      case 10:
        e: {
          if (p = i.type._context, g = i.pendingProps, S = i.memoizedProps, R = g.value, Ln(ys, p._currentValue), p._currentValue = R, S !== null)
            if (ua(S.value, R)) {
              if (S.children === g.children && !Cr.current) {
                i = Si(n, i, l);
                break e;
              }
            } else
              for (S = i.child, S !== null && (S.return = i); S !== null; ) {
                var P = S.dependencies;
                if (P !== null) {
                  R = S.child;
                  for (var F = P.firstContext; F !== null; ) {
                    if (F.context === p) {
                      if (S.tag === 1) {
                        F = Ws(-1, l & -l), F.tag = 2;
                        var ae = S.updateQueue;
                        if (ae !== null) {
                          ae = ae.shared;
                          var we = ae.pending;
                          we === null ? F.next = F : (F.next = we.next, we.next = F), ae.pending = F;
                        }
                      }
                      S.lanes |= l, F = S.alternate, F !== null && (F.lanes |= l), oi(
                        S.return,
                        l,
                        i
                      ), P.lanes |= l;
                      break;
                    }
                    F = F.next;
                  }
                } else if (S.tag === 10)
                  R = S.type === i.type ? null : S.child;
                else if (S.tag === 18) {
                  if (R = S.return, R === null)
                    throw Error(d(341));
                  R.lanes |= l, P = R.alternate, P !== null && (P.lanes |= l), oi(R, l, i), R = S.sibling;
                } else
                  R = S.child;
                if (R !== null)
                  R.return = S;
                else
                  for (R = S; R !== null; ) {
                    if (R === i) {
                      R = null;
                      break;
                    }
                    if (S = R.sibling, S !== null) {
                      S.return = R.return, R = S;
                      break;
                    }
                    R = R.return;
                  }
                S = R;
              }
          Zr(n, i, g.children, l), i = i.child;
        }
        return i;
      case 9:
        return g = i.type, p = i.pendingProps.children, Pe(i, l), g = Nr(g), p = p(g), i.flags |= 1, Zr(n, i, p, l), i.child;
      case 14:
        return p = i.type, g = Ha(p, i.pendingProps), g = Ha(p.type, g), fh(n, i, p, g, l);
      case 15:
        return ga(n, i, i.type, i.pendingProps, l);
      case 17:
        return p = i.type, g = i.pendingProps, g = i.elementType === p ? g : Ha(p, g), zi(n, i), i.tag = 1, cr(p) ? (n = !0, Ad(i)) : n = !1, Pe(i, l), Dm(i, p, g), Vd(i, p, g, l), Um(null, i, p, !0, n, l);
      case 19:
        return Vp(n, i, l);
      case 22:
        return Rl(n, i, l);
    }
    throw Error(d(156, i.tag));
  };
  function nv(n, i) {
    return Vn(n, i);
  }
  function S_(n, i, l, p) {
    this.tag = n, this.key = l, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = i, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = p, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function To(n, i, l, p) {
    return new S_(n, i, l, p);
  }
  function rv(n) {
    return n = n.prototype, !(!n || !n.isReactComponent);
  }
  function w_(n) {
    if (typeof n == "function")
      return rv(n) ? 1 : 0;
    if (n != null) {
      if (n = n.$$typeof, n === Mt)
        return 11;
      if (n === tn)
        return 14;
    }
    return 2;
  }
  function Bu(n, i) {
    var l = n.alternate;
    return l === null ? (l = To(n.tag, i, n.key, n.mode), l.elementType = n.elementType, l.type = n.type, l.stateNode = n.stateNode, l.alternate = n, n.alternate = l) : (l.pendingProps = i, l.type = n.type, l.flags = 0, l.subtreeFlags = 0, l.deletions = null), l.flags = n.flags & 14680064, l.childLanes = n.childLanes, l.lanes = n.lanes, l.child = n.child, l.memoizedProps = n.memoizedProps, l.memoizedState = n.memoizedState, l.updateQueue = n.updateQueue, i = n.dependencies, l.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext }, l.sibling = n.sibling, l.index = n.index, l.ref = n.ref, l;
  }
  function Th(n, i, l, p, g, S) {
    var R = 2;
    if (p = n, typeof n == "function")
      rv(n) && (R = 1);
    else if (typeof n == "string")
      R = 5;
    else
      e:
        switch (n) {
          case ze:
            return Ul(l.children, g, S, i);
          case kt:
            R = 8, g |= 8;
            break;
          case It:
            return n = To(12, l, i, g | 2), n.elementType = It, n.lanes = S, n;
          case ut:
            return n = To(13, l, i, g), n.elementType = ut, n.lanes = S, n;
          case lt:
            return n = To(19, l, i, g), n.elementType = lt, n.lanes = S, n;
          case Ne:
            return $f(l, g, S, i);
          default:
            if (typeof n == "object" && n !== null)
              switch (n.$$typeof) {
                case Nt:
                  R = 10;
                  break e;
                case Xe:
                  R = 9;
                  break e;
                case Mt:
                  R = 11;
                  break e;
                case tn:
                  R = 14;
                  break e;
                case vt:
                  R = 16, p = null;
                  break e;
              }
            throw Error(d(130, n == null ? n : typeof n, ""));
        }
    return i = To(R, l, i, g), i.elementType = n, i.type = p, i.lanes = S, i;
  }
  function Ul(n, i, l, p) {
    return n = To(7, n, p, i), n.lanes = l, n;
  }
  function $f(n, i, l, p) {
    return n = To(22, n, p, i), n.elementType = Ne, n.lanes = l, n.stateNode = { isHidden: !1 }, n;
  }
  function Gf(n, i, l) {
    return n = To(6, n, null, i), n.lanes = l, n;
  }
  function Il(n, i, l) {
    return i = To(4, n.children !== null ? n.children : [], n.key, i), i.lanes = l, i.stateNode = { containerInfo: n.containerInfo, pendingChildren: null, implementation: n.implementation }, i;
  }
  function E_(n, i, l, p, g) {
    this.tag = i, this.containerInfo = n, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Uo(0), this.expirationTimes = Uo(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Uo(0), this.identifierPrefix = p, this.onRecoverableError = g, this.mutableSourceEagerHydrationData = null;
  }
  function Ch(n, i, l, p, g, S, R, P, F) {
    return n = new E_(n, i, l, P, F), i === 1 ? (i = 1, S === !0 && (i |= 8)) : i = 0, S = To(3, null, null, i), n.current = S, S.stateNode = n, S.memoizedState = { element: p, isDehydrated: l, cache: null, transitions: null, pendingSuspenseBoundaries: null }, kp(S), n;
  }
  function Xm(n, i, l) {
    var p = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: Me, key: p == null ? null : "" + p, children: n, containerInfo: i, implementation: l };
  }
  function iv(n) {
    if (!n)
      return ms;
    n = n._reactInternals;
    e: {
      if (Ut(n) !== n || n.tag !== 1)
        throw Error(d(170));
      var i = n;
      do {
        switch (i.tag) {
          case 3:
            i = i.stateNode.context;
            break e;
          case 1:
            if (cr(i.type)) {
              i = i.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        i = i.return;
      } while (i !== null);
      throw Error(d(171));
    }
    if (n.tag === 1) {
      var l = n.type;
      if (cr(l))
        return Rf(n, l, i);
    }
    return i;
  }
  function Jm(n, i, l, p, g, S, R, P, F) {
    return n = Ch(l, p, !0, n, g, S, R, P, F), n.context = iv(null), l = n.current, p = ji(), g = jr(l), S = Ws(p, g), S.callback = i ?? null, Nu(l, S, g), n.current.lanes = g, hi(n, g, p), Hi(n, p), n;
  }
  function Qf(n, i, l, p) {
    var g = i.current, S = ji(), R = jr(g);
    return l = iv(l), i.context === null ? i.context = l : i.pendingContext = l, i = Ws(S, R), i.payload = { element: n }, p = p === void 0 ? null : p, p !== null && (i.callback = p), n = Nu(g, i, R), n !== null && (Fi(n, g, R, S), Bd(n, g, R)), R;
  }
  function xh(n) {
    if (n = n.current, !n.child)
      return null;
    switch (n.child.tag) {
      case 5:
        return n.child.stateNode;
      default:
        return n.child.stateNode;
    }
  }
  function ey(n, i) {
    if (n = n.memoizedState, n !== null && n.dehydrated !== null) {
      var l = n.retryLane;
      n.retryLane = l !== 0 && l < i ? l : i;
    }
  }
  function av(n, i) {
    ey(n, i), (n = n.alternate) && ey(n, i);
  }
  function ty() {
    return null;
  }
  var ov = typeof reportError == "function" ? reportError : function(n) {
    console.error(n);
  };
  function bh(n) {
    this._internalRoot = n;
  }
  Ks.prototype.render = bh.prototype.render = function(n) {
    var i = this._internalRoot;
    if (i === null)
      throw Error(d(409));
    Qf(n, i, null, null);
  }, Ks.prototype.unmount = bh.prototype.unmount = function() {
    var n = this._internalRoot;
    if (n !== null) {
      this._internalRoot = null;
      var i = n.containerInfo;
      Hu(function() {
        Qf(null, n, null, null);
      }), i[On] = null;
    }
  };
  function Ks(n) {
    this._internalRoot = n;
  }
  Ks.prototype.unstable_scheduleHydration = function(n) {
    if (n) {
      var i = is();
      n = { blockedOn: null, target: n, priority: i };
      for (var l = 0; l < Qt.length && i !== 0 && i < Qt[l].priority; l++)
        ;
      Qt.splice(l, 0, n), l === 0 && vu(n);
    }
  };
  function sv(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11);
  }
  function Mh(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 && (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "));
  }
  function ny() {
  }
  function T_(n, i, l, p, g) {
    if (g) {
      if (typeof p == "function") {
        var S = p;
        p = function() {
          var ae = xh(R);
          S.call(ae);
        };
      }
      var R = Jm(i, p, n, 0, null, !1, !1, "", ny);
      return n._reactRootContainer = R, n[On] = R.current, Fs(n.nodeType === 8 ? n.parentNode : n), Hu(), R;
    }
    for (; g = n.lastChild; )
      n.removeChild(g);
    if (typeof p == "function") {
      var P = p;
      p = function() {
        var ae = xh(F);
        P.call(ae);
      };
    }
    var F = Ch(n, 0, !1, null, null, !1, !1, "", ny);
    return n._reactRootContainer = F, n[On] = F.current, Fs(n.nodeType === 8 ? n.parentNode : n), Hu(function() {
      Qf(i, F, l, p);
    }), F;
  }
  function Rh(n, i, l, p, g) {
    var S = l._reactRootContainer;
    if (S) {
      var R = S;
      if (typeof g == "function") {
        var P = g;
        g = function() {
          var F = xh(R);
          P.call(F);
        };
      }
      Qf(i, R, n, g);
    } else
      R = T_(l, i, n, g, p);
    return xh(R);
  }
  Io = function(n) {
    switch (n.tag) {
      case 3:
        var i = n.stateNode;
        if (i.current.memoizedState.isDehydrated) {
          var l = xt(i.pendingLanes);
          l !== 0 && (ni(i, l | 1), Hi(i, cn()), !(un & 6) && (Uc = cn() + 500, da()));
        }
        break;
      case 13:
        Hu(function() {
          var p = Vs(n, 1);
          if (p !== null) {
            var g = ji();
            Fi(p, n, 1, g);
          }
        }), av(n, 1);
    }
  }, oo = function(n) {
    if (n.tag === 13) {
      var i = Vs(n, 134217728);
      if (i !== null) {
        var l = ji();
        Fi(i, n, 134217728, l);
      }
      av(n, 134217728);
    }
  }, rn = function(n) {
    if (n.tag === 13) {
      var i = jr(n), l = Vs(n, i);
      if (l !== null) {
        var p = ji();
        Fi(l, n, i, p);
      }
      av(n, i);
    }
  }, is = function() {
    return nn;
  }, jo = function(n, i) {
    var l = nn;
    try {
      return nn = n, i();
    } finally {
      nn = l;
    }
  }, ti = function(n, i, l) {
    switch (i) {
      case "input":
        if (Bn(n, l), i = l.name, l.type === "radio" && i != null) {
          for (l = n; l.parentNode; )
            l = l.parentNode;
          for (l = l.querySelectorAll("input[name=" + JSON.stringify("" + i) + '][type="radio"]'), i = 0; i < l.length; i++) {
            var p = l[i];
            if (p !== n && p.form === n.form) {
              var g = pt(p);
              if (!g)
                throw Error(d(90));
              Ue(p), Bn(p, g);
            }
          }
        }
        break;
      case "textarea":
        Yi(n, l);
        break;
      case "select":
        i = l.value, i != null && zr(n, !!l.multiple, i, !1);
    }
  }, Ls = Fc, hu = Hu;
  var C_ = { usingClientEntryPoint: !1, Events: [Hs, Bs, pt, ia, ns, Fc] }, Bc = { findFiberByHostInstance: ca, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, x_ = { bundleType: Bc.bundleType, version: Bc.version, rendererPackageName: Bc.rendererPackageName, rendererConfig: Bc.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ye.ReactCurrentDispatcher, findHostInstanceByFiber: function(n) {
    return n = wr(n), n === null ? null : n.stateNode;
  }, findFiberByHostInstance: Bc.findFiberByHostInstance || ty, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Dh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Dh.isDisabled && Dh.supportsFiber)
      try {
        Po = Dh.inject(x_), di = Dh;
      } catch {
      }
  }
  return Do.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = C_, Do.createPortal = function(n, i) {
    var l = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!sv(i))
      throw Error(d(200));
    return Xm(n, i, null, l);
  }, Do.createRoot = function(n, i) {
    if (!sv(n))
      throw Error(d(299));
    var l = !1, p = "", g = ov;
    return i != null && (i.unstable_strictMode === !0 && (l = !0), i.identifierPrefix !== void 0 && (p = i.identifierPrefix), i.onRecoverableError !== void 0 && (g = i.onRecoverableError)), i = Ch(n, 1, !1, null, null, l, !1, p, g), n[On] = i.current, Fs(n.nodeType === 8 ? n.parentNode : n), new bh(i);
  }, Do.findDOMNode = function(n) {
    if (n == null)
      return null;
    if (n.nodeType === 1)
      return n;
    var i = n._reactInternals;
    if (i === void 0)
      throw typeof n.render == "function" ? Error(d(188)) : (n = Object.keys(n).join(","), Error(d(268, n)));
    return n = wr(i), n = n === null ? null : n.stateNode, n;
  }, Do.flushSync = function(n) {
    return Hu(n);
  }, Do.hydrate = function(n, i, l) {
    if (!Mh(i))
      throw Error(d(200));
    return Rh(null, n, i, !0, l);
  }, Do.hydrateRoot = function(n, i, l) {
    if (!sv(n))
      throw Error(d(405));
    var p = l != null && l.hydratedSources || null, g = !1, S = "", R = ov;
    if (l != null && (l.unstable_strictMode === !0 && (g = !0), l.identifierPrefix !== void 0 && (S = l.identifierPrefix), l.onRecoverableError !== void 0 && (R = l.onRecoverableError)), i = Jm(i, null, n, 1, l ?? null, g, !1, S, R), n[On] = i.current, Fs(n), p)
      for (n = 0; n < p.length; n++)
        l = p[n], g = l._getVersion, g = g(l._source), i.mutableSourceEagerHydrationData == null ? i.mutableSourceEagerHydrationData = [l, g] : i.mutableSourceEagerHydrationData.push(
          l,
          g
        );
    return new Ks(i);
  }, Do.render = function(n, i, l) {
    if (!Mh(i))
      throw Error(d(200));
    return Rh(null, n, i, !1, l);
  }, Do.unmountComponentAtNode = function(n) {
    if (!Mh(n))
      throw Error(d(40));
    return n._reactRootContainer ? (Hu(function() {
      Rh(null, null, n, !1, function() {
        n._reactRootContainer = null, n[On] = null;
      });
    }), !0) : !1;
  }, Do.unstable_batchedUpdates = Fc, Do.unstable_renderSubtreeIntoContainer = function(n, i, l, p) {
    if (!Mh(l))
      throw Error(d(200));
    if (n == null || n._reactInternals === void 0)
      throw Error(d(38));
    return Rh(n, i, l, !1, p);
  }, Do.version = "18.2.0-next-9e3b772b8-20220608", Do;
}
var ko = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vx;
function eN() {
  return vx || (vx = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var o = ic(), c = Bx(), d = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, m = !1;
    function w(e) {
      m = e;
    }
    function M(e) {
      if (!m) {
        for (var t = arguments.length, a = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)
          a[s - 1] = arguments[s];
        W("warn", e, a);
      }
    }
    function C(e) {
      if (!m) {
        for (var t = arguments.length, a = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)
          a[s - 1] = arguments[s];
        W("error", e, a);
      }
    }
    function W(e, t, a) {
      {
        var s = d.ReactDebugCurrentFrame, f = s.getStackAddendum();
        f !== "" && (t += "%s", a = a.concat([f]));
        var v = a.map(function(_) {
          return String(_);
        });
        v.unshift("Warning: " + t), Function.prototype.apply.call(console[e], console, v);
      }
    }
    var z = 0, j = 1, Z = 2, H = 3, $ = 4, J = 5, oe = 6, ce = 7, ue = 8, Ke = 9, He = 10, ve = 11, ye = 12, G = 13, Me = 14, ze = 15, kt = 16, It = 17, Nt = 18, Xe = 19, Mt = 21, ut = 22, lt = 23, tn = 24, vt = 25, Ne = !0, le = !1, Je = !1, N = !1, se = !1, xe = !0, et = !1, je = !1, qe = !0, Oe = !0, Rt = !0, _t = /* @__PURE__ */ new Set(), on = {}, Sr = {};
    function ur(e, t) {
      Ue(e, t), Ue(e + "Capture", t);
    }
    function Ue(e, t) {
      on[e] && C("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", e), on[e] = t;
      {
        var a = e.toLowerCase();
        Sr[a] = e, e === "onDoubleClick" && (Sr.ondblclick = e);
      }
      for (var s = 0; s < t.length; s++)
        _t.add(t[s]);
    }
    var yn = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Ie = Object.prototype.hasOwnProperty;
    function zn(e) {
      {
        var t = typeof Symbol == "function" && Symbol.toStringTag, a = t && e[Symbol.toStringTag] || e.constructor.name || "Object";
        return a;
      }
    }
    function Xn(e) {
      try {
        return Bn(e), !1;
      } catch {
        return !0;
      }
    }
    function Bn(e) {
      return "" + e;
    }
    function Hr(e, t) {
      if (Xn(e))
        return C("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", t, zn(e)), Bn(e);
    }
    function ki(e) {
      if (Xn(e))
        return C("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", zn(e)), Bn(e);
    }
    function Dr(e, t) {
      if (Xn(e))
        return C("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", t, zn(e)), Bn(e);
    }
    function zr(e, t) {
      if (Xn(e))
        return C("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", t, zn(e)), Bn(e);
    }
    function fi(e) {
      if (Xn(e))
        return C("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", zn(e)), Bn(e);
    }
    function Br(e) {
      if (Xn(e))
        return C("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", zn(e)), Bn(e);
    }
    var Yi = 0, Yr = 1, Xr = 2, er = 3, Jr = 4, Qa = 5, Oi = 6, De = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ft = De + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Yt = new RegExp("^[" + De + "][" + ft + "]*$"), dn = {}, gn = {};
    function dr(e) {
      return Ie.call(gn, e) ? !0 : Ie.call(dn, e) ? !1 : Yt.test(e) ? (gn[e] = !0, !0) : (dn[e] = !0, C("Invalid attribute name: `%s`", e), !1);
    }
    function Un(e, t, a) {
      return t !== null ? t.type === Yi : a ? !1 : e.length > 2 && (e[0] === "o" || e[0] === "O") && (e[1] === "n" || e[1] === "N");
    }
    function ei(e, t, a, s) {
      if (a !== null && a.type === Yi)
        return !1;
      switch (typeof t) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (s)
            return !1;
          if (a !== null)
            return !a.acceptsBooleans;
          var f = e.toLowerCase().slice(0, 5);
          return f !== "data-" && f !== "aria-";
        }
        default:
          return !1;
      }
    }
    function bn(e, t, a, s) {
      if (t === null || typeof t > "u" || ei(e, t, a, s))
        return !0;
      if (s)
        return !1;
      if (a !== null)
        switch (a.type) {
          case er:
            return !t;
          case Jr:
            return t === !1;
          case Qa:
            return isNaN(t);
          case Oi:
            return isNaN(t) || t < 1;
        }
      return !1;
    }
    function ti(e) {
      return Sn.hasOwnProperty(e) ? Sn[e] : null;
    }
    function _n(e, t, a, s, f, v, _) {
      this.acceptsBooleans = t === Xr || t === er || t === Jr, this.attributeName = s, this.attributeNamespace = f, this.mustUseProperty = a, this.propertyName = e, this.type = t, this.sanitizeURL = v, this.removeEmptyString = _;
    }
    var Sn = {}, Ma = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Ma.forEach(function(e) {
      Sn[e] = new _n(
        e,
        Yi,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
      var t = e[0], a = e[1];
      Sn[t] = new _n(
        t,
        Yr,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
      Sn[e] = new _n(
        e,
        Xr,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
      Sn[e] = new _n(
        e,
        Xr,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(e) {
      Sn[e] = new _n(
        e,
        er,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      Sn[e] = new _n(
        e,
        er,
        !0,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      Sn[e] = new _n(
        e,
        Jr,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      Sn[e] = new _n(
        e,
        Oi,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(e) {
      Sn[e] = new _n(
        e,
        Qa,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ia = /[\-\:]([a-z])/g, ns = function(e) {
      return e[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var t = e.replace(ia, ns);
      Sn[t] = new _n(
        t,
        Yr,
        !1,
        // mustUseProperty
        e,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var t = e.replace(ia, ns);
      Sn[t] = new _n(
        t,
        Yr,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var t = e.replace(ia, ns);
      Sn[t] = new _n(
        t,
        Yr,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(e) {
      Sn[e] = new _n(
        e,
        Yr,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Ls = "xlinkHref";
    Sn[Ls] = new _n(
      "xlinkHref",
      Yr,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(e) {
      Sn[e] = new _n(
        e,
        Yr,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var hu = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Lo = !1;
    function qa(e) {
      !Lo && hu.test(e) && (Lo = !0, C("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(e)));
    }
    function Vi(e, t, a, s) {
      if (s.mustUseProperty) {
        var f = s.propertyName;
        return e[f];
      } else {
        Hr(a, t), s.sanitizeURL && qa("" + a);
        var v = s.attributeName, _ = null;
        if (s.type === Jr) {
          if (e.hasAttribute(v)) {
            var E = e.getAttribute(v);
            return E === "" ? !0 : bn(t, a, s, !1) ? E : E === "" + a ? a : E;
          }
        } else if (e.hasAttribute(v)) {
          if (bn(t, a, s, !1))
            return e.getAttribute(v);
          if (s.type === er)
            return a;
          _ = e.getAttribute(v);
        }
        return bn(t, a, s, !1) ? _ === null ? a : _ : _ === "" + a ? a : _;
      }
    }
    function Ka(e, t, a, s) {
      {
        if (!dr(t))
          return;
        if (!e.hasAttribute(t))
          return a === void 0 ? void 0 : null;
        var f = e.getAttribute(t);
        return Hr(a, t), f === "" + a ? a : f;
      }
    }
    function Wi(e, t, a, s) {
      var f = ti(t);
      if (!Un(t, f, s)) {
        if (bn(t, a, f, s) && (a = null), s || f === null) {
          if (dr(t)) {
            var v = t;
            a === null ? e.removeAttribute(v) : (Hr(a, t), e.setAttribute(v, "" + a));
          }
          return;
        }
        var _ = f.mustUseProperty;
        if (_) {
          var E = f.propertyName;
          if (a === null) {
            var x = f.type;
            e[E] = x === er ? !1 : "";
          } else
            e[E] = a;
          return;
        }
        var k = f.attributeName, O = f.attributeNamespace;
        if (a === null)
          e.removeAttribute(k);
        else {
          var V = f.type, B;
          V === er || V === Jr && a === !0 ? B = "" : (Hr(a, k), B = "" + a, f.sanitizeURL && qa(B.toString())), O ? e.setAttributeNS(O, k, B) : e.setAttribute(k, B);
        }
      }
    }
    var Xa = Symbol.for("react.element"), tr = Symbol.for("react.portal"), We = Symbol.for("react.fragment"), Ra = Symbol.for("react.strict_mode"), U = Symbol.for("react.profiler"), _e = Symbol.for("react.provider"), ke = Symbol.for("react.context"), Be = Symbol.for("react.forward_ref"), Ut = Symbol.for("react.suspense"), $t = Symbol.for("react.suspense_list"), jt = Symbol.for("react.memo"), mt = Symbol.for("react.lazy"), wr = Symbol.for("react.scope"), Yn = Symbol.for("react.debug_trace_mode"), Vn = Symbol.for("react.offscreen"), Ur = Symbol.for("react.legacy_hidden"), Ja = Symbol.for("react.cache"), No = Symbol.for("react.tracing_marker"), cn = Symbol.iterator, yf = "@@iterator";
    function Da(e) {
      if (e === null || typeof e != "object")
        return null;
      var t = cn && e[cn] || e[yf];
      return typeof t == "function" ? t : null;
    }
    var Gt = Object.assign, eo = 0, to, no, Po, di, Ao, Pt, In;
    function rs() {
    }
    rs.__reactDisabledLog = !0;
    function zo() {
      {
        if (eo === 0) {
          to = console.log, no = console.info, Po = console.warn, di = console.error, Ao = console.group, Pt = console.groupCollapsed, In = console.groupEnd;
          var e = {
            configurable: !0,
            enumerable: !0,
            value: rs,
            writable: !0
          };
          Object.defineProperties(console, {
            info: e,
            log: e,
            warn: e,
            error: e,
            group: e,
            groupCollapsed: e,
            groupEnd: e
          });
        }
        eo++;
      }
    }
    function ka() {
      {
        if (eo--, eo === 0) {
          var e = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Gt({}, e, {
              value: to
            }),
            info: Gt({}, e, {
              value: no
            }),
            warn: Gt({}, e, {
              value: Po
            }),
            error: Gt({}, e, {
              value: di
            }),
            group: Gt({}, e, {
              value: Ao
            }),
            groupCollapsed: Gt({}, e, {
              value: Pt
            }),
            groupEnd: Gt({}, e, {
              value: In
            })
          });
        }
        eo < 0 && C("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ro = d.ReactCurrentDispatcher, xt;
    function sn(e, t, a) {
      {
        if (xt === void 0)
          try {
            throw Error();
          } catch (f) {
            var s = f.stack.trim().match(/\n( *(at )?)/);
            xt = s && s[1] || "";
          }
        return `
` + xt + e;
      }
    }
    var io = !1, Oa;
    {
      var kr = typeof WeakMap == "function" ? WeakMap : Map;
      Oa = new kr();
    }
    function pu(e, t) {
      if (!e || io)
        return "";
      {
        var a = Oa.get(e);
        if (a !== void 0)
          return a;
      }
      var s;
      io = !0;
      var f = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var v;
      v = ro.current, ro.current = null, zo();
      try {
        if (t) {
          var _ = function() {
            throw Error();
          };
          if (Object.defineProperty(_.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(_, []);
            } catch (re) {
              s = re;
            }
            Reflect.construct(e, [], _);
          } else {
            try {
              _.call();
            } catch (re) {
              s = re;
            }
            e.call(_.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (re) {
            s = re;
          }
          e();
        }
      } catch (re) {
        if (re && s && typeof re.stack == "string") {
          for (var E = re.stack.split(`
`), x = s.stack.split(`
`), k = E.length - 1, O = x.length - 1; k >= 1 && O >= 0 && E[k] !== x[O]; )
            O--;
          for (; k >= 1 && O >= 0; k--, O--)
            if (E[k] !== x[O]) {
              if (k !== 1 || O !== 1)
                do
                  if (k--, O--, O < 0 || E[k] !== x[O]) {
                    var V = `
` + E[k].replace(" at new ", " at ");
                    return e.displayName && V.includes("<anonymous>") && (V = V.replace("<anonymous>", e.displayName)), typeof e == "function" && Oa.set(e, V), V;
                  }
                while (k >= 1 && O >= 0);
              break;
            }
        }
      } finally {
        io = !1, ro.current = v, ka(), Error.prepareStackTrace = f;
      }
      var B = e ? e.displayName || e.name : "", ne = B ? sn(B) : "";
      return typeof e == "function" && Oa.set(e, ne), ne;
    }
    function Uo(e, t, a) {
      return pu(e, !0);
    }
    function hi(e, t, a) {
      return pu(e, !1);
    }
    function lr(e) {
      var t = e.prototype;
      return !!(t && t.isReactComponent);
    }
    function ni(e, t, a) {
      if (e == null)
        return "";
      if (typeof e == "function")
        return pu(e, lr(e));
      if (typeof e == "string")
        return sn(e);
      switch (e) {
        case Ut:
          return sn("Suspense");
        case $t:
          return sn("SuspenseList");
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case Be:
            return hi(e.render);
          case jt:
            return ni(e.type, t, a);
          case mt: {
            var s = e, f = s._payload, v = s._init;
            try {
              return ni(v(f), t, a);
            } catch {
            }
          }
        }
      return "";
    }
    function nn(e) {
      switch (e._debugOwner && e._debugOwner.type, e._debugSource, e.tag) {
        case J:
          return sn(e.type);
        case kt:
          return sn("Lazy");
        case G:
          return sn("Suspense");
        case Xe:
          return sn("SuspenseList");
        case z:
        case Z:
        case ze:
          return hi(e.type);
        case ve:
          return hi(e.type.render);
        case j:
          return Uo(e.type);
        default:
          return "";
      }
    }
    function ao(e) {
      try {
        var t = "", a = e;
        do
          t += nn(a), a = a.return;
        while (a);
        return t;
      } catch (s) {
        return `
Error generating stack: ` + s.message + `
` + s.stack;
      }
    }
    function Io(e, t, a) {
      var s = e.displayName;
      if (s)
        return s;
      var f = t.displayName || t.name || "";
      return f !== "" ? a + "(" + f + ")" : a;
    }
    function oo(e) {
      return e.displayName || "Context";
    }
    function rn(e) {
      if (e == null)
        return null;
      if (typeof e.tag == "number" && C("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof e == "function")
        return e.displayName || e.name || null;
      if (typeof e == "string")
        return e;
      switch (e) {
        case We:
          return "Fragment";
        case tr:
          return "Portal";
        case U:
          return "Profiler";
        case Ra:
          return "StrictMode";
        case Ut:
          return "Suspense";
        case $t:
          return "SuspenseList";
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case ke:
            var t = e;
            return oo(t) + ".Consumer";
          case _e:
            var a = e;
            return oo(a._context) + ".Provider";
          case Be:
            return Io(e, e.render, "ForwardRef");
          case jt:
            var s = e.displayName || null;
            return s !== null ? s : rn(e.type) || "Memo";
          case mt: {
            var f = e, v = f._payload, _ = f._init;
            try {
              return rn(_(v));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function is(e, t, a) {
      var s = t.displayName || t.name || "";
      return e.displayName || (s !== "" ? a + "(" + s + ")" : a);
    }
    function jo(e) {
      return e.displayName || "Context";
    }
    function Ot(e) {
      var t = e.tag, a = e.type;
      switch (t) {
        case tn:
          return "Cache";
        case Ke:
          var s = a;
          return jo(s) + ".Consumer";
        case He:
          var f = a;
          return jo(f._context) + ".Provider";
        case Nt:
          return "DehydratedFragment";
        case ve:
          return is(a, a.render, "ForwardRef");
        case ce:
          return "Fragment";
        case J:
          return a;
        case $:
          return "Portal";
        case H:
          return "Root";
        case oe:
          return "Text";
        case kt:
          return rn(a);
        case ue:
          return a === Ra ? "StrictMode" : "Mode";
        case ut:
          return "Offscreen";
        case ye:
          return "Profiler";
        case Mt:
          return "Scope";
        case G:
          return "Suspense";
        case Xe:
          return "SuspenseList";
        case vt:
          return "TracingMarker";
        case j:
        case z:
        case It:
        case Z:
        case Me:
        case ze:
          if (typeof a == "function")
            return a.displayName || a.name || null;
          if (typeof a == "string")
            return a;
          break;
      }
      return null;
    }
    var Fo = d.ReactDebugCurrentFrame, Wn = null, pi = !1;
    function Vr() {
      {
        if (Wn === null)
          return null;
        var e = Wn._debugOwner;
        if (e !== null && typeof e < "u")
          return Ot(e);
      }
      return null;
    }
    function as() {
      return Wn === null ? "" : ao(Wn);
    }
    function nt() {
      Fo.getCurrentStack = null, Wn = null, pi = !1;
    }
    function Qt(e) {
      Fo.getCurrentStack = e === null ? null : as, Wn = e, pi = !1;
    }
    function Mn() {
      return Wn;
    }
    function vi(e) {
      pi = e;
    }
    function Er(e) {
      return "" + e;
    }
    function aa(e) {
      switch (typeof e) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return e;
        case "object":
          return Br(e), e;
        default:
          return "";
      }
    }
    var vu = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function mi(e, t) {
      vu[t.type] || t.onChange || t.onInput || t.readOnly || t.disabled || t.value == null || C("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), t.onChange || t.readOnly || t.disabled || t.checked == null || C("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function so(e) {
      var t = e.type, a = e.nodeName;
      return a && a.toLowerCase() === "input" && (t === "checkbox" || t === "radio");
    }
    function os(e) {
      return e._valueTracker;
    }
    function Dn(e) {
      e._valueTracker = null;
    }
    function Li(e) {
      var t = "";
      return e && (so(e) ? t = e.checked ? "true" : "false" : t = e.value), t;
    }
    function Ho(e) {
      var t = so(e) ? "checked" : "value", a = Object.getOwnPropertyDescriptor(e.constructor.prototype, t);
      Br(e[t]);
      var s = "" + e[t];
      if (!(e.hasOwnProperty(t) || typeof a > "u" || typeof a.get != "function" || typeof a.set != "function")) {
        var f = a.get, v = a.set;
        Object.defineProperty(e, t, {
          configurable: !0,
          get: function() {
            return f.call(this);
          },
          set: function(E) {
            Br(E), s = "" + E, v.call(this, E);
          }
        }), Object.defineProperty(e, t, {
          enumerable: a.enumerable
        });
        var _ = {
          getValue: function() {
            return s;
          },
          setValue: function(E) {
            Br(E), s = "" + E;
          },
          stopTracking: function() {
            Dn(e), delete e[t];
          }
        };
        return _;
      }
    }
    function Zi(e) {
      os(e) || (e._valueTracker = Ho(e));
    }
    function mu(e) {
      if (!e)
        return !1;
      var t = os(e);
      if (!t)
        return !0;
      var a = t.getValue(), s = Li(e);
      return s !== a ? (t.setValue(s), !0) : !1;
    }
    function Bo(e) {
      if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u")
        return null;
      try {
        return e.activeElement || e.body;
      } catch {
        return e.body;
      }
    }
    var uo = !1, Ns = !1, Ps = !1, Kt = !1;
    function La(e) {
      var t = e.type === "checkbox" || e.type === "radio";
      return t ? e.checked != null : e.value != null;
    }
    function b(e, t) {
      var a = e, s = t.checked, f = Gt({}, t, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: s ?? a._wrapperState.initialChecked
      });
      return f;
    }
    function A(e, t) {
      mi("input", t), t.checked !== void 0 && t.defaultChecked !== void 0 && !Ns && (C("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Vr() || "A component", t.type), Ns = !0), t.value !== void 0 && t.defaultValue !== void 0 && !uo && (C("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Vr() || "A component", t.type), uo = !0);
      var a = e, s = t.defaultValue == null ? "" : t.defaultValue;
      a._wrapperState = {
        initialChecked: t.checked != null ? t.checked : t.defaultChecked,
        initialValue: aa(t.value != null ? t.value : s),
        controlled: La(t)
      };
    }
    function te(e, t) {
      var a = e, s = t.checked;
      s != null && Wi(a, "checked", s, !1);
    }
    function fe(e, t) {
      var a = e;
      {
        var s = La(t);
        !a._wrapperState.controlled && s && !Kt && (C("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Kt = !0), a._wrapperState.controlled && !s && !Ps && (C("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Ps = !0);
      }
      te(e, t);
      var f = aa(t.value), v = t.type;
      if (f != null)
        v === "number" ? (f === 0 && a.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        a.value != f) && (a.value = Er(f)) : a.value !== Er(f) && (a.value = Er(f));
      else if (v === "submit" || v === "reset") {
        a.removeAttribute("value");
        return;
      }
      t.hasOwnProperty("value") ? gt(a, t.type, f) : t.hasOwnProperty("defaultValue") && gt(a, t.type, aa(t.defaultValue)), t.checked == null && t.defaultChecked != null && (a.defaultChecked = !!t.defaultChecked);
    }
    function Ce(e, t, a) {
      var s = e;
      if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
        var f = t.type, v = f === "submit" || f === "reset";
        if (v && (t.value === void 0 || t.value === null))
          return;
        var _ = Er(s._wrapperState.initialValue);
        a || _ !== s.value && (s.value = _), s.defaultValue = _;
      }
      var E = s.name;
      E !== "" && (s.name = ""), s.defaultChecked = !s.defaultChecked, s.defaultChecked = !!s._wrapperState.initialChecked, E !== "" && (s.name = E);
    }
    function St(e, t) {
      var a = e;
      fe(a, t), Le(a, t);
    }
    function Le(e, t) {
      var a = t.name;
      if (t.type === "radio" && a != null) {
        for (var s = e; s.parentNode; )
          s = s.parentNode;
        Hr(a, "name");
        for (var f = s.querySelectorAll("input[name=" + JSON.stringify("" + a) + '][type="radio"]'), v = 0; v < f.length; v++) {
          var _ = f[v];
          if (!(_ === e || _.form !== e.form)) {
            var E = _y(_);
            if (!E)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            mu(_), fe(_, E);
          }
        }
      }
    }
    function gt(e, t, a) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (t !== "number" || Bo(e.ownerDocument) !== e) && (a == null ? e.defaultValue = Er(e._wrapperState.initialValue) : e.defaultValue !== Er(a) && (e.defaultValue = Er(a)));
    }
    var qt = !1, an = !1, jn = !1;
    function Xt(e, t) {
      t.value == null && (typeof t.children == "object" && t.children !== null ? o.Children.forEach(t.children, function(a) {
        a != null && (typeof a == "string" || typeof a == "number" || an || (an = !0, C("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : t.dangerouslySetInnerHTML != null && (jn || (jn = !0, C("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), t.selected != null && !qt && (C("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), qt = !0);
    }
    function Fn(e, t) {
      t.value != null && e.setAttribute("value", Er(aa(t.value)));
    }
    var Hn = Array.isArray;
    function Ht(e) {
      return Hn(e);
    }
    var lo;
    lo = !1;
    function As() {
      var e = Vr();
      return e ? `

Check the render method of \`` + e + "`." : "";
    }
    var zs = ["value", "defaultValue"];
    function gf(e) {
      {
        mi("select", e);
        for (var t = 0; t < zs.length; t++) {
          var a = zs[t];
          if (e[a] != null) {
            var s = Ht(e[a]);
            e.multiple && !s ? C("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", a, As()) : !e.multiple && s && C("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", a, As());
          }
        }
      }
    }
    function oa(e, t, a, s) {
      var f = e.options;
      if (t) {
        for (var v = a, _ = {}, E = 0; E < v.length; E++)
          _["$" + v[E]] = !0;
        for (var x = 0; x < f.length; x++) {
          var k = _.hasOwnProperty("$" + f[x].value);
          f[x].selected !== k && (f[x].selected = k), k && s && (f[x].defaultSelected = !0);
        }
      } else {
        for (var O = Er(aa(a)), V = null, B = 0; B < f.length; B++) {
          if (f[B].value === O) {
            f[B].selected = !0, s && (f[B].defaultSelected = !0);
            return;
          }
          V === null && !f[B].disabled && (V = f[B]);
        }
        V !== null && (V.selected = !0);
      }
    }
    function yu(e, t) {
      return Gt({}, t, {
        value: void 0
      });
    }
    function al(e, t) {
      var a = e;
      gf(t), a._wrapperState = {
        wasMultiple: !!t.multiple
      }, t.value !== void 0 && t.defaultValue !== void 0 && !lo && (C("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), lo = !0);
    }
    function _f(e, t) {
      var a = e;
      a.multiple = !!t.multiple;
      var s = t.value;
      s != null ? oa(a, !!t.multiple, s, !1) : t.defaultValue != null && oa(a, !!t.multiple, t.defaultValue, !0);
    }
    function Sf(e, t) {
      var a = e, s = a._wrapperState.wasMultiple;
      a._wrapperState.wasMultiple = !!t.multiple;
      var f = t.value;
      f != null ? oa(a, !!t.multiple, f, !1) : s !== !!t.multiple && (t.defaultValue != null ? oa(a, !!t.multiple, t.defaultValue, !0) : oa(a, !!t.multiple, t.multiple ? [] : "", !1));
    }
    function gp(e, t) {
      var a = e, s = t.value;
      s != null && oa(a, !!t.multiple, s, !1);
    }
    var sc = !1;
    function uc(e, t) {
      var a = e;
      if (t.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var s = Gt({}, t, {
        value: void 0,
        defaultValue: void 0,
        children: Er(a._wrapperState.initialValue)
      });
      return s;
    }
    function ol(e, t) {
      var a = e;
      mi("textarea", t), t.value !== void 0 && t.defaultValue !== void 0 && !sc && (C("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", Vr() || "A component"), sc = !0);
      var s = t.value;
      if (s == null) {
        var f = t.children, v = t.defaultValue;
        if (f != null) {
          C("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (v != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Ht(f)) {
              if (f.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              f = f[0];
            }
            v = f;
          }
        }
        v == null && (v = ""), s = v;
      }
      a._wrapperState = {
        initialValue: aa(s)
      };
    }
    function ss(e, t) {
      var a = e, s = aa(t.value), f = aa(t.defaultValue);
      if (s != null) {
        var v = Er(s);
        v !== a.value && (a.value = v), t.defaultValue == null && a.defaultValue !== v && (a.defaultValue = v);
      }
      f != null && (a.defaultValue = Er(f));
    }
    function Sd(e, t) {
      var a = e, s = a.textContent;
      s === a._wrapperState.initialValue && s !== "" && s !== null && (a.value = s);
    }
    function Us(e, t) {
      ss(e, t);
    }
    var Tr = "http://www.w3.org/1999/xhtml", wd = "http://www.w3.org/1998/Math/MathML", lc = "http://www.w3.org/2000/svg";
    function cc(e) {
      switch (e) {
        case "svg":
          return lc;
        case "math":
          return wd;
        default:
          return Tr;
      }
    }
    function sl(e, t) {
      return e == null || e === Tr ? cc(t) : e === lc && t === "foreignObject" ? Tr : e;
    }
    var wf = function(e) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, a, s, f) {
        MSApp.execUnsafeLocalFunction(function() {
          return e(t, a, s, f);
        });
      } : e;
    }, fc, Ed = wf(function(e, t) {
      if (e.namespaceURI === lc && !("innerHTML" in e)) {
        fc = fc || document.createElement("div"), fc.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>";
        for (var a = fc.firstChild; e.firstChild; )
          e.removeChild(e.firstChild);
        for (; a.firstChild; )
          e.appendChild(a.firstChild);
        return;
      }
      e.innerHTML = t;
    }), yi = 1, Yo = 3, En = 8, ri = 9, Is = 11, sa = function(e, t) {
      if (t) {
        var a = e.firstChild;
        if (a && a === e.lastChild && a.nodeType === Yo) {
          a.nodeValue = t;
          return;
        }
      }
      e.textContent = t;
    }, Td = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, Na = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Cd(e, t) {
      return e + t.charAt(0).toUpperCase() + t.substring(1);
    }
    var gu = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Na).forEach(function(e) {
      gu.forEach(function(t) {
        Na[Cd(t, e)] = Na[e];
      });
    });
    function ul(e, t, a) {
      var s = t == null || typeof t == "boolean" || t === "";
      return s ? "" : !a && typeof t == "number" && t !== 0 && !(Na.hasOwnProperty(e) && Na[e]) ? t + "px" : (zr(t, e), ("" + t).trim());
    }
    var Vo = /([A-Z])/g, _p = /^ms-/;
    function us(e) {
      return e.replace(Vo, "-$1").toLowerCase().replace(_p, "-ms-");
    }
    var ll = function() {
    };
    {
      var xd = /^(?:webkit|moz|o)[A-Z]/, dc = /^-ms-/, cl = /-(.)/g, Ni = /;\s*$/, _u = {}, Pa = {}, bd = !1, Aa = !1, Su = function(e) {
        return e.replace(cl, function(t, a) {
          return a.toUpperCase();
        });
      }, hc = function(e) {
        _u.hasOwnProperty(e) && _u[e] || (_u[e] = !0, C(
          "Unsupported style property %s. Did you mean %s?",
          e,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Su(e.replace(dc, "ms-"))
        ));
      }, pc = function(e) {
        _u.hasOwnProperty(e) && _u[e] || (_u[e] = !0, C("Unsupported vendor-prefixed style property %s. Did you mean %s?", e, e.charAt(0).toUpperCase() + e.slice(1)));
      }, fl = function(e, t) {
        Pa.hasOwnProperty(t) && Pa[t] || (Pa[t] = !0, C(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, e, t.replace(Ni, "")));
      }, vc = function(e, t) {
        bd || (bd = !0, C("`NaN` is an invalid value for the `%s` css style property.", e));
      }, mc = function(e, t) {
        Aa || (Aa = !0, C("`Infinity` is an invalid value for the `%s` css style property.", e));
      };
      ll = function(e, t) {
        e.indexOf("-") > -1 ? hc(e) : xd.test(e) ? pc(e) : Ni.test(t) && fl(e, t), typeof t == "number" && (isNaN(t) ? vc(e, t) : isFinite(t) || mc(e, t));
      };
    }
    var wu = ll;
    function yc(e) {
      {
        var t = "", a = "";
        for (var s in e)
          if (e.hasOwnProperty(s)) {
            var f = e[s];
            if (f != null) {
              var v = s.indexOf("--") === 0;
              t += a + (v ? s : us(s)) + ":", t += ul(s, f, v), a = ";";
            }
          }
        return t || null;
      }
    }
    function gc(e, t) {
      var a = e.style;
      for (var s in t)
        if (t.hasOwnProperty(s)) {
          var f = s.indexOf("--") === 0;
          f || wu(s, t[s]);
          var v = ul(s, t[s], f);
          s === "float" && (s = "cssFloat"), f ? a.setProperty(s, v) : a[s] = v;
        }
    }
    function Md(e) {
      return e == null || typeof e == "boolean" || e === "";
    }
    function ua(e) {
      var t = {};
      for (var a in e)
        for (var s = Td[a] || [a], f = 0; f < s.length; f++)
          t[s[f]] = a;
      return t;
    }
    function ls(e, t) {
      {
        if (!t)
          return;
        var a = ua(e), s = ua(t), f = {};
        for (var v in a) {
          var _ = a[v], E = s[v];
          if (E && _ !== E) {
            var x = _ + "," + E;
            if (f[x])
              continue;
            f[x] = !0, C("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", Md(e[_]) ? "Removing" : "Updating", _, E);
          }
        }
      }
    }
    var Rd = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, Ef = Gt({
      menuitem: !0
    }, Rd), Dd = "__html";
    function dl(e, t) {
      if (t) {
        if (Ef[e] && (t.children != null || t.dangerouslySetInnerHTML != null))
          throw new Error(e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (t.dangerouslySetInnerHTML != null) {
          if (t.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof t.dangerouslySetInnerHTML != "object" || !(Dd in t.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!t.suppressContentEditableWarning && t.contentEditable && t.children != null && C("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), t.style != null && typeof t.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function Wo(e, t) {
      if (e.indexOf("-") === -1)
        return typeof t.is == "string";
      switch (e) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var $i = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, hl = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, za = {}, Eu = new RegExp("^(aria)-[" + ft + "]*$"), pl = new RegExp("^(aria)[A-Z][" + ft + "]*$");
    function _c(e, t) {
      {
        if (Ie.call(za, t) && za[t])
          return !0;
        if (pl.test(t)) {
          var a = "aria-" + t.slice(4).toLowerCase(), s = hl.hasOwnProperty(a) ? a : null;
          if (s == null)
            return C("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", t), za[t] = !0, !0;
          if (t !== s)
            return C("Invalid ARIA attribute `%s`. Did you mean `%s`?", t, s), za[t] = !0, !0;
        }
        if (Eu.test(t)) {
          var f = t.toLowerCase(), v = hl.hasOwnProperty(f) ? f : null;
          if (v == null)
            return za[t] = !0, !1;
          if (t !== v)
            return C("Unknown ARIA attribute `%s`. Did you mean `%s`?", t, v), za[t] = !0, !0;
        }
      }
      return !0;
    }
    function kd(e, t) {
      {
        var a = [];
        for (var s in t) {
          var f = _c(e, s);
          f || a.push(s);
        }
        var v = a.map(function(_) {
          return "`" + _ + "`";
        }).join(", ");
        a.length === 1 ? C("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", v, e) : a.length > 1 && C("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", v, e);
      }
    }
    function cs(e, t) {
      Wo(e, t) || kd(e, t);
    }
    var js = !1;
    function fs(e, t) {
      {
        if (e !== "input" && e !== "textarea" && e !== "select")
          return;
        t != null && t.value === null && !js && (js = !0, e === "select" && t.multiple ? C("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", e) : C("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", e));
      }
    }
    var Sc = function() {
    };
    {
      var Or = {}, Tf = /^on./, co = /^on[^A-Z]/, Cf = new RegExp("^(aria)-[" + ft + "]*$"), xf = new RegExp("^(aria)[A-Z][" + ft + "]*$");
      Sc = function(e, t, a, s) {
        if (Ie.call(Or, t) && Or[t])
          return !0;
        var f = t.toLowerCase();
        if (f === "onfocusin" || f === "onfocusout")
          return C("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Or[t] = !0, !0;
        if (s != null) {
          var v = s.registrationNameDependencies, _ = s.possibleRegistrationNames;
          if (v.hasOwnProperty(t))
            return !0;
          var E = _.hasOwnProperty(f) ? _[f] : null;
          if (E != null)
            return C("Invalid event handler property `%s`. Did you mean `%s`?", t, E), Or[t] = !0, !0;
          if (Tf.test(t))
            return C("Unknown event handler property `%s`. It will be ignored.", t), Or[t] = !0, !0;
        } else if (Tf.test(t))
          return co.test(t) && C("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", t), Or[t] = !0, !0;
        if (Cf.test(t) || xf.test(t))
          return !0;
        if (f === "innerhtml")
          return C("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Or[t] = !0, !0;
        if (f === "aria")
          return C("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Or[t] = !0, !0;
        if (f === "is" && a !== null && a !== void 0 && typeof a != "string")
          return C("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof a), Or[t] = !0, !0;
        if (typeof a == "number" && isNaN(a))
          return C("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", t), Or[t] = !0, !0;
        var x = ti(t), k = x !== null && x.type === Yi;
        if ($i.hasOwnProperty(f)) {
          var O = $i[f];
          if (O !== t)
            return C("Invalid DOM property `%s`. Did you mean `%s`?", t, O), Or[t] = !0, !0;
        } else if (!k && t !== f)
          return C("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", t, f), Or[t] = !0, !0;
        return typeof a == "boolean" && ei(t, a, x, !1) ? (a ? C('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', a, t, t, a, t) : C('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', a, t, t, a, t, t, t), Or[t] = !0, !0) : k ? !0 : ei(t, a, x, !1) ? (Or[t] = !0, !1) : ((a === "false" || a === "true") && x !== null && x.type === er && (C("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", a, t, a === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', t, a), Or[t] = !0), !0);
      };
    }
    var Tu = function(e, t, a) {
      {
        var s = [];
        for (var f in t) {
          var v = Sc(e, f, t[f], a);
          v || s.push(f);
        }
        var _ = s.map(function(E) {
          return "`" + E + "`";
        }).join(", ");
        s.length === 1 ? C("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", _, e) : s.length > 1 && C("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", _, e);
      }
    };
    function Od(e, t, a) {
      Wo(e, t) || Tu(e, t, a);
    }
    var la = 1, Zo = 2, ds = 4, Ld = la | Zo | ds, vl = null;
    function Cu(e) {
      vl !== null && C("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), vl = e;
    }
    function Nd() {
      vl === null && C("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), vl = null;
    }
    function bf(e) {
      return e === vl;
    }
    function ml(e) {
      var t = e.target || e.srcElement || window;
      return t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === Yo ? t.parentNode : t;
    }
    var kn = null, hs = null, fo = null;
    function Fs(e) {
      var t = Wc(e);
      if (t) {
        if (typeof kn != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var a = t.stateNode;
        if (a) {
          var s = _y(a);
          kn(t.stateNode, t.type, s);
        }
      }
    }
    function Pd(e) {
      kn = e;
    }
    function r(e) {
      hs ? fo ? fo.push(e) : fo = [e] : hs = e;
    }
    function u() {
      return hs !== null || fo !== null;
    }
    function h() {
      if (hs) {
        var e = hs, t = fo;
        if (hs = null, fo = null, Fs(e), t)
          for (var a = 0; a < t.length; a++)
            Fs(t[a]);
      }
    }
    var y = function(e, t) {
      return e(t);
    }, T = function() {
    }, D = !1;
    function I() {
      var e = u();
      e && (T(), h());
    }
    function Q(e, t, a) {
      if (D)
        return e(t, a);
      D = !0;
      try {
        return y(e, t, a);
      } finally {
        D = !1, I();
      }
    }
    function ie(e, t, a) {
      y = e, T = a;
    }
    function ge(e) {
      return e === "button" || e === "input" || e === "select" || e === "textarea";
    }
    function Fe(e, t, a) {
      switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(a.disabled && ge(t));
        default:
          return !1;
      }
    }
    function ht(e, t) {
      var a = e.stateNode;
      if (a === null)
        return null;
      var s = _y(a);
      if (s === null)
        return null;
      var f = s[t];
      if (Fe(t, e.type, s))
        return null;
      if (f && typeof f != "function")
        throw new Error("Expected `" + t + "` listener to be a function, instead got a value of `" + typeof f + "` type.");
      return f;
    }
    var Vt = !1;
    if (yn)
      try {
        var hr = {};
        Object.defineProperty(hr, "passive", {
          get: function() {
            Vt = !0;
          }
        }), window.addEventListener("test", hr, hr), window.removeEventListener("test", hr, hr);
      } catch {
        Vt = !1;
      }
    function Lr(e, t, a, s, f, v, _, E, x) {
      var k = Array.prototype.slice.call(arguments, 3);
      try {
        t.apply(a, k);
      } catch (O) {
        this.onError(O);
      }
    }
    var Pi = Lr;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var ii = document.createElement("react");
      Pi = function(t, a, s, f, v, _, E, x, k) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var O = document.createEvent("Event"), V = !1, B = !0, ne = window.event, re = Object.getOwnPropertyDescriptor(window, "event");
        function de() {
          ii.removeEventListener(he, wt, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = ne);
        }
        var Ge = Array.prototype.slice.call(arguments, 3);
        function wt() {
          V = !0, de(), a.apply(s, Ge), B = !1;
        }
        var dt, vn = !1, ln = !1;
        function K(X) {
          if (dt = X.error, vn = !0, dt === null && X.colno === 0 && X.lineno === 0 && (ln = !0), X.defaultPrevented && dt != null && typeof dt == "object")
            try {
              dt._suppressLogging = !0;
            } catch {
            }
        }
        var he = "react-" + (t || "invokeguardedcallback");
        if (window.addEventListener("error", K), ii.addEventListener(he, wt, !1), O.initEvent(he, !1, !1), ii.dispatchEvent(O), re && Object.defineProperty(window, "event", re), V && B && (vn ? ln && (dt = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : dt = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(dt)), window.removeEventListener("error", K), !V)
          return de(), Lr.apply(this, arguments);
      };
    }
    var xu = Pi, ps = !1, Ua = null, yl = !1, $o = null, ho = {
      onError: function(e) {
        ps = !0, Ua = e;
      }
    };
    function vs(e, t, a, s, f, v, _, E, x) {
      ps = !1, Ua = null, xu.apply(ho, arguments);
    }
    function On(e, t, a, s, f, v, _, E, x) {
      if (vs.apply(this, arguments), ps) {
        var k = Mf();
        yl || (yl = !0, $o = k);
      }
    }
    function bu() {
      if (yl) {
        var e = $o;
        throw yl = !1, $o = null, e;
      }
    }
    function Sp() {
      return ps;
    }
    function Mf() {
      if (ps) {
        var e = Ua;
        return ps = !1, Ua = null, e;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function ca(e) {
      return e._reactInternals;
    }
    function Hs(e) {
      return e._reactInternals !== void 0;
    }
    function Bs(e, t) {
      e._reactInternals = t;
    }
    var pt = (
      /*                      */
      0
    ), Mu = (
      /*                */
      1
    ), rr = (
      /*                    */
      2
    ), Wt = (
      /*                       */
      4
    ), Rn = (
      /*                */
      16
    ), Ln = (
      /*                 */
      32
    ), ms = (
      /*                     */
      64
    ), At = (
      /*                   */
      128
    ), Cr = (
      /*            */
      256
    ), fa = (
      /*                          */
      512
    ), po = (
      /*                     */
      1024
    ), cr = (
      /*                      */
      2048
    ), vo = (
      /*                    */
      4096
    ), Ru = (
      /*                   */
      8192
    ), Rf = (
      /*             */
      16384
    ), Ad = cr | Wt | ms | fa | po | Rf, Em = (
      /*               */
      32767
    ), Ia = (
      /*                   */
      32768
    ), ai = (
      /*                */
      65536
    ), Df = (
      /* */
      131072
    ), wp = (
      /*                       */
      1048576
    ), Ep = (
      /*                    */
      2097152
    ), da = (
      /*                 */
      4194304
    ), Du = (
      /*                */
      8388608
    ), ha = (
      /*               */
      16777216
    ), gl = (
      /*              */
      33554432
    ), wc = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Wt | po | 0
    ), pa = rr | Wt | Rn | Ln | fa | vo | Ru, Ai = Wt | ms | fa | Ru, mo = cr | Rn, gi = da | Du | Ep, Ys = d.ReactCurrentOwner;
    function ja(e) {
      var t = e, a = e;
      if (e.alternate)
        for (; t.return; )
          t = t.return;
      else {
        var s = t;
        do
          t = s, (t.flags & (rr | vo)) !== pt && (a = t.return), s = t.return;
        while (s);
      }
      return t.tag === H ? a : null;
    }
    function Tp(e) {
      if (e.tag === G) {
        var t = e.memoizedState;
        if (t === null) {
          var a = e.alternate;
          a !== null && (t = a.memoizedState);
        }
        if (t !== null)
          return t.dehydrated;
      }
      return null;
    }
    function zd(e) {
      return e.tag === H ? e.stateNode.containerInfo : null;
    }
    function Cp(e) {
      return ja(e) === e;
    }
    function Fa(e) {
      {
        var t = Ys.current;
        if (t !== null && t.tag === j) {
          var a = t, s = a.stateNode;
          s._warnedAboutRefsInRender || C("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Ot(a) || "A component"), s._warnedAboutRefsInRender = !0;
        }
      }
      var f = ca(e);
      return f ? ja(f) === f : !1;
    }
    function va(e) {
      if (ja(e) !== e)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function ir(e) {
      var t = e.alternate;
      if (!t) {
        var a = ja(e);
        if (a === null)
          throw new Error("Unable to find node on an unmounted component.");
        return a !== e ? null : e;
      }
      for (var s = e, f = t; ; ) {
        var v = s.return;
        if (v === null)
          break;
        var _ = v.alternate;
        if (_ === null) {
          var E = v.return;
          if (E !== null) {
            s = f = E;
            continue;
          }
          break;
        }
        if (v.child === _.child) {
          for (var x = v.child; x; ) {
            if (x === s)
              return va(v), e;
            if (x === f)
              return va(v), t;
            x = x.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (s.return !== f.return)
          s = v, f = _;
        else {
          for (var k = !1, O = v.child; O; ) {
            if (O === s) {
              k = !0, s = v, f = _;
              break;
            }
            if (O === f) {
              k = !0, f = v, s = _;
              break;
            }
            O = O.sibling;
          }
          if (!k) {
            for (O = _.child; O; ) {
              if (O === s) {
                k = !0, s = _, f = v;
                break;
              }
              if (O === f) {
                k = !0, f = _, s = v;
                break;
              }
              O = O.sibling;
            }
            if (!k)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (s.alternate !== f)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (s.tag !== H)
        throw new Error("Unable to find node on an unmounted component.");
      return s.stateNode.current === s ? e : t;
    }
    function yo(e) {
      var t = ir(e);
      return t !== null ? xp(t) : null;
    }
    function xp(e) {
      if (e.tag === J || e.tag === oe)
        return e;
      for (var t = e.child; t !== null; ) {
        var a = xp(t);
        if (a !== null)
          return a;
        t = t.sibling;
      }
      return null;
    }
    function Tm(e) {
      var t = ir(e);
      return t !== null ? Ud(t) : null;
    }
    function Ud(e) {
      if (e.tag === J || e.tag === oe)
        return e;
      for (var t = e.child; t !== null; ) {
        if (t.tag !== $) {
          var a = Ud(t);
          if (a !== null)
            return a;
        }
        t = t.sibling;
      }
      return null;
    }
    var Id = c.unstable_scheduleCallback, Cm = c.unstable_cancelCallback, jd = c.unstable_shouldYield, xm = c.unstable_requestPaint, pr = c.unstable_now, bp = c.unstable_getCurrentPriorityLevel, Fd = c.unstable_ImmediatePriority, Ha = c.unstable_UserBlockingPriority, ys = c.unstable_NormalPriority, Hd = c.unstable_LowPriority, ku = c.unstable_IdlePriority, Mp = c.unstable_yieldValue, Rp = c.unstable_setDisableYieldValue, Ou = null, oi = null, Pe = null, Nr = !1, _i = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Dp(e) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var t = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (t.isDisabled)
        return !0;
      if (!t.supportsFiber)
        return C("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        qe && (e = Gt({}, e, {
          getLaneLabelMap: Nu,
          injectProfilingHooks: Ws
        })), Ou = t.inject(e), oi = t;
      } catch (a) {
        C("React instrumentation encountered an error: %s.", a);
      }
      return !!t.checkDCE;
    }
    function bm(e, t) {
      if (oi && typeof oi.onScheduleFiberRoot == "function")
        try {
          oi.onScheduleFiberRoot(Ou, e, t);
        } catch (a) {
          Nr || (Nr = !0, C("React instrumentation encountered an error: %s", a));
        }
    }
    function Vs(e, t) {
      if (oi && typeof oi.onCommitFiberRoot == "function")
        try {
          var a = (e.current.flags & At) === At;
          if (Oe) {
            var s;
            switch (t) {
              case zi:
                s = Fd;
                break;
              case Si:
                s = Ha;
                break;
              case $s:
                s = ys;
                break;
              case If:
                s = ku;
                break;
              default:
                s = ys;
                break;
            }
            oi.onCommitFiberRoot(Ou, e, s, a);
          }
        } catch (f) {
          Nr || (Nr = !0, C("React instrumentation encountered an error: %s", f));
        }
    }
    function Lu(e) {
      if (oi && typeof oi.onPostCommitFiberRoot == "function")
        try {
          oi.onPostCommitFiberRoot(Ou, e);
        } catch (t) {
          Nr || (Nr = !0, C("React instrumentation encountered an error: %s", t));
        }
    }
    function kp(e) {
      if (oi && typeof oi.onCommitFiberUnmount == "function")
        try {
          oi.onCommitFiberUnmount(Ou, e);
        } catch (t) {
          Nr || (Nr = !0, C("React instrumentation encountered an error: %s", t));
        }
    }
    function Wr(e) {
      if (typeof Mp == "function" && (Rp(e), w(e)), oi && typeof oi.setStrictMode == "function")
        try {
          oi.setStrictMode(Ou, e);
        } catch (t) {
          Nr || (Nr = !0, C("React instrumentation encountered an error: %s", t));
        }
    }
    function Ws(e) {
      Pe = e;
    }
    function Nu() {
      {
        for (var e = /* @__PURE__ */ new Map(), t = 1, a = 0; a < ar; a++) {
          var s = s_(t);
          e.set(t, s), t *= 2;
        }
        return e;
      }
    }
    function Bd(e) {
      Pe !== null && typeof Pe.markCommitStarted == "function" && Pe.markCommitStarted(e);
    }
    function Op() {
      Pe !== null && typeof Pe.markCommitStopped == "function" && Pe.markCommitStopped();
    }
    function Pu(e) {
      Pe !== null && typeof Pe.markComponentRenderStarted == "function" && Pe.markComponentRenderStarted(e);
    }
    function _l() {
      Pe !== null && typeof Pe.markComponentRenderStopped == "function" && Pe.markComponentRenderStopped();
    }
    function Mm(e) {
      Pe !== null && typeof Pe.markComponentPassiveEffectMountStarted == "function" && Pe.markComponentPassiveEffectMountStarted(e);
    }
    function Lp() {
      Pe !== null && typeof Pe.markComponentPassiveEffectMountStopped == "function" && Pe.markComponentPassiveEffectMountStopped();
    }
    function Yd(e) {
      Pe !== null && typeof Pe.markComponentPassiveEffectUnmountStarted == "function" && Pe.markComponentPassiveEffectUnmountStarted(e);
    }
    function Rm() {
      Pe !== null && typeof Pe.markComponentPassiveEffectUnmountStopped == "function" && Pe.markComponentPassiveEffectUnmountStopped();
    }
    function Dm(e) {
      Pe !== null && typeof Pe.markComponentLayoutEffectMountStarted == "function" && Pe.markComponentLayoutEffectMountStarted(e);
    }
    function km() {
      Pe !== null && typeof Pe.markComponentLayoutEffectMountStopped == "function" && Pe.markComponentLayoutEffectMountStopped();
    }
    function Vd(e) {
      Pe !== null && typeof Pe.markComponentLayoutEffectUnmountStarted == "function" && Pe.markComponentLayoutEffectUnmountStarted(e);
    }
    function Ec() {
      Pe !== null && typeof Pe.markComponentLayoutEffectUnmountStopped == "function" && Pe.markComponentLayoutEffectUnmountStopped();
    }
    function Wd(e, t, a) {
      Pe !== null && typeof Pe.markComponentErrored == "function" && Pe.markComponentErrored(e, t, a);
    }
    function Om(e, t, a) {
      Pe !== null && typeof Pe.markComponentSuspended == "function" && Pe.markComponentSuspended(e, t, a);
    }
    function Lm(e) {
      Pe !== null && typeof Pe.markLayoutEffectsStarted == "function" && Pe.markLayoutEffectsStarted(e);
    }
    function Tc() {
      Pe !== null && typeof Pe.markLayoutEffectsStopped == "function" && Pe.markLayoutEffectsStopped();
    }
    function Nm(e) {
      Pe !== null && typeof Pe.markPassiveEffectsStarted == "function" && Pe.markPassiveEffectsStarted(e);
    }
    function kf() {
      Pe !== null && typeof Pe.markPassiveEffectsStopped == "function" && Pe.markPassiveEffectsStopped();
    }
    function Go(e) {
      Pe !== null && typeof Pe.markRenderStarted == "function" && Pe.markRenderStarted(e);
    }
    function Of() {
      Pe !== null && typeof Pe.markRenderYielded == "function" && Pe.markRenderYielded();
    }
    function Cc() {
      Pe !== null && typeof Pe.markRenderStopped == "function" && Pe.markRenderStopped();
    }
    function Sl(e) {
      Pe !== null && typeof Pe.markRenderScheduled == "function" && Pe.markRenderScheduled(e);
    }
    function Np(e, t) {
      Pe !== null && typeof Pe.markForceUpdateScheduled == "function" && Pe.markForceUpdateScheduled(e, t);
    }
    function Au(e, t) {
      Pe !== null && typeof Pe.markStateUpdateScheduled == "function" && Pe.markStateUpdateScheduled(e, t);
    }
    var Tt = (
      /*                         */
      0
    ), Jt = (
      /*                 */
      1
    ), bt = (
      /*                    */
      2
    ), vr = (
      /*               */
      8
    ), go = (
      /*              */
      16
    ), Zd = Math.clz32 ? Math.clz32 : wl, $d = Math.log, Pp = Math.LN2;
    function wl(e) {
      var t = e >>> 0;
      return t === 0 ? 32 : 31 - ($d(t) / Pp | 0) | 0;
    }
    var ar = 31, pe = (
      /*                        */
      0
    ), hn = (
      /*                          */
      0
    ), Dt = (
      /*                        */
      1
    ), gs = (
      /*    */
      2
    ), Ba = (
      /*             */
      4
    ), El = (
      /*            */
      8
    ), or = (
      /*                     */
      16
    ), Tl = (
      /*                */
      32
    ), zu = (
      /*                       */
      4194240
    ), Cl = (
      /*                        */
      64
    ), _o = (
      /*                        */
      128
    ), ma = (
      /*                        */
      256
    ), xl = (
      /*                        */
      512
    ), Lf = (
      /*                        */
      1024
    ), Nf = (
      /*                        */
      2048
    ), Gd = (
      /*                        */
      4096
    ), Qd = (
      /*                        */
      8192
    ), qd = (
      /*                        */
      16384
    ), Kd = (
      /*                       */
      32768
    ), Xd = (
      /*                       */
      65536
    ), Jd = (
      /*                       */
      131072
    ), eh = (
      /*                       */
      262144
    ), th = (
      /*                       */
      524288
    ), bl = (
      /*                       */
      1048576
    ), nh = (
      /*                       */
      2097152
    ), Ml = (
      /*                            */
      130023424
    ), Zs = (
      /*                             */
      4194304
    ), rh = (
      /*                             */
      8388608
    ), Pf = (
      /*                             */
      16777216
    ), ih = (
      /*                             */
      33554432
    ), ah = (
      /*                             */
      67108864
    ), Ap = Zs, xc = (
      /*          */
      134217728
    ), oh = (
      /*                          */
      268435455
    ), bc = (
      /*               */
      268435456
    ), Uu = (
      /*                        */
      536870912
    ), ya = (
      /*                   */
      1073741824
    );
    function s_(e) {
      {
        if (e & Dt)
          return "Sync";
        if (e & gs)
          return "InputContinuousHydration";
        if (e & Ba)
          return "InputContinuous";
        if (e & El)
          return "DefaultHydration";
        if (e & or)
          return "Default";
        if (e & Tl)
          return "TransitionHydration";
        if (e & zu)
          return "Transition";
        if (e & Ml)
          return "Retry";
        if (e & xc)
          return "SelectiveHydration";
        if (e & bc)
          return "IdleHydration";
        if (e & Uu)
          return "Idle";
        if (e & ya)
          return "Offscreen";
      }
    }
    var Jn = -1, sh = Cl, uh = Zs;
    function Mc(e) {
      switch (Ir(e)) {
        case Dt:
          return Dt;
        case gs:
          return gs;
        case Ba:
          return Ba;
        case El:
          return El;
        case or:
          return or;
        case Tl:
          return Tl;
        case Cl:
        case _o:
        case ma:
        case xl:
        case Lf:
        case Nf:
        case Gd:
        case Qd:
        case qd:
        case Kd:
        case Xd:
        case Jd:
        case eh:
        case th:
        case bl:
        case nh:
          return e & zu;
        case Zs:
        case rh:
        case Pf:
        case ih:
        case ah:
          return e & Ml;
        case xc:
          return xc;
        case bc:
          return bc;
        case Uu:
          return Uu;
        case ya:
          return ya;
        default:
          return C("Should have found matching lanes. This is a bug in React."), e;
      }
    }
    function Af(e, t) {
      var a = e.pendingLanes;
      if (a === pe)
        return pe;
      var s = pe, f = e.suspendedLanes, v = e.pingedLanes, _ = a & oh;
      if (_ !== pe) {
        var E = _ & ~f;
        if (E !== pe)
          s = Mc(E);
        else {
          var x = _ & v;
          x !== pe && (s = Mc(x));
        }
      } else {
        var k = a & ~f;
        k !== pe ? s = Mc(k) : v !== pe && (s = Mc(v));
      }
      if (s === pe)
        return pe;
      if (t !== pe && t !== s && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (t & f) === pe) {
        var O = Ir(s), V = Ir(t);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          O >= V || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          O === or && (V & zu) !== pe
        )
          return t;
      }
      (s & Ba) !== pe && (s |= a & or);
      var B = e.entangledLanes;
      if (B !== pe)
        for (var ne = e.entanglements, re = s & B; re > 0; ) {
          var de = Iu(re), Ge = 1 << de;
          s |= ne[de], re &= ~Ge;
        }
      return s;
    }
    function Pm(e, t) {
      for (var a = e.eventTimes, s = Jn; t > 0; ) {
        var f = Iu(t), v = 1 << f, _ = a[f];
        _ > s && (s = _), t &= ~v;
      }
      return s;
    }
    function lh(e, t) {
      switch (e) {
        case Dt:
        case gs:
        case Ba:
          return t + 250;
        case El:
        case or:
        case Tl:
        case Cl:
        case _o:
        case ma:
        case xl:
        case Lf:
        case Nf:
        case Gd:
        case Qd:
        case qd:
        case Kd:
        case Xd:
        case Jd:
        case eh:
        case th:
        case bl:
        case nh:
          return t + 5e3;
        case Zs:
        case rh:
        case Pf:
        case ih:
        case ah:
          return Jn;
        case xc:
        case bc:
        case Uu:
        case ya:
          return Jn;
        default:
          return C("Should have found matching lanes. This is a bug in React."), Jn;
      }
    }
    function u_(e, t) {
      for (var a = e.pendingLanes, s = e.suspendedLanes, f = e.pingedLanes, v = e.expirationTimes, _ = a; _ > 0; ) {
        var E = Iu(_), x = 1 << E, k = v[E];
        k === Jn ? ((x & s) === pe || (x & f) !== pe) && (v[E] = lh(x, t)) : k <= t && (e.expiredLanes |= x), _ &= ~x;
      }
    }
    function l_(e) {
      return Mc(e.pendingLanes);
    }
    function zp(e) {
      var t = e.pendingLanes & ~ya;
      return t !== pe ? t : t & ya ? ya : pe;
    }
    function Rc(e) {
      return (e & Dt) !== pe;
    }
    function zf(e) {
      return (e & oh) !== pe;
    }
    function ch(e) {
      return (e & Ml) === e;
    }
    function c_(e) {
      var t = Dt | Ba | or;
      return (e & t) === pe;
    }
    function Am(e) {
      return (e & zu) === e;
    }
    function Uf(e, t) {
      var a = gs | Ba | El | or;
      return (t & a) !== pe;
    }
    function zm(e, t) {
      return (t & e.expiredLanes) !== pe;
    }
    function Up(e) {
      return (e & zu) !== pe;
    }
    function Ip() {
      var e = sh;
      return sh <<= 1, (sh & zu) === pe && (sh = Cl), e;
    }
    function f_() {
      var e = uh;
      return uh <<= 1, (uh & Ml) === pe && (uh = Zs), e;
    }
    function Ir(e) {
      return e & -e;
    }
    function Zr(e) {
      return Ir(e);
    }
    function Iu(e) {
      return 31 - Zd(e);
    }
    function fh(e) {
      return Iu(e);
    }
    function ga(e, t) {
      return (e & t) !== pe;
    }
    function Rl(e, t) {
      return (e & t) === t;
    }
    function Zt(e, t) {
      return e | t;
    }
    function Dc(e, t) {
      return e & ~t;
    }
    function jp(e, t) {
      return e & t;
    }
    function Um(e) {
      return e;
    }
    function Im(e, t) {
      return e !== hn && e < t ? e : t;
    }
    function dh(e) {
      for (var t = [], a = 0; a < ar; a++)
        t.push(e);
      return t;
    }
    function Dl(e, t, a) {
      e.pendingLanes |= t, t !== Uu && (e.suspendedLanes = pe, e.pingedLanes = pe);
      var s = e.eventTimes, f = fh(t);
      s[f] = a;
    }
    function Fp(e, t) {
      e.suspendedLanes |= t, e.pingedLanes &= ~t;
      for (var a = e.expirationTimes, s = t; s > 0; ) {
        var f = Iu(s), v = 1 << f;
        a[f] = Jn, s &= ~v;
      }
    }
    function Hp(e, t, a) {
      e.pingedLanes |= e.suspendedLanes & t;
    }
    function Bp(e, t) {
      var a = e.pendingLanes & ~t;
      e.pendingLanes = t, e.suspendedLanes = pe, e.pingedLanes = pe, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t;
      for (var s = e.entanglements, f = e.eventTimes, v = e.expirationTimes, _ = a; _ > 0; ) {
        var E = Iu(_), x = 1 << E;
        s[E] = pe, f[E] = Jn, v[E] = Jn, _ &= ~x;
      }
    }
    function kc(e, t) {
      for (var a = e.entangledLanes |= t, s = e.entanglements, f = a; f; ) {
        var v = Iu(f), _ = 1 << v;
        // Is this one of the newly entangled lanes?
        _ & t | // Is this lane transitively entangled with the newly entangled lanes?
        s[v] & t && (s[v] |= t), f &= ~_;
      }
    }
    function d_(e, t) {
      var a = Ir(t), s;
      switch (a) {
        case Ba:
          s = gs;
          break;
        case or:
          s = El;
          break;
        case Cl:
        case _o:
        case ma:
        case xl:
        case Lf:
        case Nf:
        case Gd:
        case Qd:
        case qd:
        case Kd:
        case Xd:
        case Jd:
        case eh:
        case th:
        case bl:
        case nh:
        case Zs:
        case rh:
        case Pf:
        case ih:
        case ah:
          s = Tl;
          break;
        case Uu:
          s = bc;
          break;
        default:
          s = hn;
          break;
      }
      return (s & (e.suspendedLanes | t)) !== hn ? hn : s;
    }
    function Yp(e, t, a) {
      if (_i)
        for (var s = e.pendingUpdatersLaneMap; a > 0; ) {
          var f = fh(a), v = 1 << f, _ = s[f];
          _.add(t), a &= ~v;
        }
    }
    function hh(e, t) {
      if (_i)
        for (var a = e.pendingUpdatersLaneMap, s = e.memoizedUpdaters; t > 0; ) {
          var f = fh(t), v = 1 << f, _ = a[f];
          _.size > 0 && (_.forEach(function(E) {
            var x = E.alternate;
            (x === null || !s.has(x)) && s.add(E);
          }), _.clear()), t &= ~v;
        }
    }
    function Vp(e, t) {
      return null;
    }
    var zi = Dt, Si = Ba, $s = or, If = Uu, kl = hn;
    function So() {
      return kl;
    }
    function $r(e) {
      kl = e;
    }
    function jf(e, t) {
      var a = kl;
      try {
        return kl = e, t();
      } finally {
        kl = a;
      }
    }
    function Ui(e, t) {
      return e !== 0 && e < t ? e : t;
    }
    function h_(e, t) {
      return e === 0 || e > t ? e : t;
    }
    function Wp(e, t) {
      return e !== 0 && e < t;
    }
    function Ff(e) {
      var t = Ir(e);
      return Wp(zi, t) ? Wp(Si, t) ? zf(t) ? $s : If : Si : zi;
    }
    function Gr(e) {
      var t = e.current.memoizedState;
      return t.isDehydrated;
    }
    var jm;
    function tt(e) {
      jm = e;
    }
    function Oc(e) {
      jm(e);
    }
    var Hf;
    function Fm(e) {
      Hf = e;
    }
    var Hm;
    function Bf(e) {
      Hm = e;
    }
    var Yf;
    function Zp(e) {
      Yf = e;
    }
    var $p;
    function Bm(e) {
      $p = e;
    }
    var ph = !1, Lc = [], _s = null, fr = null, si = null, wo = /* @__PURE__ */ new Map(), Nc = /* @__PURE__ */ new Map(), Gs = [], Qo = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function Ym(e) {
      return Qo.indexOf(e) > -1;
    }
    function Ss(e, t, a, s, f) {
      return {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: a,
        nativeEvent: f,
        targetContainers: [s]
      };
    }
    function Vm(e, t) {
      switch (e) {
        case "focusin":
        case "focusout":
          _s = null;
          break;
        case "dragenter":
        case "dragleave":
          fr = null;
          break;
        case "mouseover":
        case "mouseout":
          si = null;
          break;
        case "pointerover":
        case "pointerout": {
          var a = t.pointerId;
          wo.delete(a);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var s = t.pointerId;
          Nc.delete(s);
          break;
        }
      }
    }
    function Pc(e, t, a, s, f, v) {
      if (e === null || e.nativeEvent !== v) {
        var _ = Ss(t, a, s, f, v);
        if (t !== null) {
          var E = Wc(t);
          E !== null && Hf(E);
        }
        return _;
      }
      e.eventSystemFlags |= s;
      var x = e.targetContainers;
      return f !== null && x.indexOf(f) === -1 && x.push(f), e;
    }
    function Wm(e, t, a, s, f) {
      switch (t) {
        case "focusin": {
          var v = f;
          return _s = Pc(_s, e, t, a, s, v), !0;
        }
        case "dragenter": {
          var _ = f;
          return fr = Pc(fr, e, t, a, s, _), !0;
        }
        case "mouseover": {
          var E = f;
          return si = Pc(si, e, t, a, s, E), !0;
        }
        case "pointerover": {
          var x = f, k = x.pointerId;
          return wo.set(k, Pc(wo.get(k) || null, e, t, a, s, x)), !0;
        }
        case "gotpointercapture": {
          var O = f, V = O.pointerId;
          return Nc.set(V, Pc(Nc.get(V) || null, e, t, a, s, O)), !0;
        }
      }
      return !1;
    }
    function Gp(e) {
      var t = Xf(e.target);
      if (t !== null) {
        var a = ja(t);
        if (a !== null) {
          var s = a.tag;
          if (s === G) {
            var f = Tp(a);
            if (f !== null) {
              e.blockedOn = f, $p(e.priority, function() {
                Hm(a);
              });
              return;
            }
          } else if (s === H) {
            var v = a.stateNode;
            if (Gr(v)) {
              e.blockedOn = zd(a);
              return;
            }
          }
        }
      }
      e.blockedOn = null;
    }
    function Zm(e) {
      for (var t = Yf(), a = {
        blockedOn: null,
        target: e,
        priority: t
      }, s = 0; s < Gs.length && Wp(t, Gs[s].priority); s++)
        ;
      Gs.splice(s, 0, a), s === 0 && Gp(a);
    }
    function vh(e) {
      if (e.blockedOn !== null)
        return !1;
      for (var t = e.targetContainers; t.length > 0; ) {
        var a = t[0], s = Ol(e.domEventName, e.eventSystemFlags, a, e.nativeEvent);
        if (s === null) {
          var f = e.nativeEvent, v = new f.constructor(f.type, f);
          Cu(v), f.target.dispatchEvent(v), Nd();
        } else {
          var _ = Wc(s);
          return _ !== null && Hf(_), e.blockedOn = s, !1;
        }
        t.shift();
      }
      return !0;
    }
    function Vf(e, t, a) {
      vh(e) && a.delete(t);
    }
    function Qp() {
      ph = !1, _s !== null && vh(_s) && (_s = null), fr !== null && vh(fr) && (fr = null), si !== null && vh(si) && (si = null), wo.forEach(Vf), Nc.forEach(Vf);
    }
    function Ii(e, t) {
      e.blockedOn === t && (e.blockedOn = null, ph || (ph = !0, c.unstable_scheduleCallback(c.unstable_NormalPriority, Qp)));
    }
    function un(e) {
      if (Lc.length > 0) {
        Ii(Lc[0], e);
        for (var t = 1; t < Lc.length; t++) {
          var a = Lc[t];
          a.blockedOn === e && (a.blockedOn = null);
        }
      }
      _s !== null && Ii(_s, e), fr !== null && Ii(fr, e), si !== null && Ii(si, e);
      var s = function(E) {
        return Ii(E, e);
      };
      wo.forEach(s), Nc.forEach(s);
      for (var f = 0; f < Gs.length; f++) {
        var v = Gs[f];
        v.blockedOn === e && (v.blockedOn = null);
      }
      for (; Gs.length > 0; ) {
        var _ = Gs[0];
        if (_.blockedOn !== null)
          break;
        Gp(_), _.blockedOn === null && Gs.shift();
      }
    }
    var mr = d.ReactCurrentBatchConfig, xr = !0;
    function ui(e) {
      xr = !!e;
    }
    function Ya() {
      return xr;
    }
    function Ac(e, t, a) {
      var s = Gi(t), f;
      switch (s) {
        case zi:
          f = Qr;
          break;
        case Si:
          f = Wf;
          break;
        case $s:
        default:
          f = Qs;
          break;
      }
      return f.bind(null, t, a, e);
    }
    function Qr(e, t, a, s) {
      var f = So(), v = mr.transition;
      mr.transition = null;
      try {
        $r(zi), Qs(e, t, a, s);
      } finally {
        $r(f), mr.transition = v;
      }
    }
    function Wf(e, t, a, s) {
      var f = So(), v = mr.transition;
      mr.transition = null;
      try {
        $r(Si), Qs(e, t, a, s);
      } finally {
        $r(f), mr.transition = v;
      }
    }
    function Qs(e, t, a, s) {
      xr && mh(e, t, a, s);
    }
    function mh(e, t, a, s) {
      var f = Ol(e, t, a, s);
      if (f === null) {
        N_(e, t, s, zc, a), Vm(e, s);
        return;
      }
      if (Wm(f, e, t, a, s)) {
        s.stopPropagation();
        return;
      }
      if (Vm(e, s), t & ds && Ym(e)) {
        for (; f !== null; ) {
          var v = Wc(f);
          v !== null && Oc(v);
          var _ = Ol(e, t, a, s);
          if (_ === null && N_(e, t, s, zc, a), _ === f)
            break;
          f = _;
        }
        f !== null && s.stopPropagation();
        return;
      }
      N_(e, t, s, null, a);
    }
    var zc = null;
    function Ol(e, t, a, s) {
      zc = null;
      var f = ml(s), v = Xf(f);
      if (v !== null) {
        var _ = ja(v);
        if (_ === null)
          v = null;
        else {
          var E = _.tag;
          if (E === G) {
            var x = Tp(_);
            if (x !== null)
              return x;
            v = null;
          } else if (E === H) {
            var k = _.stateNode;
            if (Gr(k))
              return zd(_);
            v = null;
          } else
            _ !== v && (v = null);
        }
      }
      return zc = v, null;
    }
    function Gi(e) {
      switch (e) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return zi;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Si;
        case "message": {
          var t = bp();
          switch (t) {
            case Fd:
              return zi;
            case Ha:
              return Si;
            case ys:
            case Hd:
              return $s;
            case ku:
              return If;
            default:
              return $s;
          }
        }
        default:
          return $s;
      }
    }
    function qp(e, t, a) {
      return e.addEventListener(t, a, !1), a;
    }
    function Uc(e, t, a) {
      return e.addEventListener(t, a, !0), a;
    }
    function qs(e, t, a, s) {
      return e.addEventListener(t, a, {
        capture: !0,
        passive: s
      }), a;
    }
    function yh(e, t, a, s) {
      return e.addEventListener(t, a, {
        passive: s
      }), a;
    }
    var Ll = null, ws = null, ju = null;
    function Fu(e) {
      return Ll = e, ws = _h(), !0;
    }
    function gh() {
      Ll = null, ws = null, ju = null;
    }
    function Ic() {
      if (ju)
        return ju;
      var e, t = ws, a = t.length, s, f = _h(), v = f.length;
      for (e = 0; e < a && t[e] === f[e]; e++)
        ;
      var _ = a - e;
      for (s = 1; s <= _ && t[a - s] === f[v - s]; s++)
        ;
      var E = s > 1 ? 1 - s : void 0;
      return ju = f.slice(e, E), ju;
    }
    function _h() {
      return "value" in Ll ? Ll.value : Ll.textContent;
    }
    function Nl(e) {
      var t, a = e.keyCode;
      return "charCode" in e ? (t = e.charCode, t === 0 && a === 13 && (t = 13)) : t = a, t === 10 && (t = 13), t >= 32 || t === 13 ? t : 0;
    }
    function Pl() {
      return !0;
    }
    function ji() {
      return !1;
    }
    function jr(e) {
      function t(a, s, f, v, _) {
        this._reactName = a, this._targetInst = f, this.type = s, this.nativeEvent = v, this.target = _, this.currentTarget = null;
        for (var E in e)
          if (e.hasOwnProperty(E)) {
            var x = e[E];
            x ? this[E] = x(v) : this[E] = v[E];
          }
        var k = v.defaultPrevented != null ? v.defaultPrevented : v.returnValue === !1;
        return k ? this.isDefaultPrevented = Pl : this.isDefaultPrevented = ji, this.isPropagationStopped = ji, this;
      }
      return Gt(t.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var a = this.nativeEvent;
          a && (a.preventDefault ? a.preventDefault() : typeof a.returnValue != "unknown" && (a.returnValue = !1), this.isDefaultPrevented = Pl);
        },
        stopPropagation: function() {
          var a = this.nativeEvent;
          a && (a.stopPropagation ? a.stopPropagation() : typeof a.cancelBubble != "unknown" && (a.cancelBubble = !0), this.isPropagationStopped = Pl);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: Pl
      }), t;
    }
    var Fi = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(e) {
        return e.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, Hi = jr(Fi), jc = Gt({}, Fi, {
      view: 0,
      detail: 0
    }), Kp = jr(jc), Zf, Xp, Eo;
    function $m(e) {
      e !== Eo && (Eo && e.type === "mousemove" ? (Zf = e.screenX - Eo.screenX, Xp = e.screenY - Eo.screenY) : (Zf = 0, Xp = 0), Eo = e);
    }
    var Fc = Gt({}, jc, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Eh,
      button: 0,
      buttons: 0,
      relatedTarget: function(e) {
        return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
      },
      movementX: function(e) {
        return "movementX" in e ? e.movementX : ($m(e), Zf);
      },
      movementY: function(e) {
        return "movementY" in e ? e.movementY : Xp;
      }
    }), Hu = jr(Fc), Jp = Gt({}, Fc, {
      dataTransfer: 0
    }), Al = jr(Jp), Gm = Gt({}, jc, {
      relatedTarget: 0
    }), Sh = jr(Gm), ev = Gt({}, Fi, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), wh = jr(ev), p_ = Gt({}, Fi, {
      clipboardData: function(e) {
        return "clipboardData" in e ? e.clipboardData : window.clipboardData;
      }
    }), v_ = jr(p_), Qm = Gt({}, Fi, {
      data: 0
    }), tv = jr(Qm), zl = tv, m_ = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Hc = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function qm(e) {
      if (e.key) {
        var t = m_[e.key] || e.key;
        if (t !== "Unidentified")
          return t;
      }
      if (e.type === "keypress") {
        var a = Nl(e);
        return a === 13 ? "Enter" : String.fromCharCode(a);
      }
      return e.type === "keydown" || e.type === "keyup" ? Hc[e.keyCode] || "Unidentified" : "";
    }
    var br = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function y_(e) {
      var t = this, a = t.nativeEvent;
      if (a.getModifierState)
        return a.getModifierState(e);
      var s = br[e];
      return s ? !!a[s] : !1;
    }
    function Eh(e) {
      return y_;
    }
    var g_ = Gt({}, jc, {
      key: qm,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Eh,
      // Legacy Interface
      charCode: function(e) {
        return e.type === "keypress" ? Nl(e) : 0;
      },
      keyCode: function(e) {
        return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      },
      which: function(e) {
        return e.type === "keypress" ? Nl(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      }
    }), __ = jr(g_), Km = Gt({}, Fc, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), nv = jr(Km), S_ = Gt({}, jc, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Eh
    }), To = jr(S_), rv = Gt({}, Fi, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), w_ = jr(rv), Bu = Gt({}, Fc, {
      deltaX: function(e) {
        return "deltaX" in e ? e.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in e ? -e.wheelDeltaX : 0
        );
      },
      deltaY: function(e) {
        return "deltaY" in e ? e.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in e ? -e.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in e ? -e.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), Th = jr(Bu), Ul = [9, 13, 27, 32], $f = 229, Gf = yn && "CompositionEvent" in window, Il = null;
    yn && "documentMode" in document && (Il = document.documentMode);
    var E_ = yn && "TextEvent" in window && !Il, Ch = yn && (!Gf || Il && Il > 8 && Il <= 11), Xm = 32, iv = String.fromCharCode(Xm);
    function Jm() {
      ur("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), ur("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), ur("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), ur("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Qf = !1;
    function xh(e) {
      return (e.ctrlKey || e.altKey || e.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(e.ctrlKey && e.altKey);
    }
    function ey(e) {
      switch (e) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function av(e, t) {
      return e === "keydown" && t.keyCode === $f;
    }
    function ty(e, t) {
      switch (e) {
        case "keyup":
          return Ul.indexOf(t.keyCode) !== -1;
        case "keydown":
          return t.keyCode !== $f;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function ov(e) {
      var t = e.detail;
      return typeof t == "object" && "data" in t ? t.data : null;
    }
    function bh(e) {
      return e.locale === "ko";
    }
    var Ks = !1;
    function sv(e, t, a, s, f) {
      var v, _;
      if (Gf ? v = ey(t) : Ks ? ty(t, s) && (v = "onCompositionEnd") : av(t, s) && (v = "onCompositionStart"), !v)
        return null;
      Ch && !bh(s) && (!Ks && v === "onCompositionStart" ? Ks = Fu(f) : v === "onCompositionEnd" && Ks && (_ = Ic()));
      var E = oy(a, v);
      if (E.length > 0) {
        var x = new tv(v, t, null, s, f);
        if (e.push({
          event: x,
          listeners: E
        }), _)
          x.data = _;
        else {
          var k = ov(s);
          k !== null && (x.data = k);
        }
      }
    }
    function Mh(e, t) {
      switch (e) {
        case "compositionend":
          return ov(t);
        case "keypress":
          var a = t.which;
          return a !== Xm ? null : (Qf = !0, iv);
        case "textInput":
          var s = t.data;
          return s === iv && Qf ? null : s;
        default:
          return null;
      }
    }
    function ny(e, t) {
      if (Ks) {
        if (e === "compositionend" || !Gf && ty(e, t)) {
          var a = Ic();
          return gh(), Ks = !1, a;
        }
        return null;
      }
      switch (e) {
        case "paste":
          return null;
        case "keypress":
          if (!xh(t)) {
            if (t.char && t.char.length > 1)
              return t.char;
            if (t.which)
              return String.fromCharCode(t.which);
          }
          return null;
        case "compositionend":
          return Ch && !bh(t) ? null : t.data;
        default:
          return null;
      }
    }
    function T_(e, t, a, s, f) {
      var v;
      if (E_ ? v = Mh(t, s) : v = ny(t, s), !v)
        return null;
      var _ = oy(a, "onBeforeInput");
      if (_.length > 0) {
        var E = new zl("onBeforeInput", "beforeinput", null, s, f);
        e.push({
          event: E,
          listeners: _
        }), E.data = v;
      }
    }
    function Rh(e, t, a, s, f, v, _) {
      sv(e, t, a, s, f), T_(e, t, a, s, f);
    }
    var C_ = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function Bc(e) {
      var t = e && e.nodeName && e.nodeName.toLowerCase();
      return t === "input" ? !!C_[e.type] : t === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function x_(e) {
      if (!yn)
        return !1;
      var t = "on" + e, a = t in document;
      if (!a) {
        var s = document.createElement("div");
        s.setAttribute(t, "return;"), a = typeof s[t] == "function";
      }
      return a;
    }
    function Dh() {
      ur("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function n(e, t, a, s) {
      r(s);
      var f = oy(t, "onChange");
      if (f.length > 0) {
        var v = new Hi("onChange", "change", null, a, s);
        e.push({
          event: v,
          listeners: f
        });
      }
    }
    var i = null, l = null;
    function p(e) {
      var t = e.nodeName && e.nodeName.toLowerCase();
      return t === "select" || t === "input" && e.type === "file";
    }
    function g(e) {
      var t = [];
      n(t, l, e, ml(e)), Q(S, t);
    }
    function S(e) {
      PE(e, 0);
    }
    function R(e) {
      var t = Ah(e);
      if (mu(t))
        return e;
    }
    function P(e, t) {
      if (e === "change")
        return t;
    }
    var F = !1;
    yn && (F = x_("input") && (!document.documentMode || document.documentMode > 9));
    function ae(e, t) {
      i = e, l = t, i.attachEvent("onpropertychange", Ee);
    }
    function we() {
      i && (i.detachEvent("onpropertychange", Ee), i = null, l = null);
    }
    function Ee(e) {
      e.propertyName === "value" && R(l) && g(e);
    }
    function Se(e, t, a) {
      e === "focusin" ? (we(), ae(t, a)) : e === "focusout" && we();
    }
    function Ze(e, t) {
      if (e === "selectionchange" || e === "keyup" || e === "keydown")
        return R(l);
    }
    function it(e) {
      var t = e.nodeName;
      return t && t.toLowerCase() === "input" && (e.type === "checkbox" || e.type === "radio");
    }
    function st(e, t) {
      if (e === "click")
        return R(t);
    }
    function Pr(e, t) {
      if (e === "input" || e === "change")
        return R(t);
    }
    function q(e) {
      var t = e._wrapperState;
      !t || !t.controlled || e.type !== "number" || gt(e, "number", e.value);
    }
    function Y(e, t, a, s, f, v, _) {
      var E = a ? Ah(a) : window, x, k;
      if (p(E) ? x = P : Bc(E) ? F ? x = Pr : (x = Ze, k = Se) : it(E) && (x = st), x) {
        var O = x(t, a);
        if (O) {
          n(e, O, s, f);
          return;
        }
      }
      k && k(t, E, a), t === "focusout" && q(E);
    }
    function ee() {
      Ue("onMouseEnter", ["mouseout", "mouseover"]), Ue("onMouseLeave", ["mouseout", "mouseover"]), Ue("onPointerEnter", ["pointerout", "pointerover"]), Ue("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function Re(e, t, a, s, f, v, _) {
      var E = t === "mouseover" || t === "pointerover", x = t === "mouseout" || t === "pointerout";
      if (E && !bf(s)) {
        var k = s.relatedTarget || s.fromElement;
        if (k && (Xf(k) || wv(k)))
          return;
      }
      if (!(!x && !E)) {
        var O;
        if (f.window === f)
          O = f;
        else {
          var V = f.ownerDocument;
          V ? O = V.defaultView || V.parentWindow : O = window;
        }
        var B, ne;
        if (x) {
          var re = s.relatedTarget || s.toElement;
          if (B = a, ne = re ? Xf(re) : null, ne !== null) {
            var de = ja(ne);
            (ne !== de || ne.tag !== J && ne.tag !== oe) && (ne = null);
          }
        } else
          B = null, ne = a;
        if (B !== ne) {
          var Ge = Hu, wt = "onMouseLeave", dt = "onMouseEnter", vn = "mouse";
          (t === "pointerout" || t === "pointerover") && (Ge = nv, wt = "onPointerLeave", dt = "onPointerEnter", vn = "pointer");
          var ln = B == null ? O : Ah(B), K = ne == null ? O : Ah(ne), he = new Ge(wt, vn + "leave", B, s, f);
          he.target = ln, he.relatedTarget = K;
          var X = null, Te = Xf(f);
          if (Te === a) {
            var Qe = new Ge(dt, vn + "enter", ne, s, f);
            Qe.target = K, Qe.relatedTarget = ln, X = Qe;
          }
          yM(e, he, X, B, ne);
        }
      }
    }
    function ct(e, t) {
      return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
    }
    var at = typeof Object.is == "function" ? Object.is : ct;
    function yt(e, t) {
      if (at(e, t))
        return !0;
      if (typeof e != "object" || e === null || typeof t != "object" || t === null)
        return !1;
      var a = Object.keys(e), s = Object.keys(t);
      if (a.length !== s.length)
        return !1;
      for (var f = 0; f < a.length; f++) {
        var v = a[f];
        if (!Ie.call(t, v) || !at(e[v], t[v]))
          return !1;
      }
      return !0;
    }
    function zt(e) {
      for (; e && e.firstChild; )
        e = e.firstChild;
      return e;
    }
    function li(e) {
      for (; e; ) {
        if (e.nextSibling)
          return e.nextSibling;
        e = e.parentNode;
      }
    }
    function wn(e, t) {
      for (var a = zt(e), s = 0, f = 0; a; ) {
        if (a.nodeType === Yo) {
          if (f = s + a.textContent.length, s <= t && f >= t)
            return {
              node: a,
              offset: t - s
            };
          s = f;
        }
        a = zt(li(a));
      }
    }
    function Yu(e) {
      var t = e.ownerDocument, a = t && t.defaultView || window, s = a.getSelection && a.getSelection();
      if (!s || s.rangeCount === 0)
        return null;
      var f = s.anchorNode, v = s.anchorOffset, _ = s.focusNode, E = s.focusOffset;
      try {
        f.nodeType, _.nodeType;
      } catch {
        return null;
      }
      return b_(e, f, v, _, E);
    }
    function b_(e, t, a, s, f) {
      var v = 0, _ = -1, E = -1, x = 0, k = 0, O = e, V = null;
      e:
        for (; ; ) {
          for (var B = null; O === t && (a === 0 || O.nodeType === Yo) && (_ = v + a), O === s && (f === 0 || O.nodeType === Yo) && (E = v + f), O.nodeType === Yo && (v += O.nodeValue.length), (B = O.firstChild) !== null; )
            V = O, O = B;
          for (; ; ) {
            if (O === e)
              break e;
            if (V === t && ++x === a && (_ = v), V === s && ++k === f && (E = v), (B = O.nextSibling) !== null)
              break;
            O = V, V = O.parentNode;
          }
          O = B;
        }
      return _ === -1 || E === -1 ? null : {
        start: _,
        end: E
      };
    }
    function Xb(e, t) {
      var a = e.ownerDocument || document, s = a && a.defaultView || window;
      if (s.getSelection) {
        var f = s.getSelection(), v = e.textContent.length, _ = Math.min(t.start, v), E = t.end === void 0 ? _ : Math.min(t.end, v);
        if (!f.extend && _ > E) {
          var x = E;
          E = _, _ = x;
        }
        var k = wn(e, _), O = wn(e, E);
        if (k && O) {
          if (f.rangeCount === 1 && f.anchorNode === k.node && f.anchorOffset === k.offset && f.focusNode === O.node && f.focusOffset === O.offset)
            return;
          var V = a.createRange();
          V.setStart(k.node, k.offset), f.removeAllRanges(), _ > E ? (f.addRange(V), f.extend(O.node, O.offset)) : (V.setEnd(O.node, O.offset), f.addRange(V));
        }
      }
    }
    function EE(e) {
      return e && e.nodeType === Yo;
    }
    function TE(e, t) {
      return !e || !t ? !1 : e === t ? !0 : EE(e) ? !1 : EE(t) ? TE(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1;
    }
    function Jb(e) {
      return e && e.ownerDocument && TE(e.ownerDocument.documentElement, e);
    }
    function eM(e) {
      try {
        return typeof e.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function CE() {
      for (var e = window, t = Bo(); t instanceof e.HTMLIFrameElement; ) {
        if (eM(t))
          e = t.contentWindow;
        else
          return t;
        t = Bo(e.document);
      }
      return t;
    }
    function M_(e) {
      var t = e && e.nodeName && e.nodeName.toLowerCase();
      return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true");
    }
    function tM() {
      var e = CE();
      return {
        focusedElem: e,
        selectionRange: M_(e) ? rM(e) : null
      };
    }
    function nM(e) {
      var t = CE(), a = e.focusedElem, s = e.selectionRange;
      if (t !== a && Jb(a)) {
        s !== null && M_(a) && iM(a, s);
        for (var f = [], v = a; v = v.parentNode; )
          v.nodeType === yi && f.push({
            element: v,
            left: v.scrollLeft,
            top: v.scrollTop
          });
        typeof a.focus == "function" && a.focus();
        for (var _ = 0; _ < f.length; _++) {
          var E = f[_];
          E.element.scrollLeft = E.left, E.element.scrollTop = E.top;
        }
      }
    }
    function rM(e) {
      var t;
      return "selectionStart" in e ? t = {
        start: e.selectionStart,
        end: e.selectionEnd
      } : t = Yu(e), t || {
        start: 0,
        end: 0
      };
    }
    function iM(e, t) {
      var a = t.start, s = t.end;
      s === void 0 && (s = a), "selectionStart" in e ? (e.selectionStart = a, e.selectionEnd = Math.min(s, e.value.length)) : Xb(e, t);
    }
    var aM = yn && "documentMode" in document && document.documentMode <= 11;
    function oM() {
      ur("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var kh = null, R_ = null, uv = null, D_ = !1;
    function sM(e) {
      if ("selectionStart" in e && M_(e))
        return {
          start: e.selectionStart,
          end: e.selectionEnd
        };
      var t = e.ownerDocument && e.ownerDocument.defaultView || window, a = t.getSelection();
      return {
        anchorNode: a.anchorNode,
        anchorOffset: a.anchorOffset,
        focusNode: a.focusNode,
        focusOffset: a.focusOffset
      };
    }
    function uM(e) {
      return e.window === e ? e.document : e.nodeType === ri ? e : e.ownerDocument;
    }
    function xE(e, t, a) {
      var s = uM(a);
      if (!(D_ || kh == null || kh !== Bo(s))) {
        var f = sM(kh);
        if (!uv || !yt(uv, f)) {
          uv = f;
          var v = oy(R_, "onSelect");
          if (v.length > 0) {
            var _ = new Hi("onSelect", "select", null, t, a);
            e.push({
              event: _,
              listeners: v
            }), _.target = kh;
          }
        }
      }
    }
    function lM(e, t, a, s, f, v, _) {
      var E = a ? Ah(a) : window;
      switch (t) {
        case "focusin":
          (Bc(E) || E.contentEditable === "true") && (kh = E, R_ = a, uv = null);
          break;
        case "focusout":
          kh = null, R_ = null, uv = null;
          break;
        case "mousedown":
          D_ = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          D_ = !1, xE(e, s, f);
          break;
        case "selectionchange":
          if (aM)
            break;
        case "keydown":
        case "keyup":
          xE(e, s, f);
      }
    }
    function ry(e, t) {
      var a = {};
      return a[e.toLowerCase()] = t.toLowerCase(), a["Webkit" + e] = "webkit" + t, a["Moz" + e] = "moz" + t, a;
    }
    var Oh = {
      animationend: ry("Animation", "AnimationEnd"),
      animationiteration: ry("Animation", "AnimationIteration"),
      animationstart: ry("Animation", "AnimationStart"),
      transitionend: ry("Transition", "TransitionEnd")
    }, k_ = {}, bE = {};
    yn && (bE = document.createElement("div").style, "AnimationEvent" in window || (delete Oh.animationend.animation, delete Oh.animationiteration.animation, delete Oh.animationstart.animation), "TransitionEvent" in window || delete Oh.transitionend.transition);
    function iy(e) {
      if (k_[e])
        return k_[e];
      if (!Oh[e])
        return e;
      var t = Oh[e];
      for (var a in t)
        if (t.hasOwnProperty(a) && a in bE)
          return k_[e] = t[a];
      return e;
    }
    var ME = iy("animationend"), RE = iy("animationiteration"), DE = iy("animationstart"), kE = iy("transitionend"), OE = /* @__PURE__ */ new Map(), LE = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Yc(e, t) {
      OE.set(e, t), ur(t, [e]);
    }
    function cM() {
      for (var e = 0; e < LE.length; e++) {
        var t = LE[e], a = t.toLowerCase(), s = t[0].toUpperCase() + t.slice(1);
        Yc(a, "on" + s);
      }
      Yc(ME, "onAnimationEnd"), Yc(RE, "onAnimationIteration"), Yc(DE, "onAnimationStart"), Yc("dblclick", "onDoubleClick"), Yc("focusin", "onFocus"), Yc("focusout", "onBlur"), Yc(kE, "onTransitionEnd");
    }
    function fM(e, t, a, s, f, v, _) {
      var E = OE.get(t);
      if (E !== void 0) {
        var x = Hi, k = t;
        switch (t) {
          case "keypress":
            if (Nl(s) === 0)
              return;
          case "keydown":
          case "keyup":
            x = __;
            break;
          case "focusin":
            k = "focus", x = Sh;
            break;
          case "focusout":
            k = "blur", x = Sh;
            break;
          case "beforeblur":
          case "afterblur":
            x = Sh;
            break;
          case "click":
            if (s.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            x = Hu;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            x = Al;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            x = To;
            break;
          case ME:
          case RE:
          case DE:
            x = wh;
            break;
          case kE:
            x = w_;
            break;
          case "scroll":
            x = Kp;
            break;
          case "wheel":
            x = Th;
            break;
          case "copy":
          case "cut":
          case "paste":
            x = v_;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            x = nv;
            break;
        }
        var O = (v & ds) !== 0;
        {
          var V = !O && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          t === "scroll", B = vM(a, E, s.type, O, V);
          if (B.length > 0) {
            var ne = new x(E, k, null, s, f);
            e.push({
              event: ne,
              listeners: B
            });
          }
        }
      }
    }
    cM(), ee(), Dh(), oM(), Jm();
    function dM(e, t, a, s, f, v, _) {
      fM(e, t, a, s, f, v);
      var E = (v & Ld) === 0;
      E && (Re(e, t, a, s, f), Y(e, t, a, s, f), lM(e, t, a, s, f), Rh(e, t, a, s, f));
    }
    var lv = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], O_ = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(lv));
    function NE(e, t, a) {
      var s = e.type || "unknown-event";
      e.currentTarget = a, On(s, t, void 0, e), e.currentTarget = null;
    }
    function hM(e, t, a) {
      var s;
      if (a)
        for (var f = t.length - 1; f >= 0; f--) {
          var v = t[f], _ = v.instance, E = v.currentTarget, x = v.listener;
          if (_ !== s && e.isPropagationStopped())
            return;
          NE(e, x, E), s = _;
        }
      else
        for (var k = 0; k < t.length; k++) {
          var O = t[k], V = O.instance, B = O.currentTarget, ne = O.listener;
          if (V !== s && e.isPropagationStopped())
            return;
          NE(e, ne, B), s = V;
        }
    }
    function PE(e, t) {
      for (var a = (t & ds) !== 0, s = 0; s < e.length; s++) {
        var f = e[s], v = f.event, _ = f.listeners;
        hM(v, _, a);
      }
      bu();
    }
    function pM(e, t, a, s, f) {
      var v = ml(a), _ = [];
      dM(_, e, s, a, v, t), PE(_, t);
    }
    function yr(e, t) {
      O_.has(e) || C('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', e);
      var a = !1, s = VR(t), f = gM(e, a);
      s.has(f) || (AE(t, e, Zo, a), s.add(f));
    }
    function L_(e, t, a) {
      O_.has(e) && !t && C('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', e);
      var s = 0;
      t && (s |= ds), AE(a, e, s, t);
    }
    var ay = "_reactListening" + Math.random().toString(36).slice(2);
    function cv(e) {
      if (!e[ay]) {
        e[ay] = !0, _t.forEach(function(a) {
          a !== "selectionchange" && (O_.has(a) || L_(a, !1, e), L_(a, !0, e));
        });
        var t = e.nodeType === ri ? e : e.ownerDocument;
        t !== null && (t[ay] || (t[ay] = !0, L_("selectionchange", !1, t)));
      }
    }
    function AE(e, t, a, s, f) {
      var v = Ac(e, t, a), _ = void 0;
      Vt && (t === "touchstart" || t === "touchmove" || t === "wheel") && (_ = !0), e = e, s ? _ !== void 0 ? qs(e, t, v, _) : Uc(e, t, v) : _ !== void 0 ? yh(e, t, v, _) : qp(e, t, v);
    }
    function zE(e, t) {
      return e === t || e.nodeType === En && e.parentNode === t;
    }
    function N_(e, t, a, s, f) {
      var v = s;
      if (!(t & la) && !(t & Zo)) {
        var _ = f;
        if (s !== null) {
          var E = s;
          e:
            for (; ; ) {
              if (E === null)
                return;
              var x = E.tag;
              if (x === H || x === $) {
                var k = E.stateNode.containerInfo;
                if (zE(k, _))
                  break;
                if (x === $)
                  for (var O = E.return; O !== null; ) {
                    var V = O.tag;
                    if (V === H || V === $) {
                      var B = O.stateNode.containerInfo;
                      if (zE(B, _))
                        return;
                    }
                    O = O.return;
                  }
                for (; k !== null; ) {
                  var ne = Xf(k);
                  if (ne === null)
                    return;
                  var re = ne.tag;
                  if (re === J || re === oe) {
                    E = v = ne;
                    continue e;
                  }
                  k = k.parentNode;
                }
              }
              E = E.return;
            }
        }
      }
      Q(function() {
        return pM(e, t, a, v);
      });
    }
    function fv(e, t, a) {
      return {
        instance: e,
        listener: t,
        currentTarget: a
      };
    }
    function vM(e, t, a, s, f, v) {
      for (var _ = t !== null ? t + "Capture" : null, E = s ? _ : t, x = [], k = e, O = null; k !== null; ) {
        var V = k, B = V.stateNode, ne = V.tag;
        if (ne === J && B !== null && (O = B, E !== null)) {
          var re = ht(k, E);
          re != null && x.push(fv(k, re, O));
        }
        if (f)
          break;
        k = k.return;
      }
      return x;
    }
    function oy(e, t) {
      for (var a = t + "Capture", s = [], f = e; f !== null; ) {
        var v = f, _ = v.stateNode, E = v.tag;
        if (E === J && _ !== null) {
          var x = _, k = ht(f, a);
          k != null && s.unshift(fv(f, k, x));
          var O = ht(f, t);
          O != null && s.push(fv(f, O, x));
        }
        f = f.return;
      }
      return s;
    }
    function Lh(e) {
      if (e === null)
        return null;
      do
        e = e.return;
      while (e && e.tag !== J);
      return e || null;
    }
    function mM(e, t) {
      for (var a = e, s = t, f = 0, v = a; v; v = Lh(v))
        f++;
      for (var _ = 0, E = s; E; E = Lh(E))
        _++;
      for (; f - _ > 0; )
        a = Lh(a), f--;
      for (; _ - f > 0; )
        s = Lh(s), _--;
      for (var x = f; x--; ) {
        if (a === s || s !== null && a === s.alternate)
          return a;
        a = Lh(a), s = Lh(s);
      }
      return null;
    }
    function UE(e, t, a, s, f) {
      for (var v = t._reactName, _ = [], E = a; E !== null && E !== s; ) {
        var x = E, k = x.alternate, O = x.stateNode, V = x.tag;
        if (k !== null && k === s)
          break;
        if (V === J && O !== null) {
          var B = O;
          if (f) {
            var ne = ht(E, v);
            ne != null && _.unshift(fv(E, ne, B));
          } else if (!f) {
            var re = ht(E, v);
            re != null && _.push(fv(E, re, B));
          }
        }
        E = E.return;
      }
      _.length !== 0 && e.push({
        event: t,
        listeners: _
      });
    }
    function yM(e, t, a, s, f) {
      var v = s && f ? mM(s, f) : null;
      s !== null && UE(e, t, s, v, !1), f !== null && a !== null && UE(e, a, f, v, !0);
    }
    function gM(e, t) {
      return e + "__" + (t ? "capture" : "bubble");
    }
    var Co = !1, dv = "dangerouslySetInnerHTML", sy = "suppressContentEditableWarning", Vc = "suppressHydrationWarning", IE = "autoFocus", qf = "children", Kf = "style", uy = "__html", P_, ly, hv, jE, cy, FE, HE;
    P_ = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, ly = function(e, t) {
      cs(e, t), fs(e, t), Od(e, t, {
        registrationNameDependencies: on,
        possibleRegistrationNames: Sr
      });
    }, FE = yn && !document.documentMode, hv = function(e, t, a) {
      if (!Co) {
        var s = fy(a), f = fy(t);
        f !== s && (Co = !0, C("Prop `%s` did not match. Server: %s Client: %s", e, JSON.stringify(f), JSON.stringify(s)));
      }
    }, jE = function(e) {
      if (!Co) {
        Co = !0;
        var t = [];
        e.forEach(function(a) {
          t.push(a);
        }), C("Extra attributes from the server: %s", t);
      }
    }, cy = function(e, t) {
      t === !1 ? C("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", e, e, e) : C("Expected `%s` listener to be a function, instead got a value of `%s` type.", e, typeof t);
    }, HE = function(e, t) {
      var a = e.namespaceURI === Tr ? e.ownerDocument.createElement(e.tagName) : e.ownerDocument.createElementNS(e.namespaceURI, e.tagName);
      return a.innerHTML = t, a.innerHTML;
    };
    var _M = /\r\n?/g, SM = /\u0000|\uFFFD/g;
    function fy(e) {
      fi(e);
      var t = typeof e == "string" ? e : "" + e;
      return t.replace(_M, `
`).replace(SM, "");
    }
    function dy(e, t, a, s) {
      var f = fy(t), v = fy(e);
      if (v !== f && (s && (Co || (Co = !0, C('Text content did not match. Server: "%s" Client: "%s"', v, f))), a && Ne))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function BE(e) {
      return e.nodeType === ri ? e : e.ownerDocument;
    }
    function wM() {
    }
    function hy(e) {
      e.onclick = wM;
    }
    function EM(e, t, a, s, f) {
      for (var v in s)
        if (s.hasOwnProperty(v)) {
          var _ = s[v];
          if (v === Kf)
            _ && Object.freeze(_), gc(t, _);
          else if (v === dv) {
            var E = _ ? _[uy] : void 0;
            E != null && Ed(t, E);
          } else if (v === qf)
            if (typeof _ == "string") {
              var x = e !== "textarea" || _ !== "";
              x && sa(t, _);
            } else
              typeof _ == "number" && sa(t, "" + _);
          else
            v === sy || v === Vc || v === IE || (on.hasOwnProperty(v) ? _ != null && (typeof _ != "function" && cy(v, _), v === "onScroll" && yr("scroll", t)) : _ != null && Wi(t, v, _, f));
        }
    }
    function TM(e, t, a, s) {
      for (var f = 0; f < t.length; f += 2) {
        var v = t[f], _ = t[f + 1];
        v === Kf ? gc(e, _) : v === dv ? Ed(e, _) : v === qf ? sa(e, _) : Wi(e, v, _, s);
      }
    }
    function CM(e, t, a, s) {
      var f, v = BE(a), _, E = s;
      if (E === Tr && (E = cc(e)), E === Tr) {
        if (f = Wo(e, t), !f && e !== e.toLowerCase() && C("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", e), e === "script") {
          var x = v.createElement("div");
          x.innerHTML = "<script><\/script>";
          var k = x.firstChild;
          _ = x.removeChild(k);
        } else if (typeof t.is == "string")
          _ = v.createElement(e, {
            is: t.is
          });
        else if (_ = v.createElement(e), e === "select") {
          var O = _;
          t.multiple ? O.multiple = !0 : t.size && (O.size = t.size);
        }
      } else
        _ = v.createElementNS(E, e);
      return E === Tr && !f && Object.prototype.toString.call(_) === "[object HTMLUnknownElement]" && !Ie.call(P_, e) && (P_[e] = !0, C("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", e)), _;
    }
    function xM(e, t) {
      return BE(t).createTextNode(e);
    }
    function bM(e, t, a, s) {
      var f = Wo(t, a);
      ly(t, a);
      var v;
      switch (t) {
        case "dialog":
          yr("cancel", e), yr("close", e), v = a;
          break;
        case "iframe":
        case "object":
        case "embed":
          yr("load", e), v = a;
          break;
        case "video":
        case "audio":
          for (var _ = 0; _ < lv.length; _++)
            yr(lv[_], e);
          v = a;
          break;
        case "source":
          yr("error", e), v = a;
          break;
        case "img":
        case "image":
        case "link":
          yr("error", e), yr("load", e), v = a;
          break;
        case "details":
          yr("toggle", e), v = a;
          break;
        case "input":
          A(e, a), v = b(e, a), yr("invalid", e);
          break;
        case "option":
          Xt(e, a), v = a;
          break;
        case "select":
          al(e, a), v = yu(e, a), yr("invalid", e);
          break;
        case "textarea":
          ol(e, a), v = uc(e, a), yr("invalid", e);
          break;
        default:
          v = a;
      }
      switch (dl(t, v), EM(t, e, s, v, f), t) {
        case "input":
          Zi(e), Ce(e, a, !1);
          break;
        case "textarea":
          Zi(e), Sd(e);
          break;
        case "option":
          Fn(e, a);
          break;
        case "select":
          _f(e, a);
          break;
        default:
          typeof v.onClick == "function" && hy(e);
          break;
      }
    }
    function MM(e, t, a, s, f) {
      ly(t, s);
      var v = null, _, E;
      switch (t) {
        case "input":
          _ = b(e, a), E = b(e, s), v = [];
          break;
        case "select":
          _ = yu(e, a), E = yu(e, s), v = [];
          break;
        case "textarea":
          _ = uc(e, a), E = uc(e, s), v = [];
          break;
        default:
          _ = a, E = s, typeof _.onClick != "function" && typeof E.onClick == "function" && hy(e);
          break;
      }
      dl(t, E);
      var x, k, O = null;
      for (x in _)
        if (!(E.hasOwnProperty(x) || !_.hasOwnProperty(x) || _[x] == null))
          if (x === Kf) {
            var V = _[x];
            for (k in V)
              V.hasOwnProperty(k) && (O || (O = {}), O[k] = "");
          } else
            x === dv || x === qf || x === sy || x === Vc || x === IE || (on.hasOwnProperty(x) ? v || (v = []) : (v = v || []).push(x, null));
      for (x in E) {
        var B = E[x], ne = _ != null ? _[x] : void 0;
        if (!(!E.hasOwnProperty(x) || B === ne || B == null && ne == null))
          if (x === Kf)
            if (B && Object.freeze(B), ne) {
              for (k in ne)
                ne.hasOwnProperty(k) && (!B || !B.hasOwnProperty(k)) && (O || (O = {}), O[k] = "");
              for (k in B)
                B.hasOwnProperty(k) && ne[k] !== B[k] && (O || (O = {}), O[k] = B[k]);
            } else
              O || (v || (v = []), v.push(x, O)), O = B;
          else if (x === dv) {
            var re = B ? B[uy] : void 0, de = ne ? ne[uy] : void 0;
            re != null && de !== re && (v = v || []).push(x, re);
          } else
            x === qf ? (typeof B == "string" || typeof B == "number") && (v = v || []).push(x, "" + B) : x === sy || x === Vc || (on.hasOwnProperty(x) ? (B != null && (typeof B != "function" && cy(x, B), x === "onScroll" && yr("scroll", e)), !v && ne !== B && (v = [])) : (v = v || []).push(x, B));
      }
      return O && (ls(O, E[Kf]), (v = v || []).push(Kf, O)), v;
    }
    function RM(e, t, a, s, f) {
      a === "input" && f.type === "radio" && f.name != null && te(e, f);
      var v = Wo(a, s), _ = Wo(a, f);
      switch (TM(e, t, v, _), a) {
        case "input":
          fe(e, f);
          break;
        case "textarea":
          ss(e, f);
          break;
        case "select":
          Sf(e, f);
          break;
      }
    }
    function DM(e) {
      {
        var t = e.toLowerCase();
        return $i.hasOwnProperty(t) && $i[t] || null;
      }
    }
    function kM(e, t, a, s, f, v, _) {
      var E, x;
      switch (E = Wo(t, a), ly(t, a), t) {
        case "dialog":
          yr("cancel", e), yr("close", e);
          break;
        case "iframe":
        case "object":
        case "embed":
          yr("load", e);
          break;
        case "video":
        case "audio":
          for (var k = 0; k < lv.length; k++)
            yr(lv[k], e);
          break;
        case "source":
          yr("error", e);
          break;
        case "img":
        case "image":
        case "link":
          yr("error", e), yr("load", e);
          break;
        case "details":
          yr("toggle", e);
          break;
        case "input":
          A(e, a), yr("invalid", e);
          break;
        case "option":
          Xt(e, a);
          break;
        case "select":
          al(e, a), yr("invalid", e);
          break;
        case "textarea":
          ol(e, a), yr("invalid", e);
          break;
      }
      dl(t, a);
      {
        x = /* @__PURE__ */ new Set();
        for (var O = e.attributes, V = 0; V < O.length; V++) {
          var B = O[V].name.toLowerCase();
          switch (B) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              x.add(O[V].name);
          }
        }
      }
      var ne = null;
      for (var re in a)
        if (a.hasOwnProperty(re)) {
          var de = a[re];
          if (re === qf)
            typeof de == "string" ? e.textContent !== de && (a[Vc] !== !0 && dy(e.textContent, de, v, _), ne = [qf, de]) : typeof de == "number" && e.textContent !== "" + de && (a[Vc] !== !0 && dy(e.textContent, de, v, _), ne = [qf, "" + de]);
          else if (on.hasOwnProperty(re))
            de != null && (typeof de != "function" && cy(re, de), re === "onScroll" && yr("scroll", e));
          else if (_ && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof E == "boolean") {
            var Ge = void 0, wt = E && et ? null : ti(re);
            if (a[Vc] !== !0) {
              if (!(re === sy || re === Vc || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              re === "value" || re === "checked" || re === "selected")) {
                if (re === dv) {
                  var dt = e.innerHTML, vn = de ? de[uy] : void 0;
                  if (vn != null) {
                    var ln = HE(e, vn);
                    ln !== dt && hv(re, dt, ln);
                  }
                } else if (re === Kf) {
                  if (x.delete(re), FE) {
                    var K = yc(de);
                    Ge = e.getAttribute("style"), K !== Ge && hv(re, Ge, K);
                  }
                } else if (E && !et)
                  x.delete(re.toLowerCase()), Ge = Ka(e, re, de), de !== Ge && hv(re, Ge, de);
                else if (!Un(re, wt, E) && !bn(re, de, wt, E)) {
                  var he = !1;
                  if (wt !== null)
                    x.delete(wt.attributeName), Ge = Vi(e, re, de, wt);
                  else {
                    var X = s;
                    if (X === Tr && (X = cc(t)), X === Tr)
                      x.delete(re.toLowerCase());
                    else {
                      var Te = DM(re);
                      Te !== null && Te !== re && (he = !0, x.delete(Te)), x.delete(re);
                    }
                    Ge = Ka(e, re, de);
                  }
                  var Qe = et;
                  !Qe && de !== Ge && !he && hv(re, Ge, de);
                }
              }
            }
          }
        }
      switch (_ && // $FlowFixMe - Should be inferred as not undefined.
      x.size > 0 && a[Vc] !== !0 && jE(x), t) {
        case "input":
          Zi(e), Ce(e, a, !0);
          break;
        case "textarea":
          Zi(e), Sd(e);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof a.onClick == "function" && hy(e);
          break;
      }
      return ne;
    }
    function OM(e, t, a) {
      var s = e.nodeValue !== t;
      return s;
    }
    function A_(e, t) {
      {
        if (Co)
          return;
        Co = !0, C("Did not expect server HTML to contain a <%s> in <%s>.", t.nodeName.toLowerCase(), e.nodeName.toLowerCase());
      }
    }
    function z_(e, t) {
      {
        if (Co)
          return;
        Co = !0, C('Did not expect server HTML to contain the text node "%s" in <%s>.', t.nodeValue, e.nodeName.toLowerCase());
      }
    }
    function U_(e, t, a) {
      {
        if (Co)
          return;
        Co = !0, C("Expected server HTML to contain a matching <%s> in <%s>.", t, e.nodeName.toLowerCase());
      }
    }
    function I_(e, t) {
      {
        if (t === "" || Co)
          return;
        Co = !0, C('Expected server HTML to contain a matching text node for "%s" in <%s>.', t, e.nodeName.toLowerCase());
      }
    }
    function LM(e, t, a) {
      switch (t) {
        case "input":
          St(e, a);
          return;
        case "textarea":
          Us(e, a);
          return;
        case "select":
          gp(e, a);
          return;
      }
    }
    var pv = function() {
    }, vv = function() {
    };
    {
      var NM = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], YE = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], PM = YE.concat(["button"]), AM = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], VE = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      vv = function(e, t) {
        var a = Gt({}, e || VE), s = {
          tag: t
        };
        return YE.indexOf(t) !== -1 && (a.aTagInScope = null, a.buttonTagInScope = null, a.nobrTagInScope = null), PM.indexOf(t) !== -1 && (a.pTagInButtonScope = null), NM.indexOf(t) !== -1 && t !== "address" && t !== "div" && t !== "p" && (a.listItemTagAutoclosing = null, a.dlItemTagAutoclosing = null), a.current = s, t === "form" && (a.formTag = s), t === "a" && (a.aTagInScope = s), t === "button" && (a.buttonTagInScope = s), t === "nobr" && (a.nobrTagInScope = s), t === "p" && (a.pTagInButtonScope = s), t === "li" && (a.listItemTagAutoclosing = s), (t === "dd" || t === "dt") && (a.dlItemTagAutoclosing = s), a;
      };
      var zM = function(e, t) {
        switch (t) {
          case "select":
            return e === "option" || e === "optgroup" || e === "#text";
          case "optgroup":
            return e === "option" || e === "#text";
          case "option":
            return e === "#text";
          case "tr":
            return e === "th" || e === "td" || e === "style" || e === "script" || e === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return e === "tr" || e === "style" || e === "script" || e === "template";
          case "colgroup":
            return e === "col" || e === "template";
          case "table":
            return e === "caption" || e === "colgroup" || e === "tbody" || e === "tfoot" || e === "thead" || e === "style" || e === "script" || e === "template";
          case "head":
            return e === "base" || e === "basefont" || e === "bgsound" || e === "link" || e === "meta" || e === "title" || e === "noscript" || e === "noframes" || e === "style" || e === "script" || e === "template";
          case "html":
            return e === "head" || e === "body" || e === "frameset";
          case "frameset":
            return e === "frame";
          case "#document":
            return e === "html";
        }
        switch (e) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return t !== "h1" && t !== "h2" && t !== "h3" && t !== "h4" && t !== "h5" && t !== "h6";
          case "rp":
          case "rt":
            return AM.indexOf(t) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return t == null;
        }
        return !0;
      }, UM = function(e, t) {
        switch (e) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return t.pTagInButtonScope;
          case "form":
            return t.formTag || t.pTagInButtonScope;
          case "li":
            return t.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return t.dlItemTagAutoclosing;
          case "button":
            return t.buttonTagInScope;
          case "a":
            return t.aTagInScope;
          case "nobr":
            return t.nobrTagInScope;
        }
        return null;
      }, WE = {};
      pv = function(e, t, a) {
        a = a || VE;
        var s = a.current, f = s && s.tag;
        t != null && (e != null && C("validateDOMNesting: when childText is passed, childTag should be null"), e = "#text");
        var v = zM(e, f) ? null : s, _ = v ? null : UM(e, a), E = v || _;
        if (E) {
          var x = E.tag, k = !!v + "|" + e + "|" + x;
          if (!WE[k]) {
            WE[k] = !0;
            var O = e, V = "";
            if (e === "#text" ? /\S/.test(t) ? O = "Text nodes" : (O = "Whitespace text nodes", V = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : O = "<" + e + ">", v) {
              var B = "";
              x === "table" && e === "tr" && (B += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), C("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", O, x, V, B);
            } else
              C("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", O, x);
          }
        }
      };
    }
    var py = "suppressHydrationWarning", vy = "$", my = "/$", mv = "$?", yv = "$!", IM = "style", j_ = null, F_ = null;
    function jM(e) {
      var t, a, s = e.nodeType;
      switch (s) {
        case ri:
        case Is: {
          t = s === ri ? "#document" : "#fragment";
          var f = e.documentElement;
          a = f ? f.namespaceURI : sl(null, "");
          break;
        }
        default: {
          var v = s === En ? e.parentNode : e, _ = v.namespaceURI || null;
          t = v.tagName, a = sl(_, t);
          break;
        }
      }
      {
        var E = t.toLowerCase(), x = vv(null, E);
        return {
          namespace: a,
          ancestorInfo: x
        };
      }
    }
    function FM(e, t, a) {
      {
        var s = e, f = sl(s.namespace, t), v = vv(s.ancestorInfo, t);
        return {
          namespace: f,
          ancestorInfo: v
        };
      }
    }
    function K2(e) {
      return e;
    }
    function HM(e) {
      j_ = Ya(), F_ = tM();
      var t = null;
      return ui(!1), t;
    }
    function BM(e) {
      nM(F_), ui(j_), j_ = null, F_ = null;
    }
    function YM(e, t, a, s, f) {
      var v;
      {
        var _ = s;
        if (pv(e, null, _.ancestorInfo), typeof t.children == "string" || typeof t.children == "number") {
          var E = "" + t.children, x = vv(_.ancestorInfo, e);
          pv(null, E, x);
        }
        v = _.namespace;
      }
      var k = CM(e, t, a, v);
      return Sv(f, k), G_(k, t), k;
    }
    function VM(e, t) {
      e.appendChild(t);
    }
    function WM(e, t, a, s, f) {
      switch (bM(e, t, a, s), t) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!a.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function ZM(e, t, a, s, f, v) {
      {
        var _ = v;
        if (typeof s.children != typeof a.children && (typeof s.children == "string" || typeof s.children == "number")) {
          var E = "" + s.children, x = vv(_.ancestorInfo, t);
          pv(null, E, x);
        }
      }
      return MM(e, t, a, s);
    }
    function H_(e, t) {
      return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null;
    }
    function $M(e, t, a, s) {
      {
        var f = a;
        pv(null, e, f.ancestorInfo);
      }
      var v = xM(e, t);
      return Sv(s, v), v;
    }
    function GM() {
      var e = window.event;
      return e === void 0 ? $s : Gi(e.type);
    }
    var B_ = typeof setTimeout == "function" ? setTimeout : void 0, QM = typeof clearTimeout == "function" ? clearTimeout : void 0, Y_ = -1, ZE = typeof Promise == "function" ? Promise : void 0, qM = typeof queueMicrotask == "function" ? queueMicrotask : typeof ZE < "u" ? function(e) {
      return ZE.resolve(null).then(e).catch(KM);
    } : B_;
    function KM(e) {
      setTimeout(function() {
        throw e;
      });
    }
    function XM(e, t, a, s) {
      switch (t) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          a.autoFocus && e.focus();
          return;
        case "img": {
          a.src && (e.src = a.src);
          return;
        }
      }
    }
    function JM(e, t, a, s, f, v) {
      RM(e, t, a, s, f), G_(e, f);
    }
    function $E(e) {
      sa(e, "");
    }
    function eR(e, t, a) {
      e.nodeValue = a;
    }
    function tR(e, t) {
      e.appendChild(t);
    }
    function nR(e, t) {
      var a;
      e.nodeType === En ? (a = e.parentNode, a.insertBefore(t, e)) : (a = e, a.appendChild(t));
      var s = e._reactRootContainer;
      s == null && a.onclick === null && hy(a);
    }
    function rR(e, t, a) {
      e.insertBefore(t, a);
    }
    function iR(e, t, a) {
      e.nodeType === En ? e.parentNode.insertBefore(t, a) : e.insertBefore(t, a);
    }
    function aR(e, t) {
      e.removeChild(t);
    }
    function oR(e, t) {
      e.nodeType === En ? e.parentNode.removeChild(t) : e.removeChild(t);
    }
    function V_(e, t) {
      var a = t, s = 0;
      do {
        var f = a.nextSibling;
        if (e.removeChild(a), f && f.nodeType === En) {
          var v = f.data;
          if (v === my)
            if (s === 0) {
              e.removeChild(f), un(t);
              return;
            } else
              s--;
          else
            (v === vy || v === mv || v === yv) && s++;
        }
        a = f;
      } while (a);
      un(t);
    }
    function sR(e, t) {
      e.nodeType === En ? V_(e.parentNode, t) : e.nodeType === yi && V_(e, t), un(e);
    }
    function uR(e) {
      e = e;
      var t = e.style;
      typeof t.setProperty == "function" ? t.setProperty("display", "none", "important") : t.display = "none";
    }
    function lR(e) {
      e.nodeValue = "";
    }
    function cR(e, t) {
      e = e;
      var a = t[IM], s = a != null && a.hasOwnProperty("display") ? a.display : null;
      e.style.display = ul("display", s);
    }
    function fR(e, t) {
      e.nodeValue = t;
    }
    function dR(e) {
      e.nodeType === yi ? e.textContent = "" : e.nodeType === ri && e.documentElement && e.removeChild(e.documentElement);
    }
    function hR(e, t, a) {
      return e.nodeType !== yi || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e;
    }
    function pR(e, t) {
      return t === "" || e.nodeType !== Yo ? null : e;
    }
    function vR(e) {
      return e.nodeType !== En ? null : e;
    }
    function GE(e) {
      return e.data === mv;
    }
    function W_(e) {
      return e.data === yv;
    }
    function mR(e) {
      var t = e.nextSibling && e.nextSibling.dataset, a, s, f;
      return t && (a = t.dgst, s = t.msg, f = t.stck), {
        message: s,
        digest: a,
        stack: f
      };
    }
    function yR(e, t) {
      e._reactRetry = t;
    }
    function yy(e) {
      for (; e != null; e = e.nextSibling) {
        var t = e.nodeType;
        if (t === yi || t === Yo)
          break;
        if (t === En) {
          var a = e.data;
          if (a === vy || a === yv || a === mv)
            break;
          if (a === my)
            return null;
        }
      }
      return e;
    }
    function gv(e) {
      return yy(e.nextSibling);
    }
    function gR(e) {
      return yy(e.firstChild);
    }
    function _R(e) {
      return yy(e.firstChild);
    }
    function SR(e) {
      return yy(e.nextSibling);
    }
    function wR(e, t, a, s, f, v, _) {
      Sv(v, e), G_(e, a);
      var E;
      {
        var x = f;
        E = x.namespace;
      }
      var k = (v.mode & Jt) !== Tt;
      return kM(e, t, a, E, s, k, _);
    }
    function ER(e, t, a, s) {
      return Sv(a, e), a.mode & Jt, OM(e, t);
    }
    function TR(e, t) {
      Sv(t, e);
    }
    function CR(e) {
      for (var t = e.nextSibling, a = 0; t; ) {
        if (t.nodeType === En) {
          var s = t.data;
          if (s === my) {
            if (a === 0)
              return gv(t);
            a--;
          } else
            (s === vy || s === yv || s === mv) && a++;
        }
        t = t.nextSibling;
      }
      return null;
    }
    function QE(e) {
      for (var t = e.previousSibling, a = 0; t; ) {
        if (t.nodeType === En) {
          var s = t.data;
          if (s === vy || s === yv || s === mv) {
            if (a === 0)
              return t;
            a--;
          } else
            s === my && a++;
        }
        t = t.previousSibling;
      }
      return null;
    }
    function xR(e) {
      un(e);
    }
    function bR(e) {
      un(e);
    }
    function MR(e) {
      return e !== "head" && e !== "body";
    }
    function RR(e, t, a, s) {
      var f = !0;
      dy(t.nodeValue, a, s, f);
    }
    function DR(e, t, a, s, f, v) {
      if (t[py] !== !0) {
        var _ = !0;
        dy(s.nodeValue, f, v, _);
      }
    }
    function kR(e, t) {
      t.nodeType === yi ? A_(e, t) : t.nodeType === En || z_(e, t);
    }
    function OR(e, t) {
      {
        var a = e.parentNode;
        a !== null && (t.nodeType === yi ? A_(a, t) : t.nodeType === En || z_(a, t));
      }
    }
    function LR(e, t, a, s, f) {
      (f || t[py] !== !0) && (s.nodeType === yi ? A_(a, s) : s.nodeType === En || z_(a, s));
    }
    function NR(e, t, a) {
      U_(e, t);
    }
    function PR(e, t) {
      I_(e, t);
    }
    function AR(e, t, a) {
      {
        var s = e.parentNode;
        s !== null && U_(s, t);
      }
    }
    function zR(e, t) {
      {
        var a = e.parentNode;
        a !== null && I_(a, t);
      }
    }
    function UR(e, t, a, s, f, v) {
      (v || t[py] !== !0) && U_(a, s);
    }
    function IR(e, t, a, s, f) {
      (f || t[py] !== !0) && I_(a, s);
    }
    function jR(e) {
      C("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", e.nodeName.toLowerCase());
    }
    function FR(e) {
      cv(e);
    }
    var Nh = Math.random().toString(36).slice(2), Ph = "__reactFiber$" + Nh, Z_ = "__reactProps$" + Nh, _v = "__reactContainer$" + Nh, $_ = "__reactEvents$" + Nh, HR = "__reactListeners$" + Nh, BR = "__reactHandles$" + Nh;
    function YR(e) {
      delete e[Ph], delete e[Z_], delete e[$_], delete e[HR], delete e[BR];
    }
    function Sv(e, t) {
      t[Ph] = e;
    }
    function gy(e, t) {
      t[_v] = e;
    }
    function qE(e) {
      e[_v] = null;
    }
    function wv(e) {
      return !!e[_v];
    }
    function Xf(e) {
      var t = e[Ph];
      if (t)
        return t;
      for (var a = e.parentNode; a; ) {
        if (t = a[_v] || a[Ph], t) {
          var s = t.alternate;
          if (t.child !== null || s !== null && s.child !== null)
            for (var f = QE(e); f !== null; ) {
              var v = f[Ph];
              if (v)
                return v;
              f = QE(f);
            }
          return t;
        }
        e = a, a = e.parentNode;
      }
      return null;
    }
    function Wc(e) {
      var t = e[Ph] || e[_v];
      return t && (t.tag === J || t.tag === oe || t.tag === G || t.tag === H) ? t : null;
    }
    function Ah(e) {
      if (e.tag === J || e.tag === oe)
        return e.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function _y(e) {
      return e[Z_] || null;
    }
    function G_(e, t) {
      e[Z_] = t;
    }
    function VR(e) {
      var t = e[$_];
      return t === void 0 && (t = e[$_] = /* @__PURE__ */ new Set()), t;
    }
    var KE = {}, XE = d.ReactDebugCurrentFrame;
    function Sy(e) {
      if (e) {
        var t = e._owner, a = ni(e.type, e._source, t ? t.type : null);
        XE.setExtraStackFrame(a);
      } else
        XE.setExtraStackFrame(null);
    }
    function Xs(e, t, a, s, f) {
      {
        var v = Function.call.bind(Ie);
        for (var _ in e)
          if (v(e, _)) {
            var E = void 0;
            try {
              if (typeof e[_] != "function") {
                var x = Error((s || "React class") + ": " + a + " type `" + _ + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e[_] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw x.name = "Invariant Violation", x;
              }
              E = e[_](t, _, s, a, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (k) {
              E = k;
            }
            E && !(E instanceof Error) && (Sy(f), C("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", s || "React class", a, _, typeof E), Sy(null)), E instanceof Error && !(E.message in KE) && (KE[E.message] = !0, Sy(f), C("Failed %s type: %s", a, E.message), Sy(null));
          }
      }
    }
    var Q_ = [], wy;
    wy = [];
    var jl = -1;
    function Zc(e) {
      return {
        current: e
      };
    }
    function _a(e, t) {
      if (jl < 0) {
        C("Unexpected pop.");
        return;
      }
      t !== wy[jl] && C("Unexpected Fiber popped."), e.current = Q_[jl], Q_[jl] = null, wy[jl] = null, jl--;
    }
    function Sa(e, t, a) {
      jl++, Q_[jl] = e.current, wy[jl] = a, e.current = t;
    }
    var q_;
    q_ = {};
    var qo = {};
    Object.freeze(qo);
    var Fl = Zc(qo), Vu = Zc(!1), K_ = qo;
    function zh(e, t, a) {
      return a && Wu(t) ? K_ : Fl.current;
    }
    function JE(e, t, a) {
      {
        var s = e.stateNode;
        s.__reactInternalMemoizedUnmaskedChildContext = t, s.__reactInternalMemoizedMaskedChildContext = a;
      }
    }
    function Uh(e, t) {
      {
        var a = e.type, s = a.contextTypes;
        if (!s)
          return qo;
        var f = e.stateNode;
        if (f && f.__reactInternalMemoizedUnmaskedChildContext === t)
          return f.__reactInternalMemoizedMaskedChildContext;
        var v = {};
        for (var _ in s)
          v[_] = t[_];
        {
          var E = Ot(e) || "Unknown";
          Xs(s, v, "context", E);
        }
        return f && JE(e, t, v), v;
      }
    }
    function Ey() {
      return Vu.current;
    }
    function Wu(e) {
      {
        var t = e.childContextTypes;
        return t != null;
      }
    }
    function Ty(e) {
      _a(Vu, e), _a(Fl, e);
    }
    function X_(e) {
      _a(Vu, e), _a(Fl, e);
    }
    function eT(e, t, a) {
      {
        if (Fl.current !== qo)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Sa(Fl, t, e), Sa(Vu, a, e);
      }
    }
    function tT(e, t, a) {
      {
        var s = e.stateNode, f = t.childContextTypes;
        if (typeof s.getChildContext != "function") {
          {
            var v = Ot(e) || "Unknown";
            q_[v] || (q_[v] = !0, C("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", v, v));
          }
          return a;
        }
        var _ = s.getChildContext();
        for (var E in _)
          if (!(E in f))
            throw new Error((Ot(e) || "Unknown") + '.getChildContext(): key "' + E + '" is not defined in childContextTypes.');
        {
          var x = Ot(e) || "Unknown";
          Xs(f, _, "child context", x);
        }
        return Gt({}, a, _);
      }
    }
    function Cy(e) {
      {
        var t = e.stateNode, a = t && t.__reactInternalMemoizedMergedChildContext || qo;
        return K_ = Fl.current, Sa(Fl, a, e), Sa(Vu, Vu.current, e), !0;
      }
    }
    function nT(e, t, a) {
      {
        var s = e.stateNode;
        if (!s)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (a) {
          var f = tT(e, t, K_);
          s.__reactInternalMemoizedMergedChildContext = f, _a(Vu, e), _a(Fl, e), Sa(Fl, f, e), Sa(Vu, a, e);
        } else
          _a(Vu, e), Sa(Vu, a, e);
      }
    }
    function WR(e) {
      {
        if (!Cp(e) || e.tag !== j)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var t = e;
        do {
          switch (t.tag) {
            case H:
              return t.stateNode.context;
            case j: {
              var a = t.type;
              if (Wu(a))
                return t.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          t = t.return;
        } while (t !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var $c = 0, xy = 1, Hl = null, J_ = !1, e0 = !1;
    function rT(e) {
      Hl === null ? Hl = [e] : Hl.push(e);
    }
    function ZR(e) {
      J_ = !0, rT(e);
    }
    function iT() {
      J_ && Gc();
    }
    function Gc() {
      if (!e0 && Hl !== null) {
        e0 = !0;
        var e = 0, t = So();
        try {
          var a = !0, s = Hl;
          for ($r(zi); e < s.length; e++) {
            var f = s[e];
            do
              f = f(a);
            while (f !== null);
          }
          Hl = null, J_ = !1;
        } catch (v) {
          throw Hl !== null && (Hl = Hl.slice(e + 1)), Id(Fd, Gc), v;
        } finally {
          $r(t), e0 = !1;
        }
      }
      return null;
    }
    var Ih = [], jh = 0, by = null, My = 0, Es = [], Ts = 0, Jf = null, Bl = 1, Yl = "";
    function $R(e) {
      return td(), (e.flags & wp) !== pt;
    }
    function GR(e) {
      return td(), My;
    }
    function QR() {
      var e = Yl, t = Bl, a = t & ~qR(t);
      return a.toString(32) + e;
    }
    function ed(e, t) {
      td(), Ih[jh++] = My, Ih[jh++] = by, by = e, My = t;
    }
    function aT(e, t, a) {
      td(), Es[Ts++] = Bl, Es[Ts++] = Yl, Es[Ts++] = Jf, Jf = e;
      var s = Bl, f = Yl, v = Ry(s) - 1, _ = s & ~(1 << v), E = a + 1, x = Ry(t) + v;
      if (x > 30) {
        var k = v - v % 5, O = (1 << k) - 1, V = (_ & O).toString(32), B = _ >> k, ne = v - k, re = Ry(t) + ne, de = E << ne, Ge = de | B, wt = V + f;
        Bl = 1 << re | Ge, Yl = wt;
      } else {
        var dt = E << v, vn = dt | _, ln = f;
        Bl = 1 << x | vn, Yl = ln;
      }
    }
    function t0(e) {
      td();
      var t = e.return;
      if (t !== null) {
        var a = 1, s = 0;
        ed(e, a), aT(e, a, s);
      }
    }
    function Ry(e) {
      return 32 - Zd(e);
    }
    function qR(e) {
      return 1 << Ry(e) - 1;
    }
    function n0(e) {
      for (; e === by; )
        by = Ih[--jh], Ih[jh] = null, My = Ih[--jh], Ih[jh] = null;
      for (; e === Jf; )
        Jf = Es[--Ts], Es[Ts] = null, Yl = Es[--Ts], Es[Ts] = null, Bl = Es[--Ts], Es[Ts] = null;
    }
    function KR() {
      return td(), Jf !== null ? {
        id: Bl,
        overflow: Yl
      } : null;
    }
    function XR(e, t) {
      td(), Es[Ts++] = Bl, Es[Ts++] = Yl, Es[Ts++] = Jf, Bl = t.id, Yl = t.overflow, Jf = e;
    }
    function td() {
      qi() || C("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Qi = null, Cs = null, Js = !1, nd = !1, Qc = null;
    function JR() {
      Js && C("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function oT() {
      nd = !0;
    }
    function eD() {
      return nd;
    }
    function tD(e) {
      var t = e.stateNode.containerInfo;
      return Cs = _R(t), Qi = e, Js = !0, Qc = null, nd = !1, !0;
    }
    function nD(e, t, a) {
      return Cs = SR(t), Qi = e, Js = !0, Qc = null, nd = !1, a !== null && XR(e, a), !0;
    }
    function sT(e, t) {
      switch (e.tag) {
        case H: {
          kR(e.stateNode.containerInfo, t);
          break;
        }
        case J: {
          var a = (e.mode & Jt) !== Tt;
          LR(
            e.type,
            e.memoizedProps,
            e.stateNode,
            t,
            // TODO: Delete this argument when we remove the legacy root API.
            a
          );
          break;
        }
        case G: {
          var s = e.memoizedState;
          s.dehydrated !== null && OR(s.dehydrated, t);
          break;
        }
      }
    }
    function uT(e, t) {
      sT(e, t);
      var a = aL();
      a.stateNode = t, a.return = e;
      var s = e.deletions;
      s === null ? (e.deletions = [a], e.flags |= Rn) : s.push(a);
    }
    function r0(e, t) {
      {
        if (nd)
          return;
        switch (e.tag) {
          case H: {
            var a = e.stateNode.containerInfo;
            switch (t.tag) {
              case J:
                var s = t.type;
                t.pendingProps, NR(a, s);
                break;
              case oe:
                var f = t.pendingProps;
                PR(a, f);
                break;
            }
            break;
          }
          case J: {
            var v = e.type, _ = e.memoizedProps, E = e.stateNode;
            switch (t.tag) {
              case J: {
                var x = t.type, k = t.pendingProps, O = (e.mode & Jt) !== Tt;
                UR(
                  v,
                  _,
                  E,
                  x,
                  k,
                  // TODO: Delete this argument when we remove the legacy root API.
                  O
                );
                break;
              }
              case oe: {
                var V = t.pendingProps, B = (e.mode & Jt) !== Tt;
                IR(
                  v,
                  _,
                  E,
                  V,
                  // TODO: Delete this argument when we remove the legacy root API.
                  B
                );
                break;
              }
            }
            break;
          }
          case G: {
            var ne = e.memoizedState, re = ne.dehydrated;
            if (re !== null)
              switch (t.tag) {
                case J:
                  var de = t.type;
                  t.pendingProps, AR(re, de);
                  break;
                case oe:
                  var Ge = t.pendingProps;
                  zR(re, Ge);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function lT(e, t) {
      t.flags = t.flags & ~vo | rr, r0(e, t);
    }
    function cT(e, t) {
      switch (e.tag) {
        case J: {
          var a = e.type;
          e.pendingProps;
          var s = hR(t, a);
          return s !== null ? (e.stateNode = s, Qi = e, Cs = gR(s), !0) : !1;
        }
        case oe: {
          var f = e.pendingProps, v = pR(t, f);
          return v !== null ? (e.stateNode = v, Qi = e, Cs = null, !0) : !1;
        }
        case G: {
          var _ = vR(t);
          if (_ !== null) {
            var E = {
              dehydrated: _,
              treeContext: KR(),
              retryLane: ya
            };
            e.memoizedState = E;
            var x = oL(_);
            return x.return = e, e.child = x, Qi = e, Cs = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function i0(e) {
      return (e.mode & Jt) !== Tt && (e.flags & At) === pt;
    }
    function a0(e) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function o0(e) {
      if (Js) {
        var t = Cs;
        if (!t) {
          i0(e) && (r0(Qi, e), a0()), lT(Qi, e), Js = !1, Qi = e;
          return;
        }
        var a = t;
        if (!cT(e, t)) {
          i0(e) && (r0(Qi, e), a0()), t = gv(a);
          var s = Qi;
          if (!t || !cT(e, t)) {
            lT(Qi, e), Js = !1, Qi = e;
            return;
          }
          uT(s, a);
        }
      }
    }
    function rD(e, t, a) {
      var s = e.stateNode, f = !nd, v = wR(s, e.type, e.memoizedProps, t, a, e, f);
      return e.updateQueue = v, v !== null;
    }
    function iD(e) {
      var t = e.stateNode, a = e.memoizedProps, s = ER(t, a, e);
      if (s) {
        var f = Qi;
        if (f !== null)
          switch (f.tag) {
            case H: {
              var v = f.stateNode.containerInfo, _ = (f.mode & Jt) !== Tt;
              RR(
                v,
                t,
                a,
                // TODO: Delete this argument when we remove the legacy root API.
                _
              );
              break;
            }
            case J: {
              var E = f.type, x = f.memoizedProps, k = f.stateNode, O = (f.mode & Jt) !== Tt;
              DR(
                E,
                x,
                k,
                t,
                a,
                // TODO: Delete this argument when we remove the legacy root API.
                O
              );
              break;
            }
          }
      }
      return s;
    }
    function aD(e) {
      var t = e.memoizedState, a = t !== null ? t.dehydrated : null;
      if (!a)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      TR(a, e);
    }
    function oD(e) {
      var t = e.memoizedState, a = t !== null ? t.dehydrated : null;
      if (!a)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return CR(a);
    }
    function fT(e) {
      for (var t = e.return; t !== null && t.tag !== J && t.tag !== H && t.tag !== G; )
        t = t.return;
      Qi = t;
    }
    function Dy(e) {
      if (e !== Qi)
        return !1;
      if (!Js)
        return fT(e), Js = !0, !1;
      if (e.tag !== H && (e.tag !== J || MR(e.type) && !H_(e.type, e.memoizedProps))) {
        var t = Cs;
        if (t)
          if (i0(e))
            dT(e), a0();
          else
            for (; t; )
              uT(e, t), t = gv(t);
      }
      return fT(e), e.tag === G ? Cs = oD(e) : Cs = Qi ? gv(e.stateNode) : null, !0;
    }
    function sD() {
      return Js && Cs !== null;
    }
    function dT(e) {
      for (var t = Cs; t; )
        sT(e, t), t = gv(t);
    }
    function Fh() {
      Qi = null, Cs = null, Js = !1, nd = !1;
    }
    function hT() {
      Qc !== null && (sC(Qc), Qc = null);
    }
    function qi() {
      return Js;
    }
    function s0(e) {
      Qc === null ? Qc = [e] : Qc.push(e);
    }
    var uD = d.ReactCurrentBatchConfig, lD = null;
    function cD() {
      return uD.transition;
    }
    var eu = {
      recordUnsafeLifecycleWarnings: function(e, t) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(e, t) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var fD = function(e) {
        for (var t = null, a = e; a !== null; )
          a.mode & vr && (t = a), a = a.return;
        return t;
      }, rd = function(e) {
        var t = [];
        return e.forEach(function(a) {
          t.push(a);
        }), t.sort().join(", ");
      }, Ev = [], Tv = [], Cv = [], xv = [], bv = [], Mv = [], id = /* @__PURE__ */ new Set();
      eu.recordUnsafeLifecycleWarnings = function(e, t) {
        id.has(e.type) || (typeof t.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        t.componentWillMount.__suppressDeprecationWarning !== !0 && Ev.push(e), e.mode & vr && typeof t.UNSAFE_componentWillMount == "function" && Tv.push(e), typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Cv.push(e), e.mode & vr && typeof t.UNSAFE_componentWillReceiveProps == "function" && xv.push(e), typeof t.componentWillUpdate == "function" && t.componentWillUpdate.__suppressDeprecationWarning !== !0 && bv.push(e), e.mode & vr && typeof t.UNSAFE_componentWillUpdate == "function" && Mv.push(e));
      }, eu.flushPendingUnsafeLifecycleWarnings = function() {
        var e = /* @__PURE__ */ new Set();
        Ev.length > 0 && (Ev.forEach(function(B) {
          e.add(Ot(B) || "Component"), id.add(B.type);
        }), Ev = []);
        var t = /* @__PURE__ */ new Set();
        Tv.length > 0 && (Tv.forEach(function(B) {
          t.add(Ot(B) || "Component"), id.add(B.type);
        }), Tv = []);
        var a = /* @__PURE__ */ new Set();
        Cv.length > 0 && (Cv.forEach(function(B) {
          a.add(Ot(B) || "Component"), id.add(B.type);
        }), Cv = []);
        var s = /* @__PURE__ */ new Set();
        xv.length > 0 && (xv.forEach(function(B) {
          s.add(Ot(B) || "Component"), id.add(B.type);
        }), xv = []);
        var f = /* @__PURE__ */ new Set();
        bv.length > 0 && (bv.forEach(function(B) {
          f.add(Ot(B) || "Component"), id.add(B.type);
        }), bv = []);
        var v = /* @__PURE__ */ new Set();
        if (Mv.length > 0 && (Mv.forEach(function(B) {
          v.add(Ot(B) || "Component"), id.add(B.type);
        }), Mv = []), t.size > 0) {
          var _ = rd(t);
          C(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, _);
        }
        if (s.size > 0) {
          var E = rd(s);
          C(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, E);
        }
        if (v.size > 0) {
          var x = rd(v);
          C(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, x);
        }
        if (e.size > 0) {
          var k = rd(e);
          M(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, k);
        }
        if (a.size > 0) {
          var O = rd(a);
          M(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, O);
        }
        if (f.size > 0) {
          var V = rd(f);
          M(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, V);
        }
      };
      var ky = /* @__PURE__ */ new Map(), pT = /* @__PURE__ */ new Set();
      eu.recordLegacyContextWarning = function(e, t) {
        var a = fD(e);
        if (a === null) {
          C("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!pT.has(e.type)) {
          var s = ky.get(a);
          (e.type.contextTypes != null || e.type.childContextTypes != null || t !== null && typeof t.getChildContext == "function") && (s === void 0 && (s = [], ky.set(a, s)), s.push(e));
        }
      }, eu.flushLegacyContextWarning = function() {
        ky.forEach(function(e, t) {
          if (e.length !== 0) {
            var a = e[0], s = /* @__PURE__ */ new Set();
            e.forEach(function(v) {
              s.add(Ot(v) || "Component"), pT.add(v.type);
            });
            var f = rd(s);
            try {
              Qt(a), C(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, f);
            } finally {
              nt();
            }
          }
        });
      }, eu.discardPendingWarnings = function() {
        Ev = [], Tv = [], Cv = [], xv = [], bv = [], Mv = [], ky = /* @__PURE__ */ new Map();
      };
    }
    function tu(e, t) {
      if (e && e.defaultProps) {
        var a = Gt({}, t), s = e.defaultProps;
        for (var f in s)
          a[f] === void 0 && (a[f] = s[f]);
        return a;
      }
      return t;
    }
    var u0 = Zc(null), l0;
    l0 = {};
    var Oy = null, Hh = null, c0 = null, Ly = !1;
    function Ny() {
      Oy = null, Hh = null, c0 = null, Ly = !1;
    }
    function vT() {
      Ly = !0;
    }
    function mT() {
      Ly = !1;
    }
    function yT(e, t, a) {
      Sa(u0, t._currentValue, e), t._currentValue = a, t._currentRenderer !== void 0 && t._currentRenderer !== null && t._currentRenderer !== l0 && C("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), t._currentRenderer = l0;
    }
    function f0(e, t) {
      var a = u0.current;
      _a(u0, t), e._currentValue = a;
    }
    function d0(e, t, a) {
      for (var s = e; s !== null; ) {
        var f = s.alternate;
        if (Rl(s.childLanes, t) ? f !== null && !Rl(f.childLanes, t) && (f.childLanes = Zt(f.childLanes, t)) : (s.childLanes = Zt(s.childLanes, t), f !== null && (f.childLanes = Zt(f.childLanes, t))), s === a)
          break;
        s = s.return;
      }
      s !== a && C("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function dD(e, t, a) {
      hD(e, t, a);
    }
    function hD(e, t, a) {
      var s = e.child;
      for (s !== null && (s.return = e); s !== null; ) {
        var f = void 0, v = s.dependencies;
        if (v !== null) {
          f = s.child;
          for (var _ = v.firstContext; _ !== null; ) {
            if (_.context === t) {
              if (s.tag === j) {
                var E = Zr(a), x = Vl(Jn, E);
                x.tag = Ay;
                var k = s.updateQueue;
                if (k !== null) {
                  var O = k.shared, V = O.pending;
                  V === null ? x.next = x : (x.next = V.next, V.next = x), O.pending = x;
                }
              }
              s.lanes = Zt(s.lanes, a);
              var B = s.alternate;
              B !== null && (B.lanes = Zt(B.lanes, a)), d0(s.return, a, e), v.lanes = Zt(v.lanes, a);
              break;
            }
            _ = _.next;
          }
        } else if (s.tag === He)
          f = s.type === e.type ? null : s.child;
        else if (s.tag === Nt) {
          var ne = s.return;
          if (ne === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          ne.lanes = Zt(ne.lanes, a);
          var re = ne.alternate;
          re !== null && (re.lanes = Zt(re.lanes, a)), d0(ne, a, e), f = s.sibling;
        } else
          f = s.child;
        if (f !== null)
          f.return = s;
        else
          for (f = s; f !== null; ) {
            if (f === e) {
              f = null;
              break;
            }
            var de = f.sibling;
            if (de !== null) {
              de.return = f.return, f = de;
              break;
            }
            f = f.return;
          }
        s = f;
      }
    }
    function Bh(e, t) {
      Oy = e, Hh = null, c0 = null;
      var a = e.dependencies;
      if (a !== null) {
        var s = a.firstContext;
        s !== null && (ga(a.lanes, t) && Hv(), a.firstContext = null);
      }
    }
    function ci(e) {
      Ly && C("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var t = e._currentValue;
      if (c0 !== e) {
        var a = {
          context: e,
          memoizedValue: t,
          next: null
        };
        if (Hh === null) {
          if (Oy === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Hh = a, Oy.dependencies = {
            lanes: pe,
            firstContext: a
          };
        } else
          Hh = Hh.next = a;
      }
      return t;
    }
    var ad = null;
    function h0(e) {
      ad === null ? ad = [e] : ad.push(e);
    }
    function pD() {
      if (ad !== null) {
        for (var e = 0; e < ad.length; e++) {
          var t = ad[e], a = t.interleaved;
          if (a !== null) {
            t.interleaved = null;
            var s = a.next, f = t.pending;
            if (f !== null) {
              var v = f.next;
              f.next = s, a.next = v;
            }
            t.pending = a;
          }
        }
        ad = null;
      }
    }
    function gT(e, t, a, s) {
      var f = t.interleaved;
      return f === null ? (a.next = a, h0(t)) : (a.next = f.next, f.next = a), t.interleaved = a, Py(e, s);
    }
    function vD(e, t, a, s) {
      var f = t.interleaved;
      f === null ? (a.next = a, h0(t)) : (a.next = f.next, f.next = a), t.interleaved = a;
    }
    function mD(e, t, a, s) {
      var f = t.interleaved;
      return f === null ? (a.next = a, h0(t)) : (a.next = f.next, f.next = a), t.interleaved = a, Py(e, s);
    }
    function xo(e, t) {
      return Py(e, t);
    }
    var yD = Py;
    function Py(e, t) {
      e.lanes = Zt(e.lanes, t);
      var a = e.alternate;
      a !== null && (a.lanes = Zt(a.lanes, t)), a === null && (e.flags & (rr | vo)) !== pt && _C(e);
      for (var s = e, f = e.return; f !== null; )
        f.childLanes = Zt(f.childLanes, t), a = f.alternate, a !== null ? a.childLanes = Zt(a.childLanes, t) : (f.flags & (rr | vo)) !== pt && _C(e), s = f, f = f.return;
      if (s.tag === H) {
        var v = s.stateNode;
        return v;
      } else
        return null;
    }
    var _T = 0, ST = 1, Ay = 2, p0 = 3, zy = !1, v0, Uy;
    v0 = !1, Uy = null;
    function m0(e) {
      var t = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: pe
        },
        effects: null
      };
      e.updateQueue = t;
    }
    function wT(e, t) {
      var a = t.updateQueue, s = e.updateQueue;
      if (a === s) {
        var f = {
          baseState: s.baseState,
          firstBaseUpdate: s.firstBaseUpdate,
          lastBaseUpdate: s.lastBaseUpdate,
          shared: s.shared,
          effects: s.effects
        };
        t.updateQueue = f;
      }
    }
    function Vl(e, t) {
      var a = {
        eventTime: e,
        lane: t,
        tag: _T,
        payload: null,
        callback: null,
        next: null
      };
      return a;
    }
    function qc(e, t, a) {
      var s = e.updateQueue;
      if (s === null)
        return null;
      var f = s.shared;
      if (Uy === f && !v0 && (C("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), v0 = !0), yO()) {
        var v = f.pending;
        return v === null ? t.next = t : (t.next = v.next, v.next = t), f.pending = t, yD(e, a);
      } else
        return mD(e, f, t, a);
    }
    function Iy(e, t, a) {
      var s = t.updateQueue;
      if (s !== null) {
        var f = s.shared;
        if (Up(a)) {
          var v = f.lanes;
          v = jp(v, e.pendingLanes);
          var _ = Zt(v, a);
          f.lanes = _, kc(e, _);
        }
      }
    }
    function y0(e, t) {
      var a = e.updateQueue, s = e.alternate;
      if (s !== null) {
        var f = s.updateQueue;
        if (a === f) {
          var v = null, _ = null, E = a.firstBaseUpdate;
          if (E !== null) {
            var x = E;
            do {
              var k = {
                eventTime: x.eventTime,
                lane: x.lane,
                tag: x.tag,
                payload: x.payload,
                callback: x.callback,
                next: null
              };
              _ === null ? v = _ = k : (_.next = k, _ = k), x = x.next;
            } while (x !== null);
            _ === null ? v = _ = t : (_.next = t, _ = t);
          } else
            v = _ = t;
          a = {
            baseState: f.baseState,
            firstBaseUpdate: v,
            lastBaseUpdate: _,
            shared: f.shared,
            effects: f.effects
          }, e.updateQueue = a;
          return;
        }
      }
      var O = a.lastBaseUpdate;
      O === null ? a.firstBaseUpdate = t : O.next = t, a.lastBaseUpdate = t;
    }
    function gD(e, t, a, s, f, v) {
      switch (a.tag) {
        case ST: {
          var _ = a.payload;
          if (typeof _ == "function") {
            vT();
            var E = _.call(v, s, f);
            {
              if (e.mode & vr) {
                Wr(!0);
                try {
                  _.call(v, s, f);
                } finally {
                  Wr(!1);
                }
              }
              mT();
            }
            return E;
          }
          return _;
        }
        case p0:
          e.flags = e.flags & ~ai | At;
        case _T: {
          var x = a.payload, k;
          if (typeof x == "function") {
            vT(), k = x.call(v, s, f);
            {
              if (e.mode & vr) {
                Wr(!0);
                try {
                  x.call(v, s, f);
                } finally {
                  Wr(!1);
                }
              }
              mT();
            }
          } else
            k = x;
          return k == null ? s : Gt({}, s, k);
        }
        case Ay:
          return zy = !0, s;
      }
      return s;
    }
    function jy(e, t, a, s) {
      var f = e.updateQueue;
      zy = !1, Uy = f.shared;
      var v = f.firstBaseUpdate, _ = f.lastBaseUpdate, E = f.shared.pending;
      if (E !== null) {
        f.shared.pending = null;
        var x = E, k = x.next;
        x.next = null, _ === null ? v = k : _.next = k, _ = x;
        var O = e.alternate;
        if (O !== null) {
          var V = O.updateQueue, B = V.lastBaseUpdate;
          B !== _ && (B === null ? V.firstBaseUpdate = k : B.next = k, V.lastBaseUpdate = x);
        }
      }
      if (v !== null) {
        var ne = f.baseState, re = pe, de = null, Ge = null, wt = null, dt = v;
        do {
          var vn = dt.lane, ln = dt.eventTime;
          if (Rl(s, vn)) {
            if (wt !== null) {
              var he = {
                eventTime: ln,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: hn,
                tag: dt.tag,
                payload: dt.payload,
                callback: dt.callback,
                next: null
              };
              wt = wt.next = he;
            }
            ne = gD(e, f, dt, ne, t, a);
            var X = dt.callback;
            if (X !== null && // If the update was already committed, we should not queue its
            // callback again.
            dt.lane !== hn) {
              e.flags |= ms;
              var Te = f.effects;
              Te === null ? f.effects = [dt] : Te.push(dt);
            }
          } else {
            var K = {
              eventTime: ln,
              lane: vn,
              tag: dt.tag,
              payload: dt.payload,
              callback: dt.callback,
              next: null
            };
            wt === null ? (Ge = wt = K, de = ne) : wt = wt.next = K, re = Zt(re, vn);
          }
          if (dt = dt.next, dt === null) {
            if (E = f.shared.pending, E === null)
              break;
            var Qe = E, Ve = Qe.next;
            Qe.next = null, dt = Ve, f.lastBaseUpdate = Qe, f.shared.pending = null;
          }
        } while (!0);
        wt === null && (de = ne), f.baseState = de, f.firstBaseUpdate = Ge, f.lastBaseUpdate = wt;
        var Lt = f.shared.interleaved;
        if (Lt !== null) {
          var Bt = Lt;
          do
            re = Zt(re, Bt.lane), Bt = Bt.next;
          while (Bt !== Lt);
        } else
          v === null && (f.shared.lanes = pe);
        Jv(re), e.lanes = re, e.memoizedState = ne;
      }
      Uy = null;
    }
    function _D(e, t) {
      if (typeof e != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + e));
      e.call(t);
    }
    function ET() {
      zy = !1;
    }
    function Fy() {
      return zy;
    }
    function TT(e, t, a) {
      var s = t.effects;
      if (t.effects = null, s !== null)
        for (var f = 0; f < s.length; f++) {
          var v = s[f], _ = v.callback;
          _ !== null && (v.callback = null, _D(_, a));
        }
    }
    var g0 = {}, CT = new o.Component().refs, _0, S0, w0, E0, T0, xT, Hy, C0, x0, b0;
    {
      _0 = /* @__PURE__ */ new Set(), S0 = /* @__PURE__ */ new Set(), w0 = /* @__PURE__ */ new Set(), E0 = /* @__PURE__ */ new Set(), C0 = /* @__PURE__ */ new Set(), T0 = /* @__PURE__ */ new Set(), x0 = /* @__PURE__ */ new Set(), b0 = /* @__PURE__ */ new Set();
      var bT = /* @__PURE__ */ new Set();
      Hy = function(e, t) {
        if (!(e === null || typeof e == "function")) {
          var a = t + "_" + e;
          bT.has(a) || (bT.add(a), C("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", t, e));
        }
      }, xT = function(e, t) {
        if (t === void 0) {
          var a = rn(e) || "Component";
          T0.has(a) || (T0.add(a), C("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", a));
        }
      }, Object.defineProperty(g0, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(g0);
    }
    function M0(e, t, a, s) {
      var f = e.memoizedState, v = a(s, f);
      {
        if (e.mode & vr) {
          Wr(!0);
          try {
            v = a(s, f);
          } finally {
            Wr(!1);
          }
        }
        xT(t, v);
      }
      var _ = v == null ? f : Gt({}, f, v);
      if (e.memoizedState = _, e.lanes === pe) {
        var E = e.updateQueue;
        E.baseState = _;
      }
    }
    var R0 = {
      isMounted: Fa,
      enqueueSetState: function(e, t, a) {
        var s = ca(e), f = Za(), v = af(s), _ = Vl(f, v);
        _.payload = t, a != null && (Hy(a, "setState"), _.callback = a);
        var E = qc(s, _, v);
        E !== null && (Ri(E, s, v, f), Iy(E, s, v)), Au(s, v);
      },
      enqueueReplaceState: function(e, t, a) {
        var s = ca(e), f = Za(), v = af(s), _ = Vl(f, v);
        _.tag = ST, _.payload = t, a != null && (Hy(a, "replaceState"), _.callback = a);
        var E = qc(s, _, v);
        E !== null && (Ri(E, s, v, f), Iy(E, s, v)), Au(s, v);
      },
      enqueueForceUpdate: function(e, t) {
        var a = ca(e), s = Za(), f = af(a), v = Vl(s, f);
        v.tag = Ay, t != null && (Hy(t, "forceUpdate"), v.callback = t);
        var _ = qc(a, v, f);
        _ !== null && (Ri(_, a, f, s), Iy(_, a, f)), Np(a, f);
      }
    };
    function MT(e, t, a, s, f, v, _) {
      var E = e.stateNode;
      if (typeof E.shouldComponentUpdate == "function") {
        var x = E.shouldComponentUpdate(s, v, _);
        {
          if (e.mode & vr) {
            Wr(!0);
            try {
              x = E.shouldComponentUpdate(s, v, _);
            } finally {
              Wr(!1);
            }
          }
          x === void 0 && C("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", rn(t) || "Component");
        }
        return x;
      }
      return t.prototype && t.prototype.isPureReactComponent ? !yt(a, s) || !yt(f, v) : !0;
    }
    function SD(e, t, a) {
      var s = e.stateNode;
      {
        var f = rn(t) || "Component", v = s.render;
        v || (t.prototype && typeof t.prototype.render == "function" ? C("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", f) : C("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", f)), s.getInitialState && !s.getInitialState.isReactClassApproved && !s.state && C("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", f), s.getDefaultProps && !s.getDefaultProps.isReactClassApproved && C("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", f), s.propTypes && C("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", f), s.contextType && C("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", f), s.contextTypes && C("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", f), t.contextType && t.contextTypes && !x0.has(t) && (x0.add(t), C("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", f)), typeof s.componentShouldUpdate == "function" && C("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", f), t.prototype && t.prototype.isPureReactComponent && typeof s.shouldComponentUpdate < "u" && C("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", rn(t) || "A pure component"), typeof s.componentDidUnmount == "function" && C("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", f), typeof s.componentDidReceiveProps == "function" && C("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", f), typeof s.componentWillRecieveProps == "function" && C("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", f), typeof s.UNSAFE_componentWillRecieveProps == "function" && C("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", f);
        var _ = s.props !== a;
        s.props !== void 0 && _ && C("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", f, f), s.defaultProps && C("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", f, f), typeof s.getSnapshotBeforeUpdate == "function" && typeof s.componentDidUpdate != "function" && !w0.has(t) && (w0.add(t), C("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", rn(t))), typeof s.getDerivedStateFromProps == "function" && C("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", f), typeof s.getDerivedStateFromError == "function" && C("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", f), typeof t.getSnapshotBeforeUpdate == "function" && C("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", f);
        var E = s.state;
        E && (typeof E != "object" || Ht(E)) && C("%s.state: must be set to an object or null", f), typeof s.getChildContext == "function" && typeof t.childContextTypes != "object" && C("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", f);
      }
    }
    function RT(e, t) {
      t.updater = R0, e.stateNode = t, Bs(t, e), t._reactInternalInstance = g0;
    }
    function DT(e, t, a) {
      var s = !1, f = qo, v = qo, _ = t.contextType;
      if ("contextType" in t) {
        var E = (
          // Allow null for conditional declaration
          _ === null || _ !== void 0 && _.$$typeof === ke && _._context === void 0
        );
        if (!E && !b0.has(t)) {
          b0.add(t);
          var x = "";
          _ === void 0 ? x = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof _ != "object" ? x = " However, it is set to a " + typeof _ + "." : _.$$typeof === _e ? x = " Did you accidentally pass the Context.Provider instead?" : _._context !== void 0 ? x = " Did you accidentally pass the Context.Consumer instead?" : x = " However, it is set to an object with keys {" + Object.keys(_).join(", ") + "}.", C("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", rn(t) || "Component", x);
        }
      }
      if (typeof _ == "object" && _ !== null)
        v = ci(_);
      else {
        f = zh(e, t, !0);
        var k = t.contextTypes;
        s = k != null, v = s ? Uh(e, f) : qo;
      }
      var O = new t(a, v);
      if (e.mode & vr) {
        Wr(!0);
        try {
          O = new t(a, v);
        } finally {
          Wr(!1);
        }
      }
      var V = e.memoizedState = O.state !== null && O.state !== void 0 ? O.state : null;
      RT(e, O);
      {
        if (typeof t.getDerivedStateFromProps == "function" && V === null) {
          var B = rn(t) || "Component";
          S0.has(B) || (S0.add(B), C("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", B, O.state === null ? "null" : "undefined", B));
        }
        if (typeof t.getDerivedStateFromProps == "function" || typeof O.getSnapshotBeforeUpdate == "function") {
          var ne = null, re = null, de = null;
          if (typeof O.componentWillMount == "function" && O.componentWillMount.__suppressDeprecationWarning !== !0 ? ne = "componentWillMount" : typeof O.UNSAFE_componentWillMount == "function" && (ne = "UNSAFE_componentWillMount"), typeof O.componentWillReceiveProps == "function" && O.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? re = "componentWillReceiveProps" : typeof O.UNSAFE_componentWillReceiveProps == "function" && (re = "UNSAFE_componentWillReceiveProps"), typeof O.componentWillUpdate == "function" && O.componentWillUpdate.__suppressDeprecationWarning !== !0 ? de = "componentWillUpdate" : typeof O.UNSAFE_componentWillUpdate == "function" && (de = "UNSAFE_componentWillUpdate"), ne !== null || re !== null || de !== null) {
            var Ge = rn(t) || "Component", wt = typeof t.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            E0.has(Ge) || (E0.add(Ge), C(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Ge, wt, ne !== null ? `
  ` + ne : "", re !== null ? `
  ` + re : "", de !== null ? `
  ` + de : ""));
          }
        }
      }
      return s && JE(e, f, v), O;
    }
    function wD(e, t) {
      var a = t.state;
      typeof t.componentWillMount == "function" && t.componentWillMount(), typeof t.UNSAFE_componentWillMount == "function" && t.UNSAFE_componentWillMount(), a !== t.state && (C("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Ot(e) || "Component"), R0.enqueueReplaceState(t, t.state, null));
    }
    function kT(e, t, a, s) {
      var f = t.state;
      if (typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(a, s), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(a, s), t.state !== f) {
        {
          var v = Ot(e) || "Component";
          _0.has(v) || (_0.add(v), C("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", v));
        }
        R0.enqueueReplaceState(t, t.state, null);
      }
    }
    function D0(e, t, a, s) {
      SD(e, t, a);
      var f = e.stateNode;
      f.props = a, f.state = e.memoizedState, f.refs = CT, m0(e);
      var v = t.contextType;
      if (typeof v == "object" && v !== null)
        f.context = ci(v);
      else {
        var _ = zh(e, t, !0);
        f.context = Uh(e, _);
      }
      {
        if (f.state === a) {
          var E = rn(t) || "Component";
          C0.has(E) || (C0.add(E), C("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", E));
        }
        e.mode & vr && eu.recordLegacyContextWarning(e, f), eu.recordUnsafeLifecycleWarnings(e, f);
      }
      f.state = e.memoizedState;
      var x = t.getDerivedStateFromProps;
      if (typeof x == "function" && (M0(e, t, x, a), f.state = e.memoizedState), typeof t.getDerivedStateFromProps != "function" && typeof f.getSnapshotBeforeUpdate != "function" && (typeof f.UNSAFE_componentWillMount == "function" || typeof f.componentWillMount == "function") && (wD(e, f), jy(e, a, f, s), f.state = e.memoizedState), typeof f.componentDidMount == "function") {
        var k = Wt;
        k |= da, (e.mode & go) !== Tt && (k |= ha), e.flags |= k;
      }
    }
    function ED(e, t, a, s) {
      var f = e.stateNode, v = e.memoizedProps;
      f.props = v;
      var _ = f.context, E = t.contextType, x = qo;
      if (typeof E == "object" && E !== null)
        x = ci(E);
      else {
        var k = zh(e, t, !0);
        x = Uh(e, k);
      }
      var O = t.getDerivedStateFromProps, V = typeof O == "function" || typeof f.getSnapshotBeforeUpdate == "function";
      !V && (typeof f.UNSAFE_componentWillReceiveProps == "function" || typeof f.componentWillReceiveProps == "function") && (v !== a || _ !== x) && kT(e, f, a, x), ET();
      var B = e.memoizedState, ne = f.state = B;
      if (jy(e, a, f, s), ne = e.memoizedState, v === a && B === ne && !Ey() && !Fy()) {
        if (typeof f.componentDidMount == "function") {
          var re = Wt;
          re |= da, (e.mode & go) !== Tt && (re |= ha), e.flags |= re;
        }
        return !1;
      }
      typeof O == "function" && (M0(e, t, O, a), ne = e.memoizedState);
      var de = Fy() || MT(e, t, v, a, B, ne, x);
      if (de) {
        if (!V && (typeof f.UNSAFE_componentWillMount == "function" || typeof f.componentWillMount == "function") && (typeof f.componentWillMount == "function" && f.componentWillMount(), typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount()), typeof f.componentDidMount == "function") {
          var Ge = Wt;
          Ge |= da, (e.mode & go) !== Tt && (Ge |= ha), e.flags |= Ge;
        }
      } else {
        if (typeof f.componentDidMount == "function") {
          var wt = Wt;
          wt |= da, (e.mode & go) !== Tt && (wt |= ha), e.flags |= wt;
        }
        e.memoizedProps = a, e.memoizedState = ne;
      }
      return f.props = a, f.state = ne, f.context = x, de;
    }
    function TD(e, t, a, s, f) {
      var v = t.stateNode;
      wT(e, t);
      var _ = t.memoizedProps, E = t.type === t.elementType ? _ : tu(t.type, _);
      v.props = E;
      var x = t.pendingProps, k = v.context, O = a.contextType, V = qo;
      if (typeof O == "object" && O !== null)
        V = ci(O);
      else {
        var B = zh(t, a, !0);
        V = Uh(t, B);
      }
      var ne = a.getDerivedStateFromProps, re = typeof ne == "function" || typeof v.getSnapshotBeforeUpdate == "function";
      !re && (typeof v.UNSAFE_componentWillReceiveProps == "function" || typeof v.componentWillReceiveProps == "function") && (_ !== x || k !== V) && kT(t, v, s, V), ET();
      var de = t.memoizedState, Ge = v.state = de;
      if (jy(t, s, v, f), Ge = t.memoizedState, _ === x && de === Ge && !Ey() && !Fy() && !Je)
        return typeof v.componentDidUpdate == "function" && (_ !== e.memoizedProps || de !== e.memoizedState) && (t.flags |= Wt), typeof v.getSnapshotBeforeUpdate == "function" && (_ !== e.memoizedProps || de !== e.memoizedState) && (t.flags |= po), !1;
      typeof ne == "function" && (M0(t, a, ne, s), Ge = t.memoizedState);
      var wt = Fy() || MT(t, a, E, s, de, Ge, V) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      Je;
      return wt ? (!re && (typeof v.UNSAFE_componentWillUpdate == "function" || typeof v.componentWillUpdate == "function") && (typeof v.componentWillUpdate == "function" && v.componentWillUpdate(s, Ge, V), typeof v.UNSAFE_componentWillUpdate == "function" && v.UNSAFE_componentWillUpdate(s, Ge, V)), typeof v.componentDidUpdate == "function" && (t.flags |= Wt), typeof v.getSnapshotBeforeUpdate == "function" && (t.flags |= po)) : (typeof v.componentDidUpdate == "function" && (_ !== e.memoizedProps || de !== e.memoizedState) && (t.flags |= Wt), typeof v.getSnapshotBeforeUpdate == "function" && (_ !== e.memoizedProps || de !== e.memoizedState) && (t.flags |= po), t.memoizedProps = s, t.memoizedState = Ge), v.props = s, v.state = Ge, v.context = V, wt;
    }
    var k0, O0, L0, N0, P0, OT = function(e, t) {
    };
    k0 = !1, O0 = !1, L0 = {}, N0 = {}, P0 = {}, OT = function(e, t) {
      if (!(e === null || typeof e != "object") && !(!e._store || e._store.validated || e.key != null)) {
        if (typeof e._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        e._store.validated = !0;
        var a = Ot(t) || "Component";
        N0[a] || (N0[a] = !0, C('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function Rv(e, t, a) {
      var s = a.ref;
      if (s !== null && typeof s != "function" && typeof s != "object") {
        if ((e.mode & vr || je) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(a._owner && a._self && a._owner.stateNode !== a._self)) {
          var f = Ot(e) || "Component";
          L0[f] || (C('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', s), L0[f] = !0);
        }
        if (a._owner) {
          var v = a._owner, _;
          if (v) {
            var E = v;
            if (E.tag !== j)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            _ = E.stateNode;
          }
          if (!_)
            throw new Error("Missing owner for string ref " + s + ". This error is likely caused by a bug in React. Please file an issue.");
          var x = _;
          Dr(s, "ref");
          var k = "" + s;
          if (t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === k)
            return t.ref;
          var O = function(V) {
            var B = x.refs;
            B === CT && (B = x.refs = {}), V === null ? delete B[k] : B[k] = V;
          };
          return O._stringRef = k, O;
        } else {
          if (typeof s != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!a._owner)
            throw new Error("Element ref was specified as a string (" + s + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return s;
    }
    function By(e, t) {
      var a = Object.prototype.toString.call(t);
      throw new Error("Objects are not valid as a React child (found: " + (a === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Yy(e) {
      {
        var t = Ot(e) || "Component";
        if (P0[t])
          return;
        P0[t] = !0, C("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function LT(e) {
      var t = e._payload, a = e._init;
      return a(t);
    }
    function NT(e) {
      function t(K, he) {
        if (e) {
          var X = K.deletions;
          X === null ? (K.deletions = [he], K.flags |= Rn) : X.push(he);
        }
      }
      function a(K, he) {
        if (!e)
          return null;
        for (var X = he; X !== null; )
          t(K, X), X = X.sibling;
        return null;
      }
      function s(K, he) {
        for (var X = /* @__PURE__ */ new Map(), Te = he; Te !== null; )
          Te.key !== null ? X.set(Te.key, Te) : X.set(Te.index, Te), Te = Te.sibling;
        return X;
      }
      function f(K, he) {
        var X = hd(K, he);
        return X.index = 0, X.sibling = null, X;
      }
      function v(K, he, X) {
        if (K.index = X, !e)
          return K.flags |= wp, he;
        var Te = K.alternate;
        if (Te !== null) {
          var Qe = Te.index;
          return Qe < he ? (K.flags |= rr, he) : Qe;
        } else
          return K.flags |= rr, he;
      }
      function _(K) {
        return e && K.alternate === null && (K.flags |= rr), K;
      }
      function E(K, he, X, Te) {
        if (he === null || he.tag !== oe) {
          var Qe = sw(X, K.mode, Te);
          return Qe.return = K, Qe;
        } else {
          var Ve = f(he, X);
          return Ve.return = K, Ve;
        }
      }
      function x(K, he, X, Te) {
        var Qe = X.type;
        if (Qe === We)
          return O(K, he, X.props.children, Te, X.key);
        if (he !== null && (he.elementType === Qe || // Keep this check inline so it only runs on the false path:
        TC(he, X) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof Qe == "object" && Qe !== null && Qe.$$typeof === mt && LT(Qe) === he.type)) {
          var Ve = f(he, X.props);
          return Ve.ref = Rv(K, he, X), Ve.return = K, Ve._debugSource = X._source, Ve._debugOwner = X._owner, Ve;
        }
        var Lt = ow(X, K.mode, Te);
        return Lt.ref = Rv(K, he, X), Lt.return = K, Lt;
      }
      function k(K, he, X, Te) {
        if (he === null || he.tag !== $ || he.stateNode.containerInfo !== X.containerInfo || he.stateNode.implementation !== X.implementation) {
          var Qe = uw(X, K.mode, Te);
          return Qe.return = K, Qe;
        } else {
          var Ve = f(he, X.children || []);
          return Ve.return = K, Ve;
        }
      }
      function O(K, he, X, Te, Qe) {
        if (he === null || he.tag !== ce) {
          var Ve = sf(X, K.mode, Te, Qe);
          return Ve.return = K, Ve;
        } else {
          var Lt = f(he, X);
          return Lt.return = K, Lt;
        }
      }
      function V(K, he, X) {
        if (typeof he == "string" && he !== "" || typeof he == "number") {
          var Te = sw("" + he, K.mode, X);
          return Te.return = K, Te;
        }
        if (typeof he == "object" && he !== null) {
          switch (he.$$typeof) {
            case Xa: {
              var Qe = ow(he, K.mode, X);
              return Qe.ref = Rv(K, null, he), Qe.return = K, Qe;
            }
            case tr: {
              var Ve = uw(he, K.mode, X);
              return Ve.return = K, Ve;
            }
            case mt: {
              var Lt = he._payload, Bt = he._init;
              return V(K, Bt(Lt), X);
            }
          }
          if (Ht(he) || Da(he)) {
            var $n = sf(he, K.mode, X, null);
            return $n.return = K, $n;
          }
          By(K, he);
        }
        return typeof he == "function" && Yy(K), null;
      }
      function B(K, he, X, Te) {
        var Qe = he !== null ? he.key : null;
        if (typeof X == "string" && X !== "" || typeof X == "number")
          return Qe !== null ? null : E(K, he, "" + X, Te);
        if (typeof X == "object" && X !== null) {
          switch (X.$$typeof) {
            case Xa:
              return X.key === Qe ? x(K, he, X, Te) : null;
            case tr:
              return X.key === Qe ? k(K, he, X, Te) : null;
            case mt: {
              var Ve = X._payload, Lt = X._init;
              return B(K, he, Lt(Ve), Te);
            }
          }
          if (Ht(X) || Da(X))
            return Qe !== null ? null : O(K, he, X, Te, null);
          By(K, X);
        }
        return typeof X == "function" && Yy(K), null;
      }
      function ne(K, he, X, Te, Qe) {
        if (typeof Te == "string" && Te !== "" || typeof Te == "number") {
          var Ve = K.get(X) || null;
          return E(he, Ve, "" + Te, Qe);
        }
        if (typeof Te == "object" && Te !== null) {
          switch (Te.$$typeof) {
            case Xa: {
              var Lt = K.get(Te.key === null ? X : Te.key) || null;
              return x(he, Lt, Te, Qe);
            }
            case tr: {
              var Bt = K.get(Te.key === null ? X : Te.key) || null;
              return k(he, Bt, Te, Qe);
            }
            case mt:
              var $n = Te._payload, Tn = Te._init;
              return ne(K, he, X, Tn($n), Qe);
          }
          if (Ht(Te) || Da(Te)) {
            var qr = K.get(X) || null;
            return O(he, qr, Te, Qe, null);
          }
          By(he, Te);
        }
        return typeof Te == "function" && Yy(he), null;
      }
      function re(K, he, X) {
        {
          if (typeof K != "object" || K === null)
            return he;
          switch (K.$$typeof) {
            case Xa:
            case tr:
              OT(K, X);
              var Te = K.key;
              if (typeof Te != "string")
                break;
              if (he === null) {
                he = /* @__PURE__ */ new Set(), he.add(Te);
                break;
              }
              if (!he.has(Te)) {
                he.add(Te);
                break;
              }
              C("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", Te);
              break;
            case mt:
              var Qe = K._payload, Ve = K._init;
              re(Ve(Qe), he, X);
              break;
          }
        }
        return he;
      }
      function de(K, he, X, Te) {
        for (var Qe = null, Ve = 0; Ve < X.length; Ve++) {
          var Lt = X[Ve];
          Qe = re(Lt, Qe, K);
        }
        for (var Bt = null, $n = null, Tn = he, qr = 0, Cn = 0, Fr = null; Tn !== null && Cn < X.length; Cn++) {
          Tn.index > Cn ? (Fr = Tn, Tn = null) : Fr = Tn.sibling;
          var Ea = B(K, Tn, X[Cn], Te);
          if (Ea === null) {
            Tn === null && (Tn = Fr);
            break;
          }
          e && Tn && Ea.alternate === null && t(K, Tn), qr = v(Ea, qr, Cn), $n === null ? Bt = Ea : $n.sibling = Ea, $n = Ea, Tn = Fr;
        }
        if (Cn === X.length) {
          if (a(K, Tn), qi()) {
            var ra = Cn;
            ed(K, ra);
          }
          return Bt;
        }
        if (Tn === null) {
          for (; Cn < X.length; Cn++) {
            var Xo = V(K, X[Cn], Te);
            Xo !== null && (qr = v(Xo, qr, Cn), $n === null ? Bt = Xo : $n.sibling = Xo, $n = Xo);
          }
          if (qi()) {
            var $a = Cn;
            ed(K, $a);
          }
          return Bt;
        }
        for (var Ga = s(K, Tn); Cn < X.length; Cn++) {
          var Ta = ne(Ga, K, Cn, X[Cn], Te);
          Ta !== null && (e && Ta.alternate !== null && Ga.delete(Ta.key === null ? Cn : Ta.key), qr = v(Ta, qr, Cn), $n === null ? Bt = Ta : $n.sibling = Ta, $n = Ta);
        }
        if (e && Ga.forEach(function(ap) {
          return t(K, ap);
        }), qi()) {
          var ql = Cn;
          ed(K, ql);
        }
        return Bt;
      }
      function Ge(K, he, X, Te) {
        var Qe = Da(X);
        if (typeof Qe != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          X[Symbol.toStringTag] === "Generator" && (O0 || C("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), O0 = !0), X.entries === Qe && (k0 || C("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), k0 = !0);
          var Ve = Qe.call(X);
          if (Ve)
            for (var Lt = null, Bt = Ve.next(); !Bt.done; Bt = Ve.next()) {
              var $n = Bt.value;
              Lt = re($n, Lt, K);
            }
        }
        var Tn = Qe.call(X);
        if (Tn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var qr = null, Cn = null, Fr = he, Ea = 0, ra = 0, Xo = null, $a = Tn.next(); Fr !== null && !$a.done; ra++, $a = Tn.next()) {
          Fr.index > ra ? (Xo = Fr, Fr = null) : Xo = Fr.sibling;
          var Ga = B(K, Fr, $a.value, Te);
          if (Ga === null) {
            Fr === null && (Fr = Xo);
            break;
          }
          e && Fr && Ga.alternate === null && t(K, Fr), Ea = v(Ga, Ea, ra), Cn === null ? qr = Ga : Cn.sibling = Ga, Cn = Ga, Fr = Xo;
        }
        if ($a.done) {
          if (a(K, Fr), qi()) {
            var Ta = ra;
            ed(K, Ta);
          }
          return qr;
        }
        if (Fr === null) {
          for (; !$a.done; ra++, $a = Tn.next()) {
            var ql = V(K, $a.value, Te);
            ql !== null && (Ea = v(ql, Ea, ra), Cn === null ? qr = ql : Cn.sibling = ql, Cn = ql);
          }
          if (qi()) {
            var ap = ra;
            ed(K, ap);
          }
          return qr;
        }
        for (var im = s(K, Fr); !$a.done; ra++, $a = Tn.next()) {
          var Ju = ne(im, K, ra, $a.value, Te);
          Ju !== null && (e && Ju.alternate !== null && im.delete(Ju.key === null ? ra : Ju.key), Ea = v(Ju, Ea, ra), Cn === null ? qr = Ju : Cn.sibling = Ju, Cn = Ju);
        }
        if (e && im.forEach(function(UL) {
          return t(K, UL);
        }), qi()) {
          var zL = ra;
          ed(K, zL);
        }
        return qr;
      }
      function wt(K, he, X, Te) {
        if (he !== null && he.tag === oe) {
          a(K, he.sibling);
          var Qe = f(he, X);
          return Qe.return = K, Qe;
        }
        a(K, he);
        var Ve = sw(X, K.mode, Te);
        return Ve.return = K, Ve;
      }
      function dt(K, he, X, Te) {
        for (var Qe = X.key, Ve = he; Ve !== null; ) {
          if (Ve.key === Qe) {
            var Lt = X.type;
            if (Lt === We) {
              if (Ve.tag === ce) {
                a(K, Ve.sibling);
                var Bt = f(Ve, X.props.children);
                return Bt.return = K, Bt._debugSource = X._source, Bt._debugOwner = X._owner, Bt;
              }
            } else if (Ve.elementType === Lt || // Keep this check inline so it only runs on the false path:
            TC(Ve, X) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Lt == "object" && Lt !== null && Lt.$$typeof === mt && LT(Lt) === Ve.type) {
              a(K, Ve.sibling);
              var $n = f(Ve, X.props);
              return $n.ref = Rv(K, Ve, X), $n.return = K, $n._debugSource = X._source, $n._debugOwner = X._owner, $n;
            }
            a(K, Ve);
            break;
          } else
            t(K, Ve);
          Ve = Ve.sibling;
        }
        if (X.type === We) {
          var Tn = sf(X.props.children, K.mode, Te, X.key);
          return Tn.return = K, Tn;
        } else {
          var qr = ow(X, K.mode, Te);
          return qr.ref = Rv(K, he, X), qr.return = K, qr;
        }
      }
      function vn(K, he, X, Te) {
        for (var Qe = X.key, Ve = he; Ve !== null; ) {
          if (Ve.key === Qe)
            if (Ve.tag === $ && Ve.stateNode.containerInfo === X.containerInfo && Ve.stateNode.implementation === X.implementation) {
              a(K, Ve.sibling);
              var Lt = f(Ve, X.children || []);
              return Lt.return = K, Lt;
            } else {
              a(K, Ve);
              break;
            }
          else
            t(K, Ve);
          Ve = Ve.sibling;
        }
        var Bt = uw(X, K.mode, Te);
        return Bt.return = K, Bt;
      }
      function ln(K, he, X, Te) {
        var Qe = typeof X == "object" && X !== null && X.type === We && X.key === null;
        if (Qe && (X = X.props.children), typeof X == "object" && X !== null) {
          switch (X.$$typeof) {
            case Xa:
              return _(dt(K, he, X, Te));
            case tr:
              return _(vn(K, he, X, Te));
            case mt:
              var Ve = X._payload, Lt = X._init;
              return ln(K, he, Lt(Ve), Te);
          }
          if (Ht(X))
            return de(K, he, X, Te);
          if (Da(X))
            return Ge(K, he, X, Te);
          By(K, X);
        }
        return typeof X == "string" && X !== "" || typeof X == "number" ? _(wt(K, he, "" + X, Te)) : (typeof X == "function" && Yy(K), a(K, he));
      }
      return ln;
    }
    var Yh = NT(!0), PT = NT(!1);
    function CD(e, t) {
      if (e !== null && t.child !== e.child)
        throw new Error("Resuming work not yet implemented.");
      if (t.child !== null) {
        var a = t.child, s = hd(a, a.pendingProps);
        for (t.child = s, s.return = t; a.sibling !== null; )
          a = a.sibling, s = s.sibling = hd(a, a.pendingProps), s.return = t;
        s.sibling = null;
      }
    }
    function xD(e, t) {
      for (var a = e.child; a !== null; )
        eL(a, t), a = a.sibling;
    }
    var Dv = {}, Kc = Zc(Dv), kv = Zc(Dv), Vy = Zc(Dv);
    function Wy(e) {
      if (e === Dv)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return e;
    }
    function AT() {
      var e = Wy(Vy.current);
      return e;
    }
    function A0(e, t) {
      Sa(Vy, t, e), Sa(kv, e, e), Sa(Kc, Dv, e);
      var a = jM(t);
      _a(Kc, e), Sa(Kc, a, e);
    }
    function Vh(e) {
      _a(Kc, e), _a(kv, e), _a(Vy, e);
    }
    function z0() {
      var e = Wy(Kc.current);
      return e;
    }
    function zT(e) {
      Wy(Vy.current);
      var t = Wy(Kc.current), a = FM(t, e.type);
      t !== a && (Sa(kv, e, e), Sa(Kc, a, e));
    }
    function U0(e) {
      kv.current === e && (_a(Kc, e), _a(kv, e));
    }
    var bD = 0, UT = 1, IT = 1, Ov = 2, nu = Zc(bD);
    function I0(e, t) {
      return (e & t) !== 0;
    }
    function Wh(e) {
      return e & UT;
    }
    function j0(e, t) {
      return e & UT | t;
    }
    function MD(e, t) {
      return e | t;
    }
    function Xc(e, t) {
      Sa(nu, t, e);
    }
    function Zh(e) {
      _a(nu, e);
    }
    function RD(e, t) {
      var a = e.memoizedState;
      return a !== null ? a.dehydrated !== null : (e.memoizedProps, !0);
    }
    function Zy(e) {
      for (var t = e; t !== null; ) {
        if (t.tag === G) {
          var a = t.memoizedState;
          if (a !== null) {
            var s = a.dehydrated;
            if (s === null || GE(s) || W_(s))
              return t;
          }
        } else if (t.tag === Xe && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        t.memoizedProps.revealOrder !== void 0) {
          var f = (t.flags & At) !== pt;
          if (f)
            return t;
        } else if (t.child !== null) {
          t.child.return = t, t = t.child;
          continue;
        }
        if (t === e)
          return null;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e)
            return null;
          t = t.return;
        }
        t.sibling.return = t.return, t = t.sibling;
      }
      return null;
    }
    var bo = (
      /*   */
      0
    ), wi = (
      /* */
      1
    ), Zu = (
      /*  */
      2
    ), Ei = (
      /*    */
      4
    ), Ki = (
      /*   */
      8
    ), F0 = [];
    function H0() {
      for (var e = 0; e < F0.length; e++) {
        var t = F0[e];
        t._workInProgressVersionPrimary = null;
      }
      F0.length = 0;
    }
    function DD(e, t) {
      var a = t._getVersion, s = a(t._source);
      e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, s] : e.mutableSourceEagerHydrationData.push(t, s);
    }
    var $e = d.ReactCurrentDispatcher, Lv = d.ReactCurrentBatchConfig, B0, $h;
    B0 = /* @__PURE__ */ new Set();
    var od = pe, Zn = null, Ti = null, Ci = null, $y = !1, Nv = !1, Pv = 0, kD = 0, OD = 25, me = null, xs = null, Jc = -1, Y0 = !1;
    function Nn() {
      {
        var e = me;
        xs === null ? xs = [e] : xs.push(e);
      }
    }
    function Ae() {
      {
        var e = me;
        xs !== null && (Jc++, xs[Jc] !== e && LD(e));
      }
    }
    function Gh(e) {
      e != null && !Ht(e) && C("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", me, typeof e);
    }
    function LD(e) {
      {
        var t = Ot(Zn);
        if (!B0.has(t) && (B0.add(t), xs !== null)) {
          for (var a = "", s = 30, f = 0; f <= Jc; f++) {
            for (var v = xs[f], _ = f === Jc ? e : v, E = f + 1 + ". " + v; E.length < s; )
              E += " ";
            E += _ + `
`, a += E;
          }
          C(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, t, a);
        }
      }
    }
    function wa() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function V0(e, t) {
      if (Y0)
        return !1;
      if (t === null)
        return C("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", me), !1;
      e.length !== t.length && C(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, me, "[" + t.join(", ") + "]", "[" + e.join(", ") + "]");
      for (var a = 0; a < t.length && a < e.length; a++)
        if (!at(e[a], t[a]))
          return !1;
      return !0;
    }
    function Qh(e, t, a, s, f, v) {
      od = v, Zn = t, xs = e !== null ? e._debugHookTypes : null, Jc = -1, Y0 = e !== null && e.type !== t.type, t.memoizedState = null, t.updateQueue = null, t.lanes = pe, e !== null && e.memoizedState !== null ? $e.current = o1 : xs !== null ? $e.current = a1 : $e.current = i1;
      var _ = a(s, f);
      if (Nv) {
        var E = 0;
        do {
          if (Nv = !1, Pv = 0, E >= OD)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          E += 1, Y0 = !1, Ti = null, Ci = null, t.updateQueue = null, Jc = -1, $e.current = s1, _ = a(s, f);
        } while (Nv);
      }
      $e.current = og, t._debugHookTypes = xs;
      var x = Ti !== null && Ti.next !== null;
      if (od = pe, Zn = null, Ti = null, Ci = null, me = null, xs = null, Jc = -1, e !== null && (e.flags & gi) !== (t.flags & gi) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (e.mode & Jt) !== Tt && C("Internal React error: Expected static flag was missing. Please notify the React team."), $y = !1, x)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return _;
    }
    function qh() {
      var e = Pv !== 0;
      return Pv = 0, e;
    }
    function jT(e, t, a) {
      t.updateQueue = e.updateQueue, (t.mode & go) !== Tt ? t.flags &= ~(gl | ha | cr | Wt) : t.flags &= ~(cr | Wt), e.lanes = Dc(e.lanes, a);
    }
    function FT() {
      if ($e.current = og, $y) {
        for (var e = Zn.memoizedState; e !== null; ) {
          var t = e.queue;
          t !== null && (t.pending = null), e = e.next;
        }
        $y = !1;
      }
      od = pe, Zn = null, Ti = null, Ci = null, xs = null, Jc = -1, me = null, JT = !1, Nv = !1, Pv = 0;
    }
    function $u() {
      var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Ci === null ? Zn.memoizedState = Ci = e : Ci = Ci.next = e, Ci;
    }
    function bs() {
      var e;
      if (Ti === null) {
        var t = Zn.alternate;
        t !== null ? e = t.memoizedState : e = null;
      } else
        e = Ti.next;
      var a;
      if (Ci === null ? a = Zn.memoizedState : a = Ci.next, a !== null)
        Ci = a, a = Ci.next, Ti = e;
      else {
        if (e === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Ti = e;
        var s = {
          memoizedState: Ti.memoizedState,
          baseState: Ti.baseState,
          baseQueue: Ti.baseQueue,
          queue: Ti.queue,
          next: null
        };
        Ci === null ? Zn.memoizedState = Ci = s : Ci = Ci.next = s;
      }
      return Ci;
    }
    function HT() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function W0(e, t) {
      return typeof t == "function" ? t(e) : t;
    }
    function Z0(e, t, a) {
      var s = $u(), f;
      a !== void 0 ? f = a(t) : f = t, s.memoizedState = s.baseState = f;
      var v = {
        pending: null,
        interleaved: null,
        lanes: pe,
        dispatch: null,
        lastRenderedReducer: e,
        lastRenderedState: f
      };
      s.queue = v;
      var _ = v.dispatch = zD.bind(null, Zn, v);
      return [s.memoizedState, _];
    }
    function $0(e, t, a) {
      var s = bs(), f = s.queue;
      if (f === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      f.lastRenderedReducer = e;
      var v = Ti, _ = v.baseQueue, E = f.pending;
      if (E !== null) {
        if (_ !== null) {
          var x = _.next, k = E.next;
          _.next = k, E.next = x;
        }
        v.baseQueue !== _ && C("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), v.baseQueue = _ = E, f.pending = null;
      }
      if (_ !== null) {
        var O = _.next, V = v.baseState, B = null, ne = null, re = null, de = O;
        do {
          var Ge = de.lane;
          if (Rl(od, Ge)) {
            if (re !== null) {
              var dt = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: hn,
                action: de.action,
                hasEagerState: de.hasEagerState,
                eagerState: de.eagerState,
                next: null
              };
              re = re.next = dt;
            }
            if (de.hasEagerState)
              V = de.eagerState;
            else {
              var vn = de.action;
              V = e(V, vn);
            }
          } else {
            var wt = {
              lane: Ge,
              action: de.action,
              hasEagerState: de.hasEagerState,
              eagerState: de.eagerState,
              next: null
            };
            re === null ? (ne = re = wt, B = V) : re = re.next = wt, Zn.lanes = Zt(Zn.lanes, Ge), Jv(Ge);
          }
          de = de.next;
        } while (de !== null && de !== O);
        re === null ? B = V : re.next = ne, at(V, s.memoizedState) || Hv(), s.memoizedState = V, s.baseState = B, s.baseQueue = re, f.lastRenderedState = V;
      }
      var ln = f.interleaved;
      if (ln !== null) {
        var K = ln;
        do {
          var he = K.lane;
          Zn.lanes = Zt(Zn.lanes, he), Jv(he), K = K.next;
        } while (K !== ln);
      } else
        _ === null && (f.lanes = pe);
      var X = f.dispatch;
      return [s.memoizedState, X];
    }
    function G0(e, t, a) {
      var s = bs(), f = s.queue;
      if (f === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      f.lastRenderedReducer = e;
      var v = f.dispatch, _ = f.pending, E = s.memoizedState;
      if (_ !== null) {
        f.pending = null;
        var x = _.next, k = x;
        do {
          var O = k.action;
          E = e(E, O), k = k.next;
        } while (k !== x);
        at(E, s.memoizedState) || Hv(), s.memoizedState = E, s.baseQueue === null && (s.baseState = E), f.lastRenderedState = E;
      }
      return [E, v];
    }
    function X2(e, t, a) {
    }
    function J2(e, t, a) {
    }
    function Q0(e, t, a) {
      var s = Zn, f = $u(), v, _ = qi();
      if (_) {
        if (a === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        v = a(), $h || v !== a() && (C("The result of getServerSnapshot should be cached to avoid an infinite loop"), $h = !0);
      } else {
        if (v = t(), !$h) {
          var E = t();
          at(v, E) || (C("The result of getSnapshot should be cached to avoid an infinite loop"), $h = !0);
        }
        var x = Cg();
        if (x === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Uf(x, od) || BT(s, t, v);
      }
      f.memoizedState = v;
      var k = {
        value: v,
        getSnapshot: t
      };
      return f.queue = k, Xy(VT.bind(null, s, k, e), [e]), s.flags |= cr, Av(wi | Ki, YT.bind(null, s, k, v, t), void 0, null), v;
    }
    function Gy(e, t, a) {
      var s = Zn, f = bs(), v = t();
      if (!$h) {
        var _ = t();
        at(v, _) || (C("The result of getSnapshot should be cached to avoid an infinite loop"), $h = !0);
      }
      var E = f.memoizedState, x = !at(E, v);
      x && (f.memoizedState = v, Hv());
      var k = f.queue;
      if (Uv(VT.bind(null, s, k, e), [e]), k.getSnapshot !== t || x || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Ci !== null && Ci.memoizedState.tag & wi) {
        s.flags |= cr, Av(wi | Ki, YT.bind(null, s, k, v, t), void 0, null);
        var O = Cg();
        if (O === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Uf(O, od) || BT(s, t, v);
      }
      return v;
    }
    function BT(e, t, a) {
      e.flags |= Rf;
      var s = {
        getSnapshot: t,
        value: a
      }, f = Zn.updateQueue;
      if (f === null)
        f = HT(), Zn.updateQueue = f, f.stores = [s];
      else {
        var v = f.stores;
        v === null ? f.stores = [s] : v.push(s);
      }
    }
    function YT(e, t, a, s) {
      t.value = a, t.getSnapshot = s, WT(t) && ZT(e);
    }
    function VT(e, t, a) {
      var s = function() {
        WT(t) && ZT(e);
      };
      return a(s);
    }
    function WT(e) {
      var t = e.getSnapshot, a = e.value;
      try {
        var s = t();
        return !at(a, s);
      } catch {
        return !0;
      }
    }
    function ZT(e) {
      var t = xo(e, Dt);
      t !== null && Ri(t, e, Dt, Jn);
    }
    function Qy(e) {
      var t = $u();
      typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e;
      var a = {
        pending: null,
        interleaved: null,
        lanes: pe,
        dispatch: null,
        lastRenderedReducer: W0,
        lastRenderedState: e
      };
      t.queue = a;
      var s = a.dispatch = UD.bind(null, Zn, a);
      return [t.memoizedState, s];
    }
    function q0(e) {
      return $0(W0);
    }
    function K0(e) {
      return G0(W0);
    }
    function Av(e, t, a, s) {
      var f = {
        tag: e,
        create: t,
        destroy: a,
        deps: s,
        // Circular
        next: null
      }, v = Zn.updateQueue;
      if (v === null)
        v = HT(), Zn.updateQueue = v, v.lastEffect = f.next = f;
      else {
        var _ = v.lastEffect;
        if (_ === null)
          v.lastEffect = f.next = f;
        else {
          var E = _.next;
          _.next = f, f.next = E, v.lastEffect = f;
        }
      }
      return f;
    }
    function X0(e) {
      var t = $u();
      {
        var a = {
          current: e
        };
        return t.memoizedState = a, a;
      }
    }
    function qy(e) {
      var t = bs();
      return t.memoizedState;
    }
    function zv(e, t, a, s) {
      var f = $u(), v = s === void 0 ? null : s;
      Zn.flags |= e, f.memoizedState = Av(wi | t, a, void 0, v);
    }
    function Ky(e, t, a, s) {
      var f = bs(), v = s === void 0 ? null : s, _ = void 0;
      if (Ti !== null) {
        var E = Ti.memoizedState;
        if (_ = E.destroy, v !== null) {
          var x = E.deps;
          if (V0(v, x)) {
            f.memoizedState = Av(t, a, _, v);
            return;
          }
        }
      }
      Zn.flags |= e, f.memoizedState = Av(wi | t, a, _, v);
    }
    function Xy(e, t) {
      return (Zn.mode & go) !== Tt ? zv(gl | cr | Du, Ki, e, t) : zv(cr | Du, Ki, e, t);
    }
    function Uv(e, t) {
      return Ky(cr, Ki, e, t);
    }
    function J0(e, t) {
      return zv(Wt, Zu, e, t);
    }
    function Jy(e, t) {
      return Ky(Wt, Zu, e, t);
    }
    function eS(e, t) {
      var a = Wt;
      return a |= da, (Zn.mode & go) !== Tt && (a |= ha), zv(a, Ei, e, t);
    }
    function eg(e, t) {
      return Ky(Wt, Ei, e, t);
    }
    function $T(e, t) {
      if (typeof t == "function") {
        var a = t, s = e();
        return a(s), function() {
          a(null);
        };
      } else if (t != null) {
        var f = t;
        f.hasOwnProperty("current") || C("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(f).join(", ") + "}");
        var v = e();
        return f.current = v, function() {
          f.current = null;
        };
      }
    }
    function tS(e, t, a) {
      typeof t != "function" && C("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", t !== null ? typeof t : "null");
      var s = a != null ? a.concat([e]) : null, f = Wt;
      return f |= da, (Zn.mode & go) !== Tt && (f |= ha), zv(f, Ei, $T.bind(null, t, e), s);
    }
    function tg(e, t, a) {
      typeof t != "function" && C("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", t !== null ? typeof t : "null");
      var s = a != null ? a.concat([e]) : null;
      return Ky(Wt, Ei, $T.bind(null, t, e), s);
    }
    function ND(e, t) {
    }
    var ng = ND;
    function nS(e, t) {
      var a = $u(), s = t === void 0 ? null : t;
      return a.memoizedState = [e, s], e;
    }
    function rg(e, t) {
      var a = bs(), s = t === void 0 ? null : t, f = a.memoizedState;
      if (f !== null && s !== null) {
        var v = f[1];
        if (V0(s, v))
          return f[0];
      }
      return a.memoizedState = [e, s], e;
    }
    function rS(e, t) {
      var a = $u(), s = t === void 0 ? null : t, f = e();
      return a.memoizedState = [f, s], f;
    }
    function ig(e, t) {
      var a = bs(), s = t === void 0 ? null : t, f = a.memoizedState;
      if (f !== null && s !== null) {
        var v = f[1];
        if (V0(s, v))
          return f[0];
      }
      var _ = e();
      return a.memoizedState = [_, s], _;
    }
    function iS(e) {
      var t = $u();
      return t.memoizedState = e, e;
    }
    function GT(e) {
      var t = bs(), a = Ti, s = a.memoizedState;
      return qT(t, s, e);
    }
    function QT(e) {
      var t = bs();
      if (Ti === null)
        return t.memoizedState = e, e;
      var a = Ti.memoizedState;
      return qT(t, a, e);
    }
    function qT(e, t, a) {
      var s = !c_(od);
      if (s) {
        if (!at(a, t)) {
          var f = Ip();
          Zn.lanes = Zt(Zn.lanes, f), Jv(f), e.baseState = !0;
        }
        return t;
      } else
        return e.baseState && (e.baseState = !1, Hv()), e.memoizedState = a, a;
    }
    function PD(e, t, a) {
      var s = So();
      $r(Ui(s, Si)), e(!0);
      var f = Lv.transition;
      Lv.transition = {};
      var v = Lv.transition;
      Lv.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        e(!1), t();
      } finally {
        if ($r(s), Lv.transition = f, f === null && v._updatedFibers) {
          var _ = v._updatedFibers.size;
          _ > 10 && M("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), v._updatedFibers.clear();
        }
      }
    }
    function aS() {
      var e = Qy(!1), t = e[0], a = e[1], s = PD.bind(null, a), f = $u();
      return f.memoizedState = s, [t, s];
    }
    function KT() {
      var e = q0(), t = e[0], a = bs(), s = a.memoizedState;
      return [t, s];
    }
    function XT() {
      var e = K0(), t = e[0], a = bs(), s = a.memoizedState;
      return [t, s];
    }
    var JT = !1;
    function AD() {
      return JT;
    }
    function oS() {
      var e = $u(), t = Cg(), a = t.identifierPrefix, s;
      if (qi()) {
        var f = QR();
        s = ":" + a + "R" + f;
        var v = Pv++;
        v > 0 && (s += "H" + v.toString(32)), s += ":";
      } else {
        var _ = kD++;
        s = ":" + a + "r" + _.toString(32) + ":";
      }
      return e.memoizedState = s, s;
    }
    function ag() {
      var e = bs(), t = e.memoizedState;
      return t;
    }
    function zD(e, t, a) {
      typeof arguments[3] == "function" && C("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var s = af(e), f = {
        lane: s,
        action: a,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (e1(e))
        t1(t, f);
      else {
        var v = gT(e, t, f, s);
        if (v !== null) {
          var _ = Za();
          Ri(v, e, s, _), n1(v, t, s);
        }
      }
      r1(e, s);
    }
    function UD(e, t, a) {
      typeof arguments[3] == "function" && C("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var s = af(e), f = {
        lane: s,
        action: a,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (e1(e))
        t1(t, f);
      else {
        var v = e.alternate;
        if (e.lanes === pe && (v === null || v.lanes === pe)) {
          var _ = t.lastRenderedReducer;
          if (_ !== null) {
            var E;
            E = $e.current, $e.current = ru;
            try {
              var x = t.lastRenderedState, k = _(x, a);
              if (f.hasEagerState = !0, f.eagerState = k, at(k, x)) {
                vD(e, t, f, s);
                return;
              }
            } catch {
            } finally {
              $e.current = E;
            }
          }
        }
        var O = gT(e, t, f, s);
        if (O !== null) {
          var V = Za();
          Ri(O, e, s, V), n1(O, t, s);
        }
      }
      r1(e, s);
    }
    function e1(e) {
      var t = e.alternate;
      return e === Zn || t !== null && t === Zn;
    }
    function t1(e, t) {
      Nv = $y = !0;
      var a = e.pending;
      a === null ? t.next = t : (t.next = a.next, a.next = t), e.pending = t;
    }
    function n1(e, t, a) {
      if (Up(a)) {
        var s = t.lanes;
        s = jp(s, e.pendingLanes);
        var f = Zt(s, a);
        t.lanes = f, kc(e, f);
      }
    }
    function r1(e, t, a) {
      Au(e, t);
    }
    var og = {
      readContext: ci,
      useCallback: wa,
      useContext: wa,
      useEffect: wa,
      useImperativeHandle: wa,
      useInsertionEffect: wa,
      useLayoutEffect: wa,
      useMemo: wa,
      useReducer: wa,
      useRef: wa,
      useState: wa,
      useDebugValue: wa,
      useDeferredValue: wa,
      useTransition: wa,
      useMutableSource: wa,
      useSyncExternalStore: wa,
      useId: wa,
      unstable_isNewReconciler: le
    }, i1 = null, a1 = null, o1 = null, s1 = null, Gu = null, ru = null, sg = null;
    {
      var sS = function() {
        C("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Ft = function() {
        C("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      i1 = {
        readContext: function(e) {
          return ci(e);
        },
        useCallback: function(e, t) {
          return me = "useCallback", Nn(), Gh(t), nS(e, t);
        },
        useContext: function(e) {
          return me = "useContext", Nn(), ci(e);
        },
        useEffect: function(e, t) {
          return me = "useEffect", Nn(), Gh(t), Xy(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return me = "useImperativeHandle", Nn(), Gh(a), tS(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return me = "useInsertionEffect", Nn(), Gh(t), J0(e, t);
        },
        useLayoutEffect: function(e, t) {
          return me = "useLayoutEffect", Nn(), Gh(t), eS(e, t);
        },
        useMemo: function(e, t) {
          me = "useMemo", Nn(), Gh(t);
          var a = $e.current;
          $e.current = Gu;
          try {
            return rS(e, t);
          } finally {
            $e.current = a;
          }
        },
        useReducer: function(e, t, a) {
          me = "useReducer", Nn();
          var s = $e.current;
          $e.current = Gu;
          try {
            return Z0(e, t, a);
          } finally {
            $e.current = s;
          }
        },
        useRef: function(e) {
          return me = "useRef", Nn(), X0(e);
        },
        useState: function(e) {
          me = "useState", Nn();
          var t = $e.current;
          $e.current = Gu;
          try {
            return Qy(e);
          } finally {
            $e.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return me = "useDebugValue", Nn(), void 0;
        },
        useDeferredValue: function(e) {
          return me = "useDeferredValue", Nn(), iS(e);
        },
        useTransition: function() {
          return me = "useTransition", Nn(), aS();
        },
        useMutableSource: function(e, t, a) {
          return me = "useMutableSource", Nn(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return me = "useSyncExternalStore", Nn(), Q0(e, t, a);
        },
        useId: function() {
          return me = "useId", Nn(), oS();
        },
        unstable_isNewReconciler: le
      }, a1 = {
        readContext: function(e) {
          return ci(e);
        },
        useCallback: function(e, t) {
          return me = "useCallback", Ae(), nS(e, t);
        },
        useContext: function(e) {
          return me = "useContext", Ae(), ci(e);
        },
        useEffect: function(e, t) {
          return me = "useEffect", Ae(), Xy(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return me = "useImperativeHandle", Ae(), tS(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return me = "useInsertionEffect", Ae(), J0(e, t);
        },
        useLayoutEffect: function(e, t) {
          return me = "useLayoutEffect", Ae(), eS(e, t);
        },
        useMemo: function(e, t) {
          me = "useMemo", Ae();
          var a = $e.current;
          $e.current = Gu;
          try {
            return rS(e, t);
          } finally {
            $e.current = a;
          }
        },
        useReducer: function(e, t, a) {
          me = "useReducer", Ae();
          var s = $e.current;
          $e.current = Gu;
          try {
            return Z0(e, t, a);
          } finally {
            $e.current = s;
          }
        },
        useRef: function(e) {
          return me = "useRef", Ae(), X0(e);
        },
        useState: function(e) {
          me = "useState", Ae();
          var t = $e.current;
          $e.current = Gu;
          try {
            return Qy(e);
          } finally {
            $e.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return me = "useDebugValue", Ae(), void 0;
        },
        useDeferredValue: function(e) {
          return me = "useDeferredValue", Ae(), iS(e);
        },
        useTransition: function() {
          return me = "useTransition", Ae(), aS();
        },
        useMutableSource: function(e, t, a) {
          return me = "useMutableSource", Ae(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return me = "useSyncExternalStore", Ae(), Q0(e, t, a);
        },
        useId: function() {
          return me = "useId", Ae(), oS();
        },
        unstable_isNewReconciler: le
      }, o1 = {
        readContext: function(e) {
          return ci(e);
        },
        useCallback: function(e, t) {
          return me = "useCallback", Ae(), rg(e, t);
        },
        useContext: function(e) {
          return me = "useContext", Ae(), ci(e);
        },
        useEffect: function(e, t) {
          return me = "useEffect", Ae(), Uv(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return me = "useImperativeHandle", Ae(), tg(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return me = "useInsertionEffect", Ae(), Jy(e, t);
        },
        useLayoutEffect: function(e, t) {
          return me = "useLayoutEffect", Ae(), eg(e, t);
        },
        useMemo: function(e, t) {
          me = "useMemo", Ae();
          var a = $e.current;
          $e.current = ru;
          try {
            return ig(e, t);
          } finally {
            $e.current = a;
          }
        },
        useReducer: function(e, t, a) {
          me = "useReducer", Ae();
          var s = $e.current;
          $e.current = ru;
          try {
            return $0(e, t, a);
          } finally {
            $e.current = s;
          }
        },
        useRef: function(e) {
          return me = "useRef", Ae(), qy();
        },
        useState: function(e) {
          me = "useState", Ae();
          var t = $e.current;
          $e.current = ru;
          try {
            return q0(e);
          } finally {
            $e.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return me = "useDebugValue", Ae(), ng();
        },
        useDeferredValue: function(e) {
          return me = "useDeferredValue", Ae(), GT(e);
        },
        useTransition: function() {
          return me = "useTransition", Ae(), KT();
        },
        useMutableSource: function(e, t, a) {
          return me = "useMutableSource", Ae(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return me = "useSyncExternalStore", Ae(), Gy(e, t);
        },
        useId: function() {
          return me = "useId", Ae(), ag();
        },
        unstable_isNewReconciler: le
      }, s1 = {
        readContext: function(e) {
          return ci(e);
        },
        useCallback: function(e, t) {
          return me = "useCallback", Ae(), rg(e, t);
        },
        useContext: function(e) {
          return me = "useContext", Ae(), ci(e);
        },
        useEffect: function(e, t) {
          return me = "useEffect", Ae(), Uv(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return me = "useImperativeHandle", Ae(), tg(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return me = "useInsertionEffect", Ae(), Jy(e, t);
        },
        useLayoutEffect: function(e, t) {
          return me = "useLayoutEffect", Ae(), eg(e, t);
        },
        useMemo: function(e, t) {
          me = "useMemo", Ae();
          var a = $e.current;
          $e.current = sg;
          try {
            return ig(e, t);
          } finally {
            $e.current = a;
          }
        },
        useReducer: function(e, t, a) {
          me = "useReducer", Ae();
          var s = $e.current;
          $e.current = sg;
          try {
            return G0(e, t, a);
          } finally {
            $e.current = s;
          }
        },
        useRef: function(e) {
          return me = "useRef", Ae(), qy();
        },
        useState: function(e) {
          me = "useState", Ae();
          var t = $e.current;
          $e.current = sg;
          try {
            return K0(e);
          } finally {
            $e.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return me = "useDebugValue", Ae(), ng();
        },
        useDeferredValue: function(e) {
          return me = "useDeferredValue", Ae(), QT(e);
        },
        useTransition: function() {
          return me = "useTransition", Ae(), XT();
        },
        useMutableSource: function(e, t, a) {
          return me = "useMutableSource", Ae(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return me = "useSyncExternalStore", Ae(), Gy(e, t);
        },
        useId: function() {
          return me = "useId", Ae(), ag();
        },
        unstable_isNewReconciler: le
      }, Gu = {
        readContext: function(e) {
          return sS(), ci(e);
        },
        useCallback: function(e, t) {
          return me = "useCallback", Ft(), Nn(), nS(e, t);
        },
        useContext: function(e) {
          return me = "useContext", Ft(), Nn(), ci(e);
        },
        useEffect: function(e, t) {
          return me = "useEffect", Ft(), Nn(), Xy(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return me = "useImperativeHandle", Ft(), Nn(), tS(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return me = "useInsertionEffect", Ft(), Nn(), J0(e, t);
        },
        useLayoutEffect: function(e, t) {
          return me = "useLayoutEffect", Ft(), Nn(), eS(e, t);
        },
        useMemo: function(e, t) {
          me = "useMemo", Ft(), Nn();
          var a = $e.current;
          $e.current = Gu;
          try {
            return rS(e, t);
          } finally {
            $e.current = a;
          }
        },
        useReducer: function(e, t, a) {
          me = "useReducer", Ft(), Nn();
          var s = $e.current;
          $e.current = Gu;
          try {
            return Z0(e, t, a);
          } finally {
            $e.current = s;
          }
        },
        useRef: function(e) {
          return me = "useRef", Ft(), Nn(), X0(e);
        },
        useState: function(e) {
          me = "useState", Ft(), Nn();
          var t = $e.current;
          $e.current = Gu;
          try {
            return Qy(e);
          } finally {
            $e.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return me = "useDebugValue", Ft(), Nn(), void 0;
        },
        useDeferredValue: function(e) {
          return me = "useDeferredValue", Ft(), Nn(), iS(e);
        },
        useTransition: function() {
          return me = "useTransition", Ft(), Nn(), aS();
        },
        useMutableSource: function(e, t, a) {
          return me = "useMutableSource", Ft(), Nn(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return me = "useSyncExternalStore", Ft(), Nn(), Q0(e, t, a);
        },
        useId: function() {
          return me = "useId", Ft(), Nn(), oS();
        },
        unstable_isNewReconciler: le
      }, ru = {
        readContext: function(e) {
          return sS(), ci(e);
        },
        useCallback: function(e, t) {
          return me = "useCallback", Ft(), Ae(), rg(e, t);
        },
        useContext: function(e) {
          return me = "useContext", Ft(), Ae(), ci(e);
        },
        useEffect: function(e, t) {
          return me = "useEffect", Ft(), Ae(), Uv(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return me = "useImperativeHandle", Ft(), Ae(), tg(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return me = "useInsertionEffect", Ft(), Ae(), Jy(e, t);
        },
        useLayoutEffect: function(e, t) {
          return me = "useLayoutEffect", Ft(), Ae(), eg(e, t);
        },
        useMemo: function(e, t) {
          me = "useMemo", Ft(), Ae();
          var a = $e.current;
          $e.current = ru;
          try {
            return ig(e, t);
          } finally {
            $e.current = a;
          }
        },
        useReducer: function(e, t, a) {
          me = "useReducer", Ft(), Ae();
          var s = $e.current;
          $e.current = ru;
          try {
            return $0(e, t, a);
          } finally {
            $e.current = s;
          }
        },
        useRef: function(e) {
          return me = "useRef", Ft(), Ae(), qy();
        },
        useState: function(e) {
          me = "useState", Ft(), Ae();
          var t = $e.current;
          $e.current = ru;
          try {
            return q0(e);
          } finally {
            $e.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return me = "useDebugValue", Ft(), Ae(), ng();
        },
        useDeferredValue: function(e) {
          return me = "useDeferredValue", Ft(), Ae(), GT(e);
        },
        useTransition: function() {
          return me = "useTransition", Ft(), Ae(), KT();
        },
        useMutableSource: function(e, t, a) {
          return me = "useMutableSource", Ft(), Ae(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return me = "useSyncExternalStore", Ft(), Ae(), Gy(e, t);
        },
        useId: function() {
          return me = "useId", Ft(), Ae(), ag();
        },
        unstable_isNewReconciler: le
      }, sg = {
        readContext: function(e) {
          return sS(), ci(e);
        },
        useCallback: function(e, t) {
          return me = "useCallback", Ft(), Ae(), rg(e, t);
        },
        useContext: function(e) {
          return me = "useContext", Ft(), Ae(), ci(e);
        },
        useEffect: function(e, t) {
          return me = "useEffect", Ft(), Ae(), Uv(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return me = "useImperativeHandle", Ft(), Ae(), tg(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return me = "useInsertionEffect", Ft(), Ae(), Jy(e, t);
        },
        useLayoutEffect: function(e, t) {
          return me = "useLayoutEffect", Ft(), Ae(), eg(e, t);
        },
        useMemo: function(e, t) {
          me = "useMemo", Ft(), Ae();
          var a = $e.current;
          $e.current = ru;
          try {
            return ig(e, t);
          } finally {
            $e.current = a;
          }
        },
        useReducer: function(e, t, a) {
          me = "useReducer", Ft(), Ae();
          var s = $e.current;
          $e.current = ru;
          try {
            return G0(e, t, a);
          } finally {
            $e.current = s;
          }
        },
        useRef: function(e) {
          return me = "useRef", Ft(), Ae(), qy();
        },
        useState: function(e) {
          me = "useState", Ft(), Ae();
          var t = $e.current;
          $e.current = ru;
          try {
            return K0(e);
          } finally {
            $e.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return me = "useDebugValue", Ft(), Ae(), ng();
        },
        useDeferredValue: function(e) {
          return me = "useDeferredValue", Ft(), Ae(), QT(e);
        },
        useTransition: function() {
          return me = "useTransition", Ft(), Ae(), XT();
        },
        useMutableSource: function(e, t, a) {
          return me = "useMutableSource", Ft(), Ae(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return me = "useSyncExternalStore", Ft(), Ae(), Gy(e, t);
        },
        useId: function() {
          return me = "useId", Ft(), Ae(), ag();
        },
        unstable_isNewReconciler: le
      };
    }
    var ef = c.unstable_now, u1 = 0, ug = -1, Iv = -1, lg = -1, uS = !1, cg = !1;
    function l1() {
      return uS;
    }
    function ID() {
      cg = !0;
    }
    function jD() {
      uS = !1, cg = !1;
    }
    function FD() {
      uS = cg, cg = !1;
    }
    function c1() {
      return u1;
    }
    function f1() {
      u1 = ef();
    }
    function lS(e) {
      Iv = ef(), e.actualStartTime < 0 && (e.actualStartTime = ef());
    }
    function d1(e) {
      Iv = -1;
    }
    function fg(e, t) {
      if (Iv >= 0) {
        var a = ef() - Iv;
        e.actualDuration += a, t && (e.selfBaseDuration = a), Iv = -1;
      }
    }
    function Qu(e) {
      if (ug >= 0) {
        var t = ef() - ug;
        ug = -1;
        for (var a = e.return; a !== null; ) {
          switch (a.tag) {
            case H:
              var s = a.stateNode;
              s.effectDuration += t;
              return;
            case ye:
              var f = a.stateNode;
              f.effectDuration += t;
              return;
          }
          a = a.return;
        }
      }
    }
    function cS(e) {
      if (lg >= 0) {
        var t = ef() - lg;
        lg = -1;
        for (var a = e.return; a !== null; ) {
          switch (a.tag) {
            case H:
              var s = a.stateNode;
              s !== null && (s.passiveEffectDuration += t);
              return;
            case ye:
              var f = a.stateNode;
              f !== null && (f.passiveEffectDuration += t);
              return;
          }
          a = a.return;
        }
      }
    }
    function qu() {
      ug = ef();
    }
    function fS() {
      lg = ef();
    }
    function dS(e) {
      for (var t = e.child; t; )
        e.actualDuration += t.actualDuration, t = t.sibling;
    }
    function sd(e, t) {
      return {
        value: e,
        source: t,
        stack: ao(t),
        digest: null
      };
    }
    function hS(e, t, a) {
      return {
        value: e,
        source: null,
        stack: a ?? null,
        digest: t ?? null
      };
    }
    function HD(e, t) {
      return !0;
    }
    function pS(e, t) {
      try {
        var a = HD(e, t);
        if (a === !1)
          return;
        var s = t.value, f = t.source, v = t.stack, _ = v !== null ? v : "";
        if (s != null && s._suppressLogging) {
          if (e.tag === j)
            return;
          console.error(s);
        }
        var E = f ? Ot(f) : null, x = E ? "The above error occurred in the <" + E + "> component:" : "The above error occurred in one of your React components:", k;
        if (e.tag === H)
          k = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var O = Ot(e) || "Anonymous";
          k = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + O + ".");
        }
        var V = x + `
` + _ + `

` + ("" + k);
        console.error(V);
      } catch (B) {
        setTimeout(function() {
          throw B;
        });
      }
    }
    var BD = typeof WeakMap == "function" ? WeakMap : Map;
    function h1(e, t, a) {
      var s = Vl(Jn, a);
      s.tag = p0, s.payload = {
        element: null
      };
      var f = t.value;
      return s.callback = function() {
        PO(f), pS(e, t);
      }, s;
    }
    function vS(e, t, a) {
      var s = Vl(Jn, a);
      s.tag = p0;
      var f = e.type.getDerivedStateFromError;
      if (typeof f == "function") {
        var v = t.value;
        s.payload = function() {
          return f(v);
        }, s.callback = function() {
          CC(e), pS(e, t);
        };
      }
      var _ = e.stateNode;
      return _ !== null && typeof _.componentDidCatch == "function" && (s.callback = function() {
        CC(e), pS(e, t), typeof f != "function" && LO(this);
        var x = t.value, k = t.stack;
        this.componentDidCatch(x, {
          componentStack: k !== null ? k : ""
        }), typeof f != "function" && (ga(e.lanes, Dt) || C("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Ot(e) || "Unknown"));
      }), s;
    }
    function p1(e, t, a) {
      var s = e.pingCache, f;
      if (s === null ? (s = e.pingCache = new BD(), f = /* @__PURE__ */ new Set(), s.set(t, f)) : (f = s.get(t), f === void 0 && (f = /* @__PURE__ */ new Set(), s.set(t, f))), !f.has(a)) {
        f.add(a);
        var v = AO.bind(null, e, t, a);
        _i && em(e, a), t.then(v, v);
      }
    }
    function YD(e, t, a, s) {
      var f = e.updateQueue;
      if (f === null) {
        var v = /* @__PURE__ */ new Set();
        v.add(a), e.updateQueue = v;
      } else
        f.add(a);
    }
    function VD(e, t) {
      var a = e.tag;
      if ((e.mode & Jt) === Tt && (a === z || a === ve || a === ze)) {
        var s = e.alternate;
        s ? (e.updateQueue = s.updateQueue, e.memoizedState = s.memoizedState, e.lanes = s.lanes) : (e.updateQueue = null, e.memoizedState = null);
      }
    }
    function v1(e) {
      var t = e;
      do {
        if (t.tag === G && RD(t))
          return t;
        t = t.return;
      } while (t !== null);
      return null;
    }
    function m1(e, t, a, s, f) {
      if ((e.mode & Jt) === Tt) {
        if (e === t)
          e.flags |= ai;
        else {
          if (e.flags |= At, a.flags |= Df, a.flags &= ~(Ad | Ia), a.tag === j) {
            var v = a.alternate;
            if (v === null)
              a.tag = It;
            else {
              var _ = Vl(Jn, Dt);
              _.tag = Ay, qc(a, _, Dt);
            }
          }
          a.lanes = Zt(a.lanes, Dt);
        }
        return e;
      }
      return e.flags |= ai, e.lanes = f, e;
    }
    function WD(e, t, a, s, f) {
      if (a.flags |= Ia, _i && em(e, f), s !== null && typeof s == "object" && typeof s.then == "function") {
        var v = s;
        VD(a), qi() && a.mode & Jt && oT();
        var _ = v1(t);
        if (_ !== null) {
          _.flags &= ~Cr, m1(_, t, a, e, f), _.mode & Jt && p1(e, v, f), YD(_, e, v);
          return;
        } else {
          if (!Rc(f)) {
            p1(e, v, f), GS();
            return;
          }
          var E = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          s = E;
        }
      } else if (qi() && a.mode & Jt) {
        oT();
        var x = v1(t);
        if (x !== null) {
          (x.flags & ai) === pt && (x.flags |= Cr), m1(x, t, a, e, f), s0(sd(s, a));
          return;
        }
      }
      s = sd(s, a), CO(s);
      var k = t;
      do {
        switch (k.tag) {
          case H: {
            var O = s;
            k.flags |= ai;
            var V = Zr(f);
            k.lanes = Zt(k.lanes, V);
            var B = h1(k, O, V);
            y0(k, B);
            return;
          }
          case j:
            var ne = s, re = k.type, de = k.stateNode;
            if ((k.flags & At) === pt && (typeof re.getDerivedStateFromError == "function" || de !== null && typeof de.componentDidCatch == "function" && !vC(de))) {
              k.flags |= ai;
              var Ge = Zr(f);
              k.lanes = Zt(k.lanes, Ge);
              var wt = vS(k, ne, Ge);
              y0(k, wt);
              return;
            }
            break;
        }
        k = k.return;
      } while (k !== null);
    }
    function ZD() {
      return null;
    }
    var jv = d.ReactCurrentOwner, iu = !1, mS, Fv, yS, gS, _S, ud, SS, dg;
    mS = {}, Fv = {}, yS = {}, gS = {}, _S = {}, ud = !1, SS = {}, dg = {};
    function Va(e, t, a, s) {
      e === null ? t.child = PT(t, null, a, s) : t.child = Yh(t, e.child, a, s);
    }
    function $D(e, t, a, s) {
      t.child = Yh(t, e.child, null, s), t.child = Yh(t, null, a, s);
    }
    function y1(e, t, a, s, f) {
      if (t.type !== t.elementType) {
        var v = a.propTypes;
        v && Xs(
          v,
          s,
          // Resolved props
          "prop",
          rn(a)
        );
      }
      var _ = a.render, E = t.ref, x, k;
      Bh(t, f), Pu(t);
      {
        if (jv.current = t, vi(!0), x = Qh(e, t, _, s, E, f), k = qh(), t.mode & vr) {
          Wr(!0);
          try {
            x = Qh(e, t, _, s, E, f), k = qh();
          } finally {
            Wr(!1);
          }
        }
        vi(!1);
      }
      return _l(), e !== null && !iu ? (jT(e, t, f), Wl(e, t, f)) : (qi() && k && t0(t), t.flags |= Mu, Va(e, t, x, f), t.child);
    }
    function g1(e, t, a, s, f) {
      if (e === null) {
        var v = a.type;
        if (XO(v) && a.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        a.defaultProps === void 0) {
          var _ = v;
          return _ = ip(v), t.tag = ze, t.type = _, TS(t, v), _1(e, t, _, s, f);
        }
        {
          var E = v.propTypes;
          E && Xs(
            E,
            s,
            // Resolved props
            "prop",
            rn(v)
          );
        }
        var x = aw(a.type, null, s, t, t.mode, f);
        return x.ref = t.ref, x.return = t, t.child = x, x;
      }
      {
        var k = a.type, O = k.propTypes;
        O && Xs(
          O,
          s,
          // Resolved props
          "prop",
          rn(k)
        );
      }
      var V = e.child, B = DS(e, f);
      if (!B) {
        var ne = V.memoizedProps, re = a.compare;
        if (re = re !== null ? re : yt, re(ne, s) && e.ref === t.ref)
          return Wl(e, t, f);
      }
      t.flags |= Mu;
      var de = hd(V, s);
      return de.ref = t.ref, de.return = t, t.child = de, de;
    }
    function _1(e, t, a, s, f) {
      if (t.type !== t.elementType) {
        var v = t.elementType;
        if (v.$$typeof === mt) {
          var _ = v, E = _._payload, x = _._init;
          try {
            v = x(E);
          } catch {
            v = null;
          }
          var k = v && v.propTypes;
          k && Xs(
            k,
            s,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            rn(v)
          );
        }
      }
      if (e !== null) {
        var O = e.memoizedProps;
        if (yt(O, s) && e.ref === t.ref && // Prevent bailout if the implementation changed due to hot reload.
        t.type === e.type)
          if (iu = !1, t.pendingProps = s = O, DS(e, f))
            (e.flags & Df) !== pt && (iu = !0);
          else
            return t.lanes = e.lanes, Wl(e, t, f);
      }
      return wS(e, t, a, s, f);
    }
    function S1(e, t, a) {
      var s = t.pendingProps, f = s.children, v = e !== null ? e.memoizedState : null;
      if (s.mode === "hidden" || N)
        if ((t.mode & Jt) === Tt) {
          var _ = {
            baseLanes: pe,
            cachePool: null,
            transitions: null
          };
          t.memoizedState = _, xg(t, a);
        } else if (ga(a, ya)) {
          var V = {
            baseLanes: pe,
            cachePool: null,
            transitions: null
          };
          t.memoizedState = V;
          var B = v !== null ? v.baseLanes : a;
          xg(t, B);
        } else {
          var E = null, x;
          if (v !== null) {
            var k = v.baseLanes;
            x = Zt(k, a);
          } else
            x = a;
          t.lanes = t.childLanes = ya;
          var O = {
            baseLanes: x,
            cachePool: E,
            transitions: null
          };
          return t.memoizedState = O, t.updateQueue = null, xg(t, x), null;
        }
      else {
        var ne;
        v !== null ? (ne = Zt(v.baseLanes, a), t.memoizedState = null) : ne = a, xg(t, ne);
      }
      return Va(e, t, f, a), t.child;
    }
    function GD(e, t, a) {
      var s = t.pendingProps;
      return Va(e, t, s, a), t.child;
    }
    function QD(e, t, a) {
      var s = t.pendingProps.children;
      return Va(e, t, s, a), t.child;
    }
    function qD(e, t, a) {
      {
        t.flags |= Wt;
        {
          var s = t.stateNode;
          s.effectDuration = 0, s.passiveEffectDuration = 0;
        }
      }
      var f = t.pendingProps, v = f.children;
      return Va(e, t, v, a), t.child;
    }
    function w1(e, t) {
      var a = t.ref;
      (e === null && a !== null || e !== null && e.ref !== a) && (t.flags |= fa, t.flags |= Ep);
    }
    function wS(e, t, a, s, f) {
      if (t.type !== t.elementType) {
        var v = a.propTypes;
        v && Xs(
          v,
          s,
          // Resolved props
          "prop",
          rn(a)
        );
      }
      var _;
      {
        var E = zh(t, a, !0);
        _ = Uh(t, E);
      }
      var x, k;
      Bh(t, f), Pu(t);
      {
        if (jv.current = t, vi(!0), x = Qh(e, t, a, s, _, f), k = qh(), t.mode & vr) {
          Wr(!0);
          try {
            x = Qh(e, t, a, s, _, f), k = qh();
          } finally {
            Wr(!1);
          }
        }
        vi(!1);
      }
      return _l(), e !== null && !iu ? (jT(e, t, f), Wl(e, t, f)) : (qi() && k && t0(t), t.flags |= Mu, Va(e, t, x, f), t.child);
    }
    function E1(e, t, a, s, f) {
      {
        switch (hL(t)) {
          case !1: {
            var v = t.stateNode, _ = t.type, E = new _(t.memoizedProps, v.context), x = E.state;
            v.updater.enqueueSetState(v, x, null);
            break;
          }
          case !0: {
            t.flags |= At, t.flags |= ai;
            var k = new Error("Simulated error coming from DevTools"), O = Zr(f);
            t.lanes = Zt(t.lanes, O);
            var V = vS(t, sd(k, t), O);
            y0(t, V);
            break;
          }
        }
        if (t.type !== t.elementType) {
          var B = a.propTypes;
          B && Xs(
            B,
            s,
            // Resolved props
            "prop",
            rn(a)
          );
        }
      }
      var ne;
      Wu(a) ? (ne = !0, Cy(t)) : ne = !1, Bh(t, f);
      var re = t.stateNode, de;
      re === null ? (pg(e, t), DT(t, a, s), D0(t, a, s, f), de = !0) : e === null ? de = ED(t, a, s, f) : de = TD(e, t, a, s, f);
      var Ge = ES(e, t, a, de, ne, f);
      {
        var wt = t.stateNode;
        de && wt.props !== s && (ud || C("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Ot(t) || "a component"), ud = !0);
      }
      return Ge;
    }
    function ES(e, t, a, s, f, v) {
      w1(e, t);
      var _ = (t.flags & At) !== pt;
      if (!s && !_)
        return f && nT(t, a, !1), Wl(e, t, v);
      var E = t.stateNode;
      jv.current = t;
      var x;
      if (_ && typeof a.getDerivedStateFromError != "function")
        x = null, d1();
      else {
        Pu(t);
        {
          if (vi(!0), x = E.render(), t.mode & vr) {
            Wr(!0);
            try {
              E.render();
            } finally {
              Wr(!1);
            }
          }
          vi(!1);
        }
        _l();
      }
      return t.flags |= Mu, e !== null && _ ? $D(e, t, x, v) : Va(e, t, x, v), t.memoizedState = E.state, f && nT(t, a, !0), t.child;
    }
    function T1(e) {
      var t = e.stateNode;
      t.pendingContext ? eT(e, t.pendingContext, t.pendingContext !== t.context) : t.context && eT(e, t.context, !1), A0(e, t.containerInfo);
    }
    function KD(e, t, a) {
      if (T1(t), e === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var s = t.pendingProps, f = t.memoizedState, v = f.element;
      wT(e, t), jy(t, s, null, a);
      var _ = t.memoizedState;
      t.stateNode;
      var E = _.element;
      if (f.isDehydrated) {
        var x = {
          element: E,
          isDehydrated: !1,
          cache: _.cache,
          pendingSuspenseBoundaries: _.pendingSuspenseBoundaries,
          transitions: _.transitions
        }, k = t.updateQueue;
        if (k.baseState = x, t.memoizedState = x, t.flags & Cr) {
          var O = sd(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), t);
          return C1(e, t, E, a, O);
        } else if (E !== v) {
          var V = sd(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), t);
          return C1(e, t, E, a, V);
        } else {
          tD(t);
          var B = PT(t, null, E, a);
          t.child = B;
          for (var ne = B; ne; )
            ne.flags = ne.flags & ~rr | vo, ne = ne.sibling;
        }
      } else {
        if (Fh(), E === v)
          return Wl(e, t, a);
        Va(e, t, E, a);
      }
      return t.child;
    }
    function C1(e, t, a, s, f) {
      return Fh(), s0(f), t.flags |= Cr, Va(e, t, a, s), t.child;
    }
    function XD(e, t, a) {
      zT(t), e === null && o0(t);
      var s = t.type, f = t.pendingProps, v = e !== null ? e.memoizedProps : null, _ = f.children, E = H_(s, f);
      return E ? _ = null : v !== null && H_(s, v) && (t.flags |= Ln), w1(e, t), Va(e, t, _, a), t.child;
    }
    function JD(e, t) {
      return e === null && o0(t), null;
    }
    function ek(e, t, a, s) {
      pg(e, t);
      var f = t.pendingProps, v = a, _ = v._payload, E = v._init, x = E(_);
      t.type = x;
      var k = t.tag = JO(x), O = tu(x, f), V;
      switch (k) {
        case z:
          return TS(t, x), t.type = x = ip(x), V = wS(null, t, x, O, s), V;
        case j:
          return t.type = x = JS(x), V = E1(null, t, x, O, s), V;
        case ve:
          return t.type = x = ew(x), V = y1(null, t, x, O, s), V;
        case Me: {
          if (t.type !== t.elementType) {
            var B = x.propTypes;
            B && Xs(
              B,
              O,
              // Resolved for outer only
              "prop",
              rn(x)
            );
          }
          return V = g1(
            null,
            t,
            x,
            tu(x.type, O),
            // The inner type can have defaults too
            s
          ), V;
        }
      }
      var ne = "";
      throw x !== null && typeof x == "object" && x.$$typeof === mt && (ne = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + x + ". " + ("Lazy element type must resolve to a class or function." + ne));
    }
    function tk(e, t, a, s, f) {
      pg(e, t), t.tag = j;
      var v;
      return Wu(a) ? (v = !0, Cy(t)) : v = !1, Bh(t, f), DT(t, a, s), D0(t, a, s, f), ES(null, t, a, !0, v, f);
    }
    function nk(e, t, a, s) {
      pg(e, t);
      var f = t.pendingProps, v;
      {
        var _ = zh(t, a, !1);
        v = Uh(t, _);
      }
      Bh(t, s);
      var E, x;
      Pu(t);
      {
        if (a.prototype && typeof a.prototype.render == "function") {
          var k = rn(a) || "Unknown";
          mS[k] || (C("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", k, k), mS[k] = !0);
        }
        t.mode & vr && eu.recordLegacyContextWarning(t, null), vi(!0), jv.current = t, E = Qh(null, t, a, f, v, s), x = qh(), vi(!1);
      }
      if (_l(), t.flags |= Mu, typeof E == "object" && E !== null && typeof E.render == "function" && E.$$typeof === void 0) {
        var O = rn(a) || "Unknown";
        Fv[O] || (C("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", O, O, O), Fv[O] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof E == "object" && E !== null && typeof E.render == "function" && E.$$typeof === void 0
      ) {
        {
          var V = rn(a) || "Unknown";
          Fv[V] || (C("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", V, V, V), Fv[V] = !0);
        }
        t.tag = j, t.memoizedState = null, t.updateQueue = null;
        var B = !1;
        return Wu(a) ? (B = !0, Cy(t)) : B = !1, t.memoizedState = E.state !== null && E.state !== void 0 ? E.state : null, m0(t), RT(t, E), D0(t, a, f, s), ES(null, t, a, !0, B, s);
      } else {
        if (t.tag = z, t.mode & vr) {
          Wr(!0);
          try {
            E = Qh(null, t, a, f, v, s), x = qh();
          } finally {
            Wr(!1);
          }
        }
        return qi() && x && t0(t), Va(null, t, E, s), TS(t, a), t.child;
      }
    }
    function TS(e, t) {
      {
        if (t && t.childContextTypes && C("%s(...): childContextTypes cannot be defined on a function component.", t.displayName || t.name || "Component"), e.ref !== null) {
          var a = "", s = Vr();
          s && (a += `

Check the render method of \`` + s + "`.");
          var f = s || "", v = e._debugSource;
          v && (f = v.fileName + ":" + v.lineNumber), _S[f] || (_S[f] = !0, C("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", a));
        }
        if (typeof t.getDerivedStateFromProps == "function") {
          var _ = rn(t) || "Unknown";
          gS[_] || (C("%s: Function components do not support getDerivedStateFromProps.", _), gS[_] = !0);
        }
        if (typeof t.contextType == "object" && t.contextType !== null) {
          var E = rn(t) || "Unknown";
          yS[E] || (C("%s: Function components do not support contextType.", E), yS[E] = !0);
        }
      }
    }
    var CS = {
      dehydrated: null,
      treeContext: null,
      retryLane: hn
    };
    function xS(e) {
      return {
        baseLanes: e,
        cachePool: ZD(),
        transitions: null
      };
    }
    function rk(e, t) {
      var a = null;
      return {
        baseLanes: Zt(e.baseLanes, t),
        cachePool: a,
        transitions: e.transitions
      };
    }
    function ik(e, t, a, s) {
      if (t !== null) {
        var f = t.memoizedState;
        if (f === null)
          return !1;
      }
      return I0(e, Ov);
    }
    function ak(e, t) {
      return Dc(e.childLanes, t);
    }
    function x1(e, t, a) {
      var s = t.pendingProps;
      pL(t) && (t.flags |= At);
      var f = nu.current, v = !1, _ = (t.flags & At) !== pt;
      if (_ || ik(f, e) ? (v = !0, t.flags &= ~At) : (e === null || e.memoizedState !== null) && (f = MD(f, IT)), f = Wh(f), Xc(t, f), e === null) {
        o0(t);
        var E = t.memoizedState;
        if (E !== null) {
          var x = E.dehydrated;
          if (x !== null)
            return ck(t, x);
        }
        var k = s.children, O = s.fallback;
        if (v) {
          var V = ok(t, k, O, a), B = t.child;
          return B.memoizedState = xS(a), t.memoizedState = CS, V;
        } else
          return bS(t, k);
      } else {
        var ne = e.memoizedState;
        if (ne !== null) {
          var re = ne.dehydrated;
          if (re !== null)
            return fk(e, t, _, s, re, ne, a);
        }
        if (v) {
          var de = s.fallback, Ge = s.children, wt = uk(e, t, Ge, de, a), dt = t.child, vn = e.child.memoizedState;
          return dt.memoizedState = vn === null ? xS(a) : rk(vn, a), dt.childLanes = ak(e, a), t.memoizedState = CS, wt;
        } else {
          var ln = s.children, K = sk(e, t, ln, a);
          return t.memoizedState = null, K;
        }
      }
    }
    function bS(e, t, a) {
      var s = e.mode, f = {
        mode: "visible",
        children: t
      }, v = MS(f, s);
      return v.return = e, e.child = v, v;
    }
    function ok(e, t, a, s) {
      var f = e.mode, v = e.child, _ = {
        mode: "hidden",
        children: t
      }, E, x;
      return (f & Jt) === Tt && v !== null ? (E = v, E.childLanes = pe, E.pendingProps = _, e.mode & bt && (E.actualDuration = 0, E.actualStartTime = -1, E.selfBaseDuration = 0, E.treeBaseDuration = 0), x = sf(a, f, s, null)) : (E = MS(_, f), x = sf(a, f, s, null)), E.return = e, x.return = e, E.sibling = x, e.child = E, x;
    }
    function MS(e, t, a) {
      return bC(e, t, pe, null);
    }
    function b1(e, t) {
      return hd(e, t);
    }
    function sk(e, t, a, s) {
      var f = e.child, v = f.sibling, _ = b1(f, {
        mode: "visible",
        children: a
      });
      if ((t.mode & Jt) === Tt && (_.lanes = s), _.return = t, _.sibling = null, v !== null) {
        var E = t.deletions;
        E === null ? (t.deletions = [v], t.flags |= Rn) : E.push(v);
      }
      return t.child = _, _;
    }
    function uk(e, t, a, s, f) {
      var v = t.mode, _ = e.child, E = _.sibling, x = {
        mode: "hidden",
        children: a
      }, k;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (v & Jt) === Tt && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        t.child !== _
      ) {
        var O = t.child;
        k = O, k.childLanes = pe, k.pendingProps = x, t.mode & bt && (k.actualDuration = 0, k.actualStartTime = -1, k.selfBaseDuration = _.selfBaseDuration, k.treeBaseDuration = _.treeBaseDuration), t.deletions = null;
      } else
        k = b1(_, x), k.subtreeFlags = _.subtreeFlags & gi;
      var V;
      return E !== null ? V = hd(E, s) : (V = sf(s, v, f, null), V.flags |= rr), V.return = t, k.return = t, k.sibling = V, t.child = k, V;
    }
    function hg(e, t, a, s) {
      s !== null && s0(s), Yh(t, e.child, null, a);
      var f = t.pendingProps, v = f.children, _ = bS(t, v);
      return _.flags |= rr, t.memoizedState = null, _;
    }
    function lk(e, t, a, s, f) {
      var v = t.mode, _ = {
        mode: "visible",
        children: a
      }, E = MS(_, v), x = sf(s, v, f, null);
      return x.flags |= rr, E.return = t, x.return = t, E.sibling = x, t.child = E, (t.mode & Jt) !== Tt && Yh(t, e.child, null, f), x;
    }
    function ck(e, t, a) {
      return (e.mode & Jt) === Tt ? (C("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), e.lanes = Dt) : W_(t) ? e.lanes = El : e.lanes = ya, null;
    }
    function fk(e, t, a, s, f, v, _) {
      if (a)
        if (t.flags & Cr) {
          t.flags &= ~Cr;
          var K = hS(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return hg(e, t, _, K);
        } else {
          if (t.memoizedState !== null)
            return t.child = e.child, t.flags |= At, null;
          var he = s.children, X = s.fallback, Te = lk(e, t, he, X, _), Qe = t.child;
          return Qe.memoizedState = xS(_), t.memoizedState = CS, Te;
        }
      else {
        if (JR(), (t.mode & Jt) === Tt)
          return hg(
            e,
            t,
            _,
            // TODO: When we delete legacy mode, we should make this error argument
            // required  every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (W_(f)) {
          var E, x, k;
          {
            var O = mR(f);
            E = O.digest, x = O.message, k = O.stack;
          }
          var V;
          x ? V = new Error(x) : V = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var B = hS(V, E, k);
          return hg(e, t, _, B);
        }
        var ne = ga(_, e.childLanes);
        if (iu || ne) {
          var re = Cg();
          if (re !== null) {
            var de = d_(re, _);
            if (de !== hn && de !== v.retryLane) {
              v.retryLane = de;
              var Ge = Jn;
              xo(e, de), Ri(re, e, de, Ge);
            }
          }
          GS();
          var wt = hS(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return hg(e, t, _, wt);
        } else if (GE(f)) {
          t.flags |= At, t.child = e.child;
          var dt = zO.bind(null, e);
          return yR(f, dt), null;
        } else {
          nD(t, f, v.treeContext);
          var vn = s.children, ln = bS(t, vn);
          return ln.flags |= vo, ln;
        }
      }
    }
    function M1(e, t, a) {
      e.lanes = Zt(e.lanes, t);
      var s = e.alternate;
      s !== null && (s.lanes = Zt(s.lanes, t)), d0(e.return, t, a);
    }
    function dk(e, t, a) {
      for (var s = t; s !== null; ) {
        if (s.tag === G) {
          var f = s.memoizedState;
          f !== null && M1(s, a, e);
        } else if (s.tag === Xe)
          M1(s, a, e);
        else if (s.child !== null) {
          s.child.return = s, s = s.child;
          continue;
        }
        if (s === e)
          return;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === e)
            return;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
    }
    function hk(e) {
      for (var t = e, a = null; t !== null; ) {
        var s = t.alternate;
        s !== null && Zy(s) === null && (a = t), t = t.sibling;
      }
      return a;
    }
    function pk(e) {
      if (e !== void 0 && e !== "forwards" && e !== "backwards" && e !== "together" && !SS[e])
        if (SS[e] = !0, typeof e == "string")
          switch (e.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              C('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', e, e.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              C('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', e, e.toLowerCase());
              break;
            }
            default:
              C('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
              break;
          }
        else
          C('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
    }
    function vk(e, t) {
      e !== void 0 && !dg[e] && (e !== "collapsed" && e !== "hidden" ? (dg[e] = !0, C('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', e)) : t !== "forwards" && t !== "backwards" && (dg[e] = !0, C('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', e)));
    }
    function R1(e, t) {
      {
        var a = Ht(e), s = !a && typeof Da(e) == "function";
        if (a || s) {
          var f = a ? "array" : "iterable";
          return C("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", f, t, f), !1;
        }
      }
      return !0;
    }
    function mk(e, t) {
      if ((t === "forwards" || t === "backwards") && e !== void 0 && e !== null && e !== !1)
        if (Ht(e)) {
          for (var a = 0; a < e.length; a++)
            if (!R1(e[a], a))
              return;
        } else {
          var s = Da(e);
          if (typeof s == "function") {
            var f = s.call(e);
            if (f)
              for (var v = f.next(), _ = 0; !v.done; v = f.next()) {
                if (!R1(v.value, _))
                  return;
                _++;
              }
          } else
            C('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', t);
        }
    }
    function RS(e, t, a, s, f) {
      var v = e.memoizedState;
      v === null ? e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: s,
        tail: a,
        tailMode: f
      } : (v.isBackwards = t, v.rendering = null, v.renderingStartTime = 0, v.last = s, v.tail = a, v.tailMode = f);
    }
    function D1(e, t, a) {
      var s = t.pendingProps, f = s.revealOrder, v = s.tail, _ = s.children;
      pk(f), vk(v, f), mk(_, f), Va(e, t, _, a);
      var E = nu.current, x = I0(E, Ov);
      if (x)
        E = j0(E, Ov), t.flags |= At;
      else {
        var k = e !== null && (e.flags & At) !== pt;
        k && dk(t, t.child, a), E = Wh(E);
      }
      if (Xc(t, E), (t.mode & Jt) === Tt)
        t.memoizedState = null;
      else
        switch (f) {
          case "forwards": {
            var O = hk(t.child), V;
            O === null ? (V = t.child, t.child = null) : (V = O.sibling, O.sibling = null), RS(
              t,
              !1,
              // isBackwards
              V,
              O,
              v
            );
            break;
          }
          case "backwards": {
            var B = null, ne = t.child;
            for (t.child = null; ne !== null; ) {
              var re = ne.alternate;
              if (re !== null && Zy(re) === null) {
                t.child = ne;
                break;
              }
              var de = ne.sibling;
              ne.sibling = B, B = ne, ne = de;
            }
            RS(
              t,
              !0,
              // isBackwards
              B,
              null,
              // last
              v
            );
            break;
          }
          case "together": {
            RS(
              t,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            t.memoizedState = null;
        }
      return t.child;
    }
    function yk(e, t, a) {
      A0(t, t.stateNode.containerInfo);
      var s = t.pendingProps;
      return e === null ? t.child = Yh(t, null, s, a) : Va(e, t, s, a), t.child;
    }
    var k1 = !1;
    function gk(e, t, a) {
      var s = t.type, f = s._context, v = t.pendingProps, _ = t.memoizedProps, E = v.value;
      {
        "value" in v || k1 || (k1 = !0, C("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var x = t.type.propTypes;
        x && Xs(x, v, "prop", "Context.Provider");
      }
      if (yT(t, f, E), _ !== null) {
        var k = _.value;
        if (at(k, E)) {
          if (_.children === v.children && !Ey())
            return Wl(e, t, a);
        } else
          dD(t, f, a);
      }
      var O = v.children;
      return Va(e, t, O, a), t.child;
    }
    var O1 = !1;
    function _k(e, t, a) {
      var s = t.type;
      s._context === void 0 ? s !== s.Consumer && (O1 || (O1 = !0, C("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : s = s._context;
      var f = t.pendingProps, v = f.children;
      typeof v != "function" && C("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Bh(t, a);
      var _ = ci(s);
      Pu(t);
      var E;
      return jv.current = t, vi(!0), E = v(_), vi(!1), _l(), t.flags |= Mu, Va(e, t, E, a), t.child;
    }
    function Hv() {
      iu = !0;
    }
    function pg(e, t) {
      (t.mode & Jt) === Tt && e !== null && (e.alternate = null, t.alternate = null, t.flags |= rr);
    }
    function Wl(e, t, a) {
      return e !== null && (t.dependencies = e.dependencies), d1(), Jv(t.lanes), ga(a, t.childLanes) ? (CD(e, t), t.child) : null;
    }
    function Sk(e, t, a) {
      {
        var s = t.return;
        if (s === null)
          throw new Error("Cannot swap the root fiber.");
        if (e.alternate = null, t.alternate = null, a.index = t.index, a.sibling = t.sibling, a.return = t.return, a.ref = t.ref, t === s.child)
          s.child = a;
        else {
          var f = s.child;
          if (f === null)
            throw new Error("Expected parent to have a child.");
          for (; f.sibling !== t; )
            if (f = f.sibling, f === null)
              throw new Error("Expected to find the previous sibling.");
          f.sibling = a;
        }
        var v = s.deletions;
        return v === null ? (s.deletions = [e], s.flags |= Rn) : v.push(e), a.flags |= rr, a;
      }
    }
    function DS(e, t) {
      var a = e.lanes;
      return !!ga(a, t);
    }
    function wk(e, t, a) {
      switch (t.tag) {
        case H:
          T1(t), t.stateNode, Fh();
          break;
        case J:
          zT(t);
          break;
        case j: {
          var s = t.type;
          Wu(s) && Cy(t);
          break;
        }
        case $:
          A0(t, t.stateNode.containerInfo);
          break;
        case He: {
          var f = t.memoizedProps.value, v = t.type._context;
          yT(t, v, f);
          break;
        }
        case ye:
          {
            var _ = ga(a, t.childLanes);
            _ && (t.flags |= Wt);
            {
              var E = t.stateNode;
              E.effectDuration = 0, E.passiveEffectDuration = 0;
            }
          }
          break;
        case G: {
          var x = t.memoizedState;
          if (x !== null) {
            if (x.dehydrated !== null)
              return Xc(t, Wh(nu.current)), t.flags |= At, null;
            var k = t.child, O = k.childLanes;
            if (ga(a, O))
              return x1(e, t, a);
            Xc(t, Wh(nu.current));
            var V = Wl(e, t, a);
            return V !== null ? V.sibling : null;
          } else
            Xc(t, Wh(nu.current));
          break;
        }
        case Xe: {
          var B = (e.flags & At) !== pt, ne = ga(a, t.childLanes);
          if (B) {
            if (ne)
              return D1(e, t, a);
            t.flags |= At;
          }
          var re = t.memoizedState;
          if (re !== null && (re.rendering = null, re.tail = null, re.lastEffect = null), Xc(t, nu.current), ne)
            break;
          return null;
        }
        case ut:
        case lt:
          return t.lanes = pe, S1(e, t, a);
      }
      return Wl(e, t, a);
    }
    function L1(e, t, a) {
      if (t._debugNeedsRemount && e !== null)
        return Sk(e, t, aw(t.type, t.key, t.pendingProps, t._debugOwner || null, t.mode, t.lanes));
      if (e !== null) {
        var s = e.memoizedProps, f = t.pendingProps;
        if (s !== f || Ey() || // Force a re-render if the implementation changed due to hot reload:
        t.type !== e.type)
          iu = !0;
        else {
          var v = DS(e, a);
          if (!v && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (t.flags & At) === pt)
            return iu = !1, wk(e, t, a);
          (e.flags & Df) !== pt ? iu = !0 : iu = !1;
        }
      } else if (iu = !1, qi() && $R(t)) {
        var _ = t.index, E = GR();
        aT(t, E, _);
      }
      switch (t.lanes = pe, t.tag) {
        case Z:
          return nk(e, t, t.type, a);
        case kt: {
          var x = t.elementType;
          return ek(e, t, x, a);
        }
        case z: {
          var k = t.type, O = t.pendingProps, V = t.elementType === k ? O : tu(k, O);
          return wS(e, t, k, V, a);
        }
        case j: {
          var B = t.type, ne = t.pendingProps, re = t.elementType === B ? ne : tu(B, ne);
          return E1(e, t, B, re, a);
        }
        case H:
          return KD(e, t, a);
        case J:
          return XD(e, t, a);
        case oe:
          return JD(e, t);
        case G:
          return x1(e, t, a);
        case $:
          return yk(e, t, a);
        case ve: {
          var de = t.type, Ge = t.pendingProps, wt = t.elementType === de ? Ge : tu(de, Ge);
          return y1(e, t, de, wt, a);
        }
        case ce:
          return GD(e, t, a);
        case ue:
          return QD(e, t, a);
        case ye:
          return qD(e, t, a);
        case He:
          return gk(e, t, a);
        case Ke:
          return _k(e, t, a);
        case Me: {
          var dt = t.type, vn = t.pendingProps, ln = tu(dt, vn);
          if (t.type !== t.elementType) {
            var K = dt.propTypes;
            K && Xs(
              K,
              ln,
              // Resolved for outer only
              "prop",
              rn(dt)
            );
          }
          return ln = tu(dt.type, ln), g1(e, t, dt, ln, a);
        }
        case ze:
          return _1(e, t, t.type, t.pendingProps, a);
        case It: {
          var he = t.type, X = t.pendingProps, Te = t.elementType === he ? X : tu(he, X);
          return tk(e, t, he, Te, a);
        }
        case Xe:
          return D1(e, t, a);
        case Mt:
          break;
        case ut:
          return S1(e, t, a);
      }
      throw new Error("Unknown unit of work tag (" + t.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Kh(e) {
      e.flags |= Wt;
    }
    function N1(e) {
      e.flags |= fa, e.flags |= Ep;
    }
    var P1, kS, A1, z1;
    P1 = function(e, t, a, s) {
      for (var f = t.child; f !== null; ) {
        if (f.tag === J || f.tag === oe)
          VM(e, f.stateNode);
        else if (f.tag !== $) {
          if (f.child !== null) {
            f.child.return = f, f = f.child;
            continue;
          }
        }
        if (f === t)
          return;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === t)
            return;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
    }, kS = function(e, t) {
    }, A1 = function(e, t, a, s, f) {
      var v = e.memoizedProps;
      if (v !== s) {
        var _ = t.stateNode, E = z0(), x = ZM(_, a, v, s, f, E);
        t.updateQueue = x, x && Kh(t);
      }
    }, z1 = function(e, t, a, s) {
      a !== s && Kh(t);
    };
    function Bv(e, t) {
      if (!qi())
        switch (e.tailMode) {
          case "hidden": {
            for (var a = e.tail, s = null; a !== null; )
              a.alternate !== null && (s = a), a = a.sibling;
            s === null ? e.tail = null : s.sibling = null;
            break;
          }
          case "collapsed": {
            for (var f = e.tail, v = null; f !== null; )
              f.alternate !== null && (v = f), f = f.sibling;
            v === null ? !t && e.tail !== null ? e.tail.sibling = null : e.tail = null : v.sibling = null;
            break;
          }
        }
    }
    function Xi(e) {
      var t = e.alternate !== null && e.alternate.child === e.child, a = pe, s = pt;
      if (t) {
        if ((e.mode & bt) !== Tt) {
          for (var x = e.selfBaseDuration, k = e.child; k !== null; )
            a = Zt(a, Zt(k.lanes, k.childLanes)), s |= k.subtreeFlags & gi, s |= k.flags & gi, x += k.treeBaseDuration, k = k.sibling;
          e.treeBaseDuration = x;
        } else
          for (var O = e.child; O !== null; )
            a = Zt(a, Zt(O.lanes, O.childLanes)), s |= O.subtreeFlags & gi, s |= O.flags & gi, O.return = e, O = O.sibling;
        e.subtreeFlags |= s;
      } else {
        if ((e.mode & bt) !== Tt) {
          for (var f = e.actualDuration, v = e.selfBaseDuration, _ = e.child; _ !== null; )
            a = Zt(a, Zt(_.lanes, _.childLanes)), s |= _.subtreeFlags, s |= _.flags, f += _.actualDuration, v += _.treeBaseDuration, _ = _.sibling;
          e.actualDuration = f, e.treeBaseDuration = v;
        } else
          for (var E = e.child; E !== null; )
            a = Zt(a, Zt(E.lanes, E.childLanes)), s |= E.subtreeFlags, s |= E.flags, E.return = e, E = E.sibling;
        e.subtreeFlags |= s;
      }
      return e.childLanes = a, t;
    }
    function Ek(e, t, a) {
      if (sD() && (t.mode & Jt) !== Tt && (t.flags & At) === pt)
        return dT(t), Fh(), t.flags |= Cr | Ia | ai, !1;
      var s = Dy(t);
      if (a !== null && a.dehydrated !== null)
        if (e === null) {
          if (!s)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (aD(t), Xi(t), (t.mode & bt) !== Tt) {
            var f = a !== null;
            if (f) {
              var v = t.child;
              v !== null && (t.treeBaseDuration -= v.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Fh(), (t.flags & At) === pt && (t.memoizedState = null), t.flags |= Wt, Xi(t), (t.mode & bt) !== Tt) {
            var _ = a !== null;
            if (_) {
              var E = t.child;
              E !== null && (t.treeBaseDuration -= E.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return hT(), !0;
    }
    function U1(e, t, a) {
      var s = t.pendingProps;
      switch (n0(t), t.tag) {
        case Z:
        case kt:
        case ze:
        case z:
        case ve:
        case ce:
        case ue:
        case ye:
        case Ke:
        case Me:
          return Xi(t), null;
        case j: {
          var f = t.type;
          return Wu(f) && Ty(t), Xi(t), null;
        }
        case H: {
          var v = t.stateNode;
          if (Vh(t), X_(t), H0(), v.pendingContext && (v.context = v.pendingContext, v.pendingContext = null), e === null || e.child === null) {
            var _ = Dy(t);
            if (_)
              Kh(t);
            else if (e !== null) {
              var E = e.memoizedState;
              // Check if this is a client root
              (!E.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (t.flags & Cr) !== pt) && (t.flags |= po, hT());
            }
          }
          return kS(e, t), Xi(t), null;
        }
        case J: {
          U0(t);
          var x = AT(), k = t.type;
          if (e !== null && t.stateNode != null)
            A1(e, t, k, s, x), e.ref !== t.ref && N1(t);
          else {
            if (!s) {
              if (t.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Xi(t), null;
            }
            var O = z0(), V = Dy(t);
            if (V)
              rD(t, x, O) && Kh(t);
            else {
              var B = YM(k, s, x, O, t);
              P1(B, t, !1, !1), t.stateNode = B, WM(B, k, s, x) && Kh(t);
            }
            t.ref !== null && N1(t);
          }
          return Xi(t), null;
        }
        case oe: {
          var ne = s;
          if (e && t.stateNode != null) {
            var re = e.memoizedProps;
            z1(e, t, re, ne);
          } else {
            if (typeof ne != "string" && t.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var de = AT(), Ge = z0(), wt = Dy(t);
            wt ? iD(t) && Kh(t) : t.stateNode = $M(ne, de, Ge, t);
          }
          return Xi(t), null;
        }
        case G: {
          Zh(t);
          var dt = t.memoizedState;
          if (e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
            var vn = Ek(e, t, dt);
            if (!vn)
              return t.flags & ai ? t : null;
          }
          if ((t.flags & At) !== pt)
            return t.lanes = a, (t.mode & bt) !== Tt && dS(t), t;
          var ln = dt !== null, K = e !== null && e.memoizedState !== null;
          if (ln !== K && ln) {
            var he = t.child;
            if (he.flags |= Ru, (t.mode & Jt) !== Tt) {
              var X = e === null && (t.memoizedProps.unstable_avoidThisFallback !== !0 || !se);
              X || I0(nu.current, IT) ? TO() : GS();
            }
          }
          var Te = t.updateQueue;
          if (Te !== null && (t.flags |= Wt), Xi(t), (t.mode & bt) !== Tt && ln) {
            var Qe = t.child;
            Qe !== null && (t.treeBaseDuration -= Qe.treeBaseDuration);
          }
          return null;
        }
        case $:
          return Vh(t), kS(e, t), e === null && FR(t.stateNode.containerInfo), Xi(t), null;
        case He:
          var Ve = t.type._context;
          return f0(Ve, t), Xi(t), null;
        case It: {
          var Lt = t.type;
          return Wu(Lt) && Ty(t), Xi(t), null;
        }
        case Xe: {
          Zh(t);
          var Bt = t.memoizedState;
          if (Bt === null)
            return Xi(t), null;
          var $n = (t.flags & At) !== pt, Tn = Bt.rendering;
          if (Tn === null)
            if ($n)
              Bv(Bt, !1);
            else {
              var qr = xO() && (e === null || (e.flags & At) === pt);
              if (!qr)
                for (var Cn = t.child; Cn !== null; ) {
                  var Fr = Zy(Cn);
                  if (Fr !== null) {
                    $n = !0, t.flags |= At, Bv(Bt, !1);
                    var Ea = Fr.updateQueue;
                    return Ea !== null && (t.updateQueue = Ea, t.flags |= Wt), t.subtreeFlags = pt, xD(t, a), Xc(t, j0(nu.current, Ov)), t.child;
                  }
                  Cn = Cn.sibling;
                }
              Bt.tail !== null && pr() > iC() && (t.flags |= At, $n = !0, Bv(Bt, !1), t.lanes = Ap);
            }
          else {
            if (!$n) {
              var ra = Zy(Tn);
              if (ra !== null) {
                t.flags |= At, $n = !0;
                var Xo = ra.updateQueue;
                if (Xo !== null && (t.updateQueue = Xo, t.flags |= Wt), Bv(Bt, !0), Bt.tail === null && Bt.tailMode === "hidden" && !Tn.alternate && !qi())
                  return Xi(t), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                pr() * 2 - Bt.renderingStartTime > iC() && a !== ya && (t.flags |= At, $n = !0, Bv(Bt, !1), t.lanes = Ap);
            }
            if (Bt.isBackwards)
              Tn.sibling = t.child, t.child = Tn;
            else {
              var $a = Bt.last;
              $a !== null ? $a.sibling = Tn : t.child = Tn, Bt.last = Tn;
            }
          }
          if (Bt.tail !== null) {
            var Ga = Bt.tail;
            Bt.rendering = Ga, Bt.tail = Ga.sibling, Bt.renderingStartTime = pr(), Ga.sibling = null;
            var Ta = nu.current;
            return $n ? Ta = j0(Ta, Ov) : Ta = Wh(Ta), Xc(t, Ta), Ga;
          }
          return Xi(t), null;
        }
        case Mt:
          break;
        case ut:
        case lt: {
          $S(t);
          var ql = t.memoizedState, ap = ql !== null;
          if (e !== null) {
            var im = e.memoizedState, Ju = im !== null;
            Ju !== ap && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !N && (t.flags |= Ru);
          }
          return !ap || (t.mode & Jt) === Tt ? Xi(t) : ga(Xu, ya) && (Xi(t), t.subtreeFlags & (rr | Wt) && (t.flags |= Ru)), null;
        }
        case tn:
          return null;
        case vt:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + t.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Tk(e, t, a) {
      switch (n0(t), t.tag) {
        case j: {
          var s = t.type;
          Wu(s) && Ty(t);
          var f = t.flags;
          return f & ai ? (t.flags = f & ~ai | At, (t.mode & bt) !== Tt && dS(t), t) : null;
        }
        case H: {
          t.stateNode, Vh(t), X_(t), H0();
          var v = t.flags;
          return (v & ai) !== pt && (v & At) === pt ? (t.flags = v & ~ai | At, t) : null;
        }
        case J:
          return U0(t), null;
        case G: {
          Zh(t);
          var _ = t.memoizedState;
          if (_ !== null && _.dehydrated !== null) {
            if (t.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Fh();
          }
          var E = t.flags;
          return E & ai ? (t.flags = E & ~ai | At, (t.mode & bt) !== Tt && dS(t), t) : null;
        }
        case Xe:
          return Zh(t), null;
        case $:
          return Vh(t), null;
        case He:
          var x = t.type._context;
          return f0(x, t), null;
        case ut:
        case lt:
          return $S(t), null;
        case tn:
          return null;
        default:
          return null;
      }
    }
    function I1(e, t, a) {
      switch (n0(t), t.tag) {
        case j: {
          var s = t.type.childContextTypes;
          s != null && Ty(t);
          break;
        }
        case H: {
          t.stateNode, Vh(t), X_(t), H0();
          break;
        }
        case J: {
          U0(t);
          break;
        }
        case $:
          Vh(t);
          break;
        case G:
          Zh(t);
          break;
        case Xe:
          Zh(t);
          break;
        case He:
          var f = t.type._context;
          f0(f, t);
          break;
        case ut:
        case lt:
          $S(t);
          break;
      }
    }
    var j1 = null;
    j1 = /* @__PURE__ */ new Set();
    var vg = !1, Ji = !1, Ck = typeof WeakSet == "function" ? WeakSet : Set, ot = null, Xh = null, Jh = null;
    function xk(e) {
      vs(null, function() {
        throw e;
      }), Mf();
    }
    var bk = function(e, t) {
      if (t.props = e.memoizedProps, t.state = e.memoizedState, e.mode & bt)
        try {
          qu(), t.componentWillUnmount();
        } finally {
          Qu(e);
        }
      else
        t.componentWillUnmount();
    };
    function F1(e, t) {
      try {
        tf(Ei, e);
      } catch (a) {
        sr(e, t, a);
      }
    }
    function OS(e, t, a) {
      try {
        bk(e, a);
      } catch (s) {
        sr(e, t, s);
      }
    }
    function Mk(e, t, a) {
      try {
        a.componentDidMount();
      } catch (s) {
        sr(e, t, s);
      }
    }
    function H1(e, t) {
      try {
        Y1(e);
      } catch (a) {
        sr(e, t, a);
      }
    }
    function ep(e, t) {
      var a = e.ref;
      if (a !== null)
        if (typeof a == "function") {
          var s;
          try {
            if (Oe && Rt && e.mode & bt)
              try {
                qu(), s = a(null);
              } finally {
                Qu(e);
              }
            else
              s = a(null);
          } catch (f) {
            sr(e, t, f);
          }
          typeof s == "function" && C("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Ot(e));
        } else
          a.current = null;
    }
    function mg(e, t, a) {
      try {
        a();
      } catch (s) {
        sr(e, t, s);
      }
    }
    var B1 = !1;
    function Rk(e, t) {
      HM(e.containerInfo), ot = t, Dk();
      var a = B1;
      return B1 = !1, a;
    }
    function Dk() {
      for (; ot !== null; ) {
        var e = ot, t = e.child;
        (e.subtreeFlags & wc) !== pt && t !== null ? (t.return = e, ot = t) : kk();
      }
    }
    function kk() {
      for (; ot !== null; ) {
        var e = ot;
        Qt(e);
        try {
          Ok(e);
        } catch (a) {
          sr(e, e.return, a);
        }
        nt();
        var t = e.sibling;
        if (t !== null) {
          t.return = e.return, ot = t;
          return;
        }
        ot = e.return;
      }
    }
    function Ok(e) {
      var t = e.alternate, a = e.flags;
      if ((a & po) !== pt) {
        switch (Qt(e), e.tag) {
          case z:
          case ve:
          case ze:
            break;
          case j: {
            if (t !== null) {
              var s = t.memoizedProps, f = t.memoizedState, v = e.stateNode;
              e.type === e.elementType && !ud && (v.props !== e.memoizedProps && C("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ot(e) || "instance"), v.state !== e.memoizedState && C("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ot(e) || "instance"));
              var _ = v.getSnapshotBeforeUpdate(e.elementType === e.type ? s : tu(e.type, s), f);
              {
                var E = j1;
                _ === void 0 && !E.has(e.type) && (E.add(e.type), C("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Ot(e)));
              }
              v.__reactInternalSnapshotBeforeUpdate = _;
            }
            break;
          }
          case H: {
            {
              var x = e.stateNode;
              dR(x.containerInfo);
            }
            break;
          }
          case J:
          case oe:
          case $:
          case It:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        nt();
      }
    }
    function au(e, t, a) {
      var s = t.updateQueue, f = s !== null ? s.lastEffect : null;
      if (f !== null) {
        var v = f.next, _ = v;
        do {
          if ((_.tag & e) === e) {
            var E = _.destroy;
            _.destroy = void 0, E !== void 0 && ((e & Ki) !== bo ? Yd(t) : (e & Ei) !== bo && Vd(t), (e & Zu) !== bo && tm(!0), mg(t, a, E), (e & Zu) !== bo && tm(!1), (e & Ki) !== bo ? Rm() : (e & Ei) !== bo && Ec());
          }
          _ = _.next;
        } while (_ !== v);
      }
    }
    function tf(e, t) {
      var a = t.updateQueue, s = a !== null ? a.lastEffect : null;
      if (s !== null) {
        var f = s.next, v = f;
        do {
          if ((v.tag & e) === e) {
            (e & Ki) !== bo ? Mm(t) : (e & Ei) !== bo && Dm(t);
            var _ = v.create;
            (e & Zu) !== bo && tm(!0), v.destroy = _(), (e & Zu) !== bo && tm(!1), (e & Ki) !== bo ? Lp() : (e & Ei) !== bo && km();
            {
              var E = v.destroy;
              if (E !== void 0 && typeof E != "function") {
                var x = void 0;
                (v.tag & Ei) !== pt ? x = "useLayoutEffect" : (v.tag & Zu) !== pt ? x = "useInsertionEffect" : x = "useEffect";
                var k = void 0;
                E === null ? k = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof E.then == "function" ? k = `

It looks like you wrote ` + x + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + x + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : k = " You returned: " + E, C("%s must not return anything besides a function, which is used for clean-up.%s", x, k);
              }
            }
          }
          v = v.next;
        } while (v !== f);
      }
    }
    function Lk(e, t) {
      if ((t.flags & Wt) !== pt)
        switch (t.tag) {
          case ye: {
            var a = t.stateNode.passiveEffectDuration, s = t.memoizedProps, f = s.id, v = s.onPostCommit, _ = c1(), E = t.alternate === null ? "mount" : "update";
            l1() && (E = "nested-update"), typeof v == "function" && v(f, E, a, _);
            var x = t.return;
            e:
              for (; x !== null; ) {
                switch (x.tag) {
                  case H:
                    var k = x.stateNode;
                    k.passiveEffectDuration += a;
                    break e;
                  case ye:
                    var O = x.stateNode;
                    O.passiveEffectDuration += a;
                    break e;
                }
                x = x.return;
              }
            break;
          }
        }
    }
    function Nk(e, t, a, s) {
      if ((a.flags & Ai) !== pt)
        switch (a.tag) {
          case z:
          case ve:
          case ze: {
            if (!Ji)
              if (a.mode & bt)
                try {
                  qu(), tf(Ei | wi, a);
                } finally {
                  Qu(a);
                }
              else
                tf(Ei | wi, a);
            break;
          }
          case j: {
            var f = a.stateNode;
            if (a.flags & Wt && !Ji)
              if (t === null)
                if (a.type === a.elementType && !ud && (f.props !== a.memoizedProps && C("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ot(a) || "instance"), f.state !== a.memoizedState && C("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ot(a) || "instance")), a.mode & bt)
                  try {
                    qu(), f.componentDidMount();
                  } finally {
                    Qu(a);
                  }
                else
                  f.componentDidMount();
              else {
                var v = a.elementType === a.type ? t.memoizedProps : tu(a.type, t.memoizedProps), _ = t.memoizedState;
                if (a.type === a.elementType && !ud && (f.props !== a.memoizedProps && C("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ot(a) || "instance"), f.state !== a.memoizedState && C("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ot(a) || "instance")), a.mode & bt)
                  try {
                    qu(), f.componentDidUpdate(v, _, f.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Qu(a);
                  }
                else
                  f.componentDidUpdate(v, _, f.__reactInternalSnapshotBeforeUpdate);
              }
            var E = a.updateQueue;
            E !== null && (a.type === a.elementType && !ud && (f.props !== a.memoizedProps && C("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ot(a) || "instance"), f.state !== a.memoizedState && C("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ot(a) || "instance")), TT(a, E, f));
            break;
          }
          case H: {
            var x = a.updateQueue;
            if (x !== null) {
              var k = null;
              if (a.child !== null)
                switch (a.child.tag) {
                  case J:
                    k = a.child.stateNode;
                    break;
                  case j:
                    k = a.child.stateNode;
                    break;
                }
              TT(a, x, k);
            }
            break;
          }
          case J: {
            var O = a.stateNode;
            if (t === null && a.flags & Wt) {
              var V = a.type, B = a.memoizedProps;
              XM(O, V, B);
            }
            break;
          }
          case oe:
            break;
          case $:
            break;
          case ye: {
            {
              var ne = a.memoizedProps, re = ne.onCommit, de = ne.onRender, Ge = a.stateNode.effectDuration, wt = c1(), dt = t === null ? "mount" : "update";
              l1() && (dt = "nested-update"), typeof de == "function" && de(a.memoizedProps.id, dt, a.actualDuration, a.treeBaseDuration, a.actualStartTime, wt);
              {
                typeof re == "function" && re(a.memoizedProps.id, dt, Ge, wt), kO(a);
                var vn = a.return;
                e:
                  for (; vn !== null; ) {
                    switch (vn.tag) {
                      case H:
                        var ln = vn.stateNode;
                        ln.effectDuration += Ge;
                        break e;
                      case ye:
                        var K = vn.stateNode;
                        K.effectDuration += Ge;
                        break e;
                    }
                    vn = vn.return;
                  }
              }
            }
            break;
          }
          case G: {
            Hk(e, a);
            break;
          }
          case Xe:
          case It:
          case Mt:
          case ut:
          case lt:
          case vt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Ji || a.flags & fa && Y1(a);
    }
    function Pk(e) {
      switch (e.tag) {
        case z:
        case ve:
        case ze: {
          if (e.mode & bt)
            try {
              qu(), F1(e, e.return);
            } finally {
              Qu(e);
            }
          else
            F1(e, e.return);
          break;
        }
        case j: {
          var t = e.stateNode;
          typeof t.componentDidMount == "function" && Mk(e, e.return, t), H1(e, e.return);
          break;
        }
        case J: {
          H1(e, e.return);
          break;
        }
      }
    }
    function Ak(e, t) {
      for (var a = null, s = e; ; ) {
        if (s.tag === J) {
          if (a === null) {
            a = s;
            try {
              var f = s.stateNode;
              t ? uR(f) : cR(s.stateNode, s.memoizedProps);
            } catch (_) {
              sr(e, e.return, _);
            }
          }
        } else if (s.tag === oe) {
          if (a === null)
            try {
              var v = s.stateNode;
              t ? lR(v) : fR(v, s.memoizedProps);
            } catch (_) {
              sr(e, e.return, _);
            }
        } else if (!((s.tag === ut || s.tag === lt) && s.memoizedState !== null && s !== e)) {
          if (s.child !== null) {
            s.child.return = s, s = s.child;
            continue;
          }
        }
        if (s === e)
          return;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === e)
            return;
          a === s && (a = null), s = s.return;
        }
        a === s && (a = null), s.sibling.return = s.return, s = s.sibling;
      }
    }
    function Y1(e) {
      var t = e.ref;
      if (t !== null) {
        var a = e.stateNode, s;
        switch (e.tag) {
          case J:
            s = a;
            break;
          default:
            s = a;
        }
        if (typeof t == "function") {
          var f;
          if (e.mode & bt)
            try {
              qu(), f = t(s);
            } finally {
              Qu(e);
            }
          else
            f = t(s);
          typeof f == "function" && C("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Ot(e));
        } else
          t.hasOwnProperty("current") || C("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Ot(e)), t.current = s;
      }
    }
    function zk(e) {
      var t = e.alternate;
      t !== null && (t.return = null), e.return = null;
    }
    function V1(e) {
      var t = e.alternate;
      t !== null && (e.alternate = null, V1(t));
      {
        if (e.child = null, e.deletions = null, e.sibling = null, e.tag === J) {
          var a = e.stateNode;
          a !== null && YR(a);
        }
        e.stateNode = null, e._debugOwner = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
      }
    }
    function Uk(e) {
      for (var t = e.return; t !== null; ) {
        if (W1(t))
          return t;
        t = t.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function W1(e) {
      return e.tag === J || e.tag === H || e.tag === $;
    }
    function Z1(e) {
      var t = e;
      e:
        for (; ; ) {
          for (; t.sibling === null; ) {
            if (t.return === null || W1(t.return))
              return null;
            t = t.return;
          }
          for (t.sibling.return = t.return, t = t.sibling; t.tag !== J && t.tag !== oe && t.tag !== Nt; ) {
            if (t.flags & rr || t.child === null || t.tag === $)
              continue e;
            t.child.return = t, t = t.child;
          }
          if (!(t.flags & rr))
            return t.stateNode;
        }
    }
    function Ik(e) {
      var t = Uk(e);
      switch (t.tag) {
        case J: {
          var a = t.stateNode;
          t.flags & Ln && ($E(a), t.flags &= ~Ln);
          var s = Z1(e);
          NS(e, s, a);
          break;
        }
        case H:
        case $: {
          var f = t.stateNode.containerInfo, v = Z1(e);
          LS(e, v, f);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function LS(e, t, a) {
      var s = e.tag, f = s === J || s === oe;
      if (f) {
        var v = e.stateNode;
        t ? iR(a, v, t) : nR(a, v);
      } else if (s !== $) {
        var _ = e.child;
        if (_ !== null) {
          LS(_, t, a);
          for (var E = _.sibling; E !== null; )
            LS(E, t, a), E = E.sibling;
        }
      }
    }
    function NS(e, t, a) {
      var s = e.tag, f = s === J || s === oe;
      if (f) {
        var v = e.stateNode;
        t ? rR(a, v, t) : tR(a, v);
      } else if (s !== $) {
        var _ = e.child;
        if (_ !== null) {
          NS(_, t, a);
          for (var E = _.sibling; E !== null; )
            NS(E, t, a), E = E.sibling;
        }
      }
    }
    var ea = null, ou = !1;
    function jk(e, t, a) {
      {
        var s = t;
        e:
          for (; s !== null; ) {
            switch (s.tag) {
              case J: {
                ea = s.stateNode, ou = !1;
                break e;
              }
              case H: {
                ea = s.stateNode.containerInfo, ou = !0;
                break e;
              }
              case $: {
                ea = s.stateNode.containerInfo, ou = !0;
                break e;
              }
            }
            s = s.return;
          }
        if (ea === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        $1(e, t, a), ea = null, ou = !1;
      }
      zk(a);
    }
    function nf(e, t, a) {
      for (var s = a.child; s !== null; )
        $1(e, t, s), s = s.sibling;
    }
    function $1(e, t, a) {
      switch (kp(a), a.tag) {
        case J:
          Ji || ep(a, t);
        case oe: {
          {
            var s = ea, f = ou;
            ea = null, nf(e, t, a), ea = s, ou = f, ea !== null && (ou ? oR(ea, a.stateNode) : aR(ea, a.stateNode));
          }
          return;
        }
        case Nt: {
          ea !== null && (ou ? sR(ea, a.stateNode) : V_(ea, a.stateNode));
          return;
        }
        case $: {
          {
            var v = ea, _ = ou;
            ea = a.stateNode.containerInfo, ou = !0, nf(e, t, a), ea = v, ou = _;
          }
          return;
        }
        case z:
        case ve:
        case Me:
        case ze: {
          if (!Ji) {
            var E = a.updateQueue;
            if (E !== null) {
              var x = E.lastEffect;
              if (x !== null) {
                var k = x.next, O = k;
                do {
                  var V = O, B = V.destroy, ne = V.tag;
                  B !== void 0 && ((ne & Zu) !== bo ? mg(a, t, B) : (ne & Ei) !== bo && (Vd(a), a.mode & bt ? (qu(), mg(a, t, B), Qu(a)) : mg(a, t, B), Ec())), O = O.next;
                } while (O !== k);
              }
            }
          }
          nf(e, t, a);
          return;
        }
        case j: {
          if (!Ji) {
            ep(a, t);
            var re = a.stateNode;
            typeof re.componentWillUnmount == "function" && OS(a, t, re);
          }
          nf(e, t, a);
          return;
        }
        case Mt: {
          nf(e, t, a);
          return;
        }
        case ut: {
          if (
            // TODO: Remove this dead flag
            a.mode & Jt
          ) {
            var de = Ji;
            Ji = de || a.memoizedState !== null, nf(e, t, a), Ji = de;
          } else
            nf(e, t, a);
          break;
        }
        default: {
          nf(e, t, a);
          return;
        }
      }
    }
    function Fk(e) {
      e.memoizedState;
    }
    function Hk(e, t) {
      var a = t.memoizedState;
      if (a === null) {
        var s = t.alternate;
        if (s !== null) {
          var f = s.memoizedState;
          if (f !== null) {
            var v = f.dehydrated;
            v !== null && bR(v);
          }
        }
      }
    }
    function G1(e) {
      var t = e.updateQueue;
      if (t !== null) {
        e.updateQueue = null;
        var a = e.stateNode;
        a === null && (a = e.stateNode = new Ck()), t.forEach(function(s) {
          var f = UO.bind(null, e, s);
          if (!a.has(s)) {
            if (a.add(s), _i)
              if (Xh !== null && Jh !== null)
                em(Jh, Xh);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            s.then(f, f);
          }
        });
      }
    }
    function Bk(e, t, a) {
      Xh = a, Jh = e, Qt(t), Q1(t, e), Qt(t), Xh = null, Jh = null;
    }
    function su(e, t, a) {
      var s = t.deletions;
      if (s !== null)
        for (var f = 0; f < s.length; f++) {
          var v = s[f];
          try {
            jk(e, t, v);
          } catch (x) {
            sr(v, t, x);
          }
        }
      var _ = Mn();
      if (t.subtreeFlags & pa)
        for (var E = t.child; E !== null; )
          Qt(E), Q1(E, e), E = E.sibling;
      Qt(_);
    }
    function Q1(e, t, a) {
      var s = e.alternate, f = e.flags;
      switch (e.tag) {
        case z:
        case ve:
        case Me:
        case ze: {
          if (su(t, e), Ku(e), f & Wt) {
            try {
              au(Zu | wi, e, e.return), tf(Zu | wi, e);
            } catch (Lt) {
              sr(e, e.return, Lt);
            }
            if (e.mode & bt) {
              try {
                qu(), au(Ei | wi, e, e.return);
              } catch (Lt) {
                sr(e, e.return, Lt);
              }
              Qu(e);
            } else
              try {
                au(Ei | wi, e, e.return);
              } catch (Lt) {
                sr(e, e.return, Lt);
              }
          }
          return;
        }
        case j: {
          su(t, e), Ku(e), f & fa && s !== null && ep(s, s.return);
          return;
        }
        case J: {
          su(t, e), Ku(e), f & fa && s !== null && ep(s, s.return);
          {
            if (e.flags & Ln) {
              var v = e.stateNode;
              try {
                $E(v);
              } catch (Lt) {
                sr(e, e.return, Lt);
              }
            }
            if (f & Wt) {
              var _ = e.stateNode;
              if (_ != null) {
                var E = e.memoizedProps, x = s !== null ? s.memoizedProps : E, k = e.type, O = e.updateQueue;
                if (e.updateQueue = null, O !== null)
                  try {
                    JM(_, O, k, x, E, e);
                  } catch (Lt) {
                    sr(e, e.return, Lt);
                  }
              }
            }
          }
          return;
        }
        case oe: {
          if (su(t, e), Ku(e), f & Wt) {
            if (e.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var V = e.stateNode, B = e.memoizedProps, ne = s !== null ? s.memoizedProps : B;
            try {
              eR(V, ne, B);
            } catch (Lt) {
              sr(e, e.return, Lt);
            }
          }
          return;
        }
        case H: {
          if (su(t, e), Ku(e), f & Wt && s !== null) {
            var re = s.memoizedState;
            if (re.isDehydrated)
              try {
                xR(t.containerInfo);
              } catch (Lt) {
                sr(e, e.return, Lt);
              }
          }
          return;
        }
        case $: {
          su(t, e), Ku(e);
          return;
        }
        case G: {
          su(t, e), Ku(e);
          var de = e.child;
          if (de.flags & Ru) {
            var Ge = de.stateNode, wt = de.memoizedState, dt = wt !== null;
            if (Ge.isHidden = dt, dt) {
              var vn = de.alternate !== null && de.alternate.memoizedState !== null;
              vn || EO();
            }
          }
          if (f & Wt) {
            try {
              Fk(e);
            } catch (Lt) {
              sr(e, e.return, Lt);
            }
            G1(e);
          }
          return;
        }
        case ut: {
          var ln = s !== null && s.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            e.mode & Jt
          ) {
            var K = Ji;
            Ji = K || ln, su(t, e), Ji = K;
          } else
            su(t, e);
          if (Ku(e), f & Ru) {
            var he = e.stateNode, X = e.memoizedState, Te = X !== null, Qe = e;
            if (he.isHidden = Te, Te && !ln && (Qe.mode & Jt) !== Tt) {
              ot = Qe;
              for (var Ve = Qe.child; Ve !== null; )
                ot = Ve, Vk(Ve), Ve = Ve.sibling;
            }
            Ak(Qe, Te);
          }
          return;
        }
        case Xe: {
          su(t, e), Ku(e), f & Wt && G1(e);
          return;
        }
        case Mt:
          return;
        default: {
          su(t, e), Ku(e);
          return;
        }
      }
    }
    function Ku(e) {
      var t = e.flags;
      if (t & rr) {
        try {
          Ik(e);
        } catch (a) {
          sr(e, e.return, a);
        }
        e.flags &= ~rr;
      }
      t & vo && (e.flags &= ~vo);
    }
    function Yk(e, t, a) {
      Xh = a, Jh = t, ot = e, q1(e, t, a), Xh = null, Jh = null;
    }
    function q1(e, t, a) {
      for (var s = (e.mode & Jt) !== Tt; ot !== null; ) {
        var f = ot, v = f.child;
        if (f.tag === ut && s) {
          var _ = f.memoizedState !== null, E = _ || vg;
          if (E) {
            PS(e, t, a);
            continue;
          } else {
            var x = f.alternate, k = x !== null && x.memoizedState !== null, O = k || Ji, V = vg, B = Ji;
            vg = E, Ji = O, Ji && !B && (ot = f, Wk(f));
            for (var ne = v; ne !== null; )
              ot = ne, q1(
                ne,
                // New root; bubble back up to here and stop.
                t,
                a
              ), ne = ne.sibling;
            ot = f, vg = V, Ji = B, PS(e, t, a);
            continue;
          }
        }
        (f.subtreeFlags & Ai) !== pt && v !== null ? (v.return = f, ot = v) : PS(e, t, a);
      }
    }
    function PS(e, t, a) {
      for (; ot !== null; ) {
        var s = ot;
        if ((s.flags & Ai) !== pt) {
          var f = s.alternate;
          Qt(s);
          try {
            Nk(t, f, s, a);
          } catch (_) {
            sr(s, s.return, _);
          }
          nt();
        }
        if (s === e) {
          ot = null;
          return;
        }
        var v = s.sibling;
        if (v !== null) {
          v.return = s.return, ot = v;
          return;
        }
        ot = s.return;
      }
    }
    function Vk(e) {
      for (; ot !== null; ) {
        var t = ot, a = t.child;
        switch (t.tag) {
          case z:
          case ve:
          case Me:
          case ze: {
            if (t.mode & bt)
              try {
                qu(), au(Ei, t, t.return);
              } finally {
                Qu(t);
              }
            else
              au(Ei, t, t.return);
            break;
          }
          case j: {
            ep(t, t.return);
            var s = t.stateNode;
            typeof s.componentWillUnmount == "function" && OS(t, t.return, s);
            break;
          }
          case J: {
            ep(t, t.return);
            break;
          }
          case ut: {
            var f = t.memoizedState !== null;
            if (f) {
              K1(e);
              continue;
            }
            break;
          }
        }
        a !== null ? (a.return = t, ot = a) : K1(e);
      }
    }
    function K1(e) {
      for (; ot !== null; ) {
        var t = ot;
        if (t === e) {
          ot = null;
          return;
        }
        var a = t.sibling;
        if (a !== null) {
          a.return = t.return, ot = a;
          return;
        }
        ot = t.return;
      }
    }
    function Wk(e) {
      for (; ot !== null; ) {
        var t = ot, a = t.child;
        if (t.tag === ut) {
          var s = t.memoizedState !== null;
          if (s) {
            X1(e);
            continue;
          }
        }
        a !== null ? (a.return = t, ot = a) : X1(e);
      }
    }
    function X1(e) {
      for (; ot !== null; ) {
        var t = ot;
        Qt(t);
        try {
          Pk(t);
        } catch (s) {
          sr(t, t.return, s);
        }
        if (nt(), t === e) {
          ot = null;
          return;
        }
        var a = t.sibling;
        if (a !== null) {
          a.return = t.return, ot = a;
          return;
        }
        ot = t.return;
      }
    }
    function Zk(e, t, a, s) {
      ot = t, $k(t, e, a, s);
    }
    function $k(e, t, a, s) {
      for (; ot !== null; ) {
        var f = ot, v = f.child;
        (f.subtreeFlags & mo) !== pt && v !== null ? (v.return = f, ot = v) : Gk(e, t, a, s);
      }
    }
    function Gk(e, t, a, s) {
      for (; ot !== null; ) {
        var f = ot;
        if ((f.flags & cr) !== pt) {
          Qt(f);
          try {
            Qk(t, f, a, s);
          } catch (_) {
            sr(f, f.return, _);
          }
          nt();
        }
        if (f === e) {
          ot = null;
          return;
        }
        var v = f.sibling;
        if (v !== null) {
          v.return = f.return, ot = v;
          return;
        }
        ot = f.return;
      }
    }
    function Qk(e, t, a, s) {
      switch (t.tag) {
        case z:
        case ve:
        case ze: {
          if (t.mode & bt) {
            fS();
            try {
              tf(Ki | wi, t);
            } finally {
              cS(t);
            }
          } else
            tf(Ki | wi, t);
          break;
        }
      }
    }
    function qk(e) {
      ot = e, Kk();
    }
    function Kk() {
      for (; ot !== null; ) {
        var e = ot, t = e.child;
        if ((ot.flags & Rn) !== pt) {
          var a = e.deletions;
          if (a !== null) {
            for (var s = 0; s < a.length; s++) {
              var f = a[s];
              ot = f, eO(f, e);
            }
            {
              var v = e.alternate;
              if (v !== null) {
                var _ = v.child;
                if (_ !== null) {
                  v.child = null;
                  do {
                    var E = _.sibling;
                    _.sibling = null, _ = E;
                  } while (_ !== null);
                }
              }
            }
            ot = e;
          }
        }
        (e.subtreeFlags & mo) !== pt && t !== null ? (t.return = e, ot = t) : Xk();
      }
    }
    function Xk() {
      for (; ot !== null; ) {
        var e = ot;
        (e.flags & cr) !== pt && (Qt(e), Jk(e), nt());
        var t = e.sibling;
        if (t !== null) {
          t.return = e.return, ot = t;
          return;
        }
        ot = e.return;
      }
    }
    function Jk(e) {
      switch (e.tag) {
        case z:
        case ve:
        case ze: {
          e.mode & bt ? (fS(), au(Ki | wi, e, e.return), cS(e)) : au(Ki | wi, e, e.return);
          break;
        }
      }
    }
    function eO(e, t) {
      for (; ot !== null; ) {
        var a = ot;
        Qt(a), nO(a, t), nt();
        var s = a.child;
        s !== null ? (s.return = a, ot = s) : tO(e);
      }
    }
    function tO(e) {
      for (; ot !== null; ) {
        var t = ot, a = t.sibling, s = t.return;
        if (V1(t), t === e) {
          ot = null;
          return;
        }
        if (a !== null) {
          a.return = s, ot = a;
          return;
        }
        ot = s;
      }
    }
    function nO(e, t) {
      switch (e.tag) {
        case z:
        case ve:
        case ze: {
          e.mode & bt ? (fS(), au(Ki, e, t), cS(e)) : au(Ki, e, t);
          break;
        }
      }
    }
    function rO(e) {
      switch (e.tag) {
        case z:
        case ve:
        case ze: {
          try {
            tf(Ei | wi, e);
          } catch (a) {
            sr(e, e.return, a);
          }
          break;
        }
        case j: {
          var t = e.stateNode;
          try {
            t.componentDidMount();
          } catch (a) {
            sr(e, e.return, a);
          }
          break;
        }
      }
    }
    function iO(e) {
      switch (e.tag) {
        case z:
        case ve:
        case ze: {
          try {
            tf(Ki | wi, e);
          } catch (t) {
            sr(e, e.return, t);
          }
          break;
        }
      }
    }
    function aO(e) {
      switch (e.tag) {
        case z:
        case ve:
        case ze: {
          try {
            au(Ei | wi, e, e.return);
          } catch (a) {
            sr(e, e.return, a);
          }
          break;
        }
        case j: {
          var t = e.stateNode;
          typeof t.componentWillUnmount == "function" && OS(e, e.return, t);
          break;
        }
      }
    }
    function oO(e) {
      switch (e.tag) {
        case z:
        case ve:
        case ze:
          try {
            au(Ki | wi, e, e.return);
          } catch (t) {
            sr(e, e.return, t);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var Yv = Symbol.for;
      Yv("selector.component"), Yv("selector.has_pseudo_class"), Yv("selector.role"), Yv("selector.test_id"), Yv("selector.text");
    }
    var sO = [];
    function uO() {
      sO.forEach(function(e) {
        return e();
      });
    }
    var lO = d.ReactCurrentActQueue;
    function cO(e) {
      {
        var t = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), a = typeof jest < "u";
        return a && t !== !1;
      }
    }
    function J1() {
      {
        var e = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !e && lO.current !== null && C("The current testing environment is not configured to support act(...)"), e;
      }
    }
    var fO = Math.ceil, AS = d.ReactCurrentDispatcher, zS = d.ReactCurrentOwner, ta = d.ReactCurrentBatchConfig, uu = d.ReactCurrentActQueue, xi = (
      /*             */
      0
    ), eC = (
      /*               */
      1
    ), na = (
      /*                */
      2
    ), Ms = (
      /*                */
      4
    ), Zl = 0, Vv = 1, ld = 2, yg = 3, Wv = 4, tC = 5, US = 6, pn = xi, Wa = null, Ar = null, bi = pe, Xu = pe, IS = Zc(pe), Mi = Zl, Zv = null, gg = pe, $v = pe, _g = pe, Gv = null, Mo = null, jS = 0, nC = 500, rC = 1 / 0, dO = 500, $l = null;
    function Qv() {
      rC = pr() + dO;
    }
    function iC() {
      return rC;
    }
    var Sg = !1, FS = null, tp = null, cd = !1, rf = null, qv = pe, HS = [], BS = null, hO = 50, Kv = 0, YS = null, VS = !1, wg = !1, pO = 50, np = 0, Eg = null, Xv = Jn, Tg = pe, aC = !1;
    function Cg() {
      return Wa;
    }
    function Za() {
      return (pn & (na | Ms)) !== xi ? pr() : (Xv !== Jn || (Xv = pr()), Xv);
    }
    function af(e) {
      var t = e.mode;
      if ((t & Jt) === Tt)
        return Dt;
      if ((pn & na) !== xi && bi !== pe)
        return Zr(bi);
      var a = cD() !== lD;
      if (a) {
        if (ta.transition !== null) {
          var s = ta.transition;
          s._updatedFibers || (s._updatedFibers = /* @__PURE__ */ new Set()), s._updatedFibers.add(e);
        }
        return Tg === hn && (Tg = Ip()), Tg;
      }
      var f = So();
      if (f !== hn)
        return f;
      var v = GM();
      return v;
    }
    function vO(e) {
      var t = e.mode;
      return (t & Jt) === Tt ? Dt : f_();
    }
    function Ri(e, t, a, s) {
      jO(), aC && C("useInsertionEffect must not schedule updates."), VS && (wg = !0), Dl(e, a, s), (pn & na) !== pe && e === Wa ? BO(t) : (_i && Yp(e, t, a), YO(t), e === Wa && ((pn & na) === xi && ($v = Zt($v, a)), Mi === Wv && of(e, bi)), Ro(e, s), a === Dt && pn === xi && (t.mode & Jt) === Tt && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !uu.isBatchingLegacy && (Qv(), iT()));
    }
    function mO(e, t, a) {
      var s = e.current;
      s.lanes = t, Dl(e, t, a), Ro(e, a);
    }
    function yO(e) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (pn & na) !== xi
      );
    }
    function Ro(e, t) {
      var a = e.callbackNode;
      u_(e, t);
      var s = Af(e, e === Wa ? bi : pe);
      if (s === pe) {
        a !== null && wC(a), e.callbackNode = null, e.callbackPriority = hn;
        return;
      }
      var f = Ir(s), v = e.callbackPriority;
      if (v === f && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(uu.current !== null && a !== KS)) {
        a == null && v !== Dt && C("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      a != null && wC(a);
      var _;
      if (f === Dt)
        e.tag === $c ? (uu.isBatchingLegacy !== null && (uu.didScheduleLegacyUpdate = !0), ZR(uC.bind(null, e))) : rT(uC.bind(null, e)), uu.current !== null ? uu.current.push(Gc) : qM(function() {
          (pn & (na | Ms)) === xi && Gc();
        }), _ = null;
      else {
        var E;
        switch (Ff(s)) {
          case zi:
            E = Fd;
            break;
          case Si:
            E = Ha;
            break;
          case $s:
            E = ys;
            break;
          case If:
            E = ku;
            break;
          default:
            E = ys;
            break;
        }
        _ = XS(E, oC.bind(null, e));
      }
      e.callbackPriority = f, e.callbackNode = _;
    }
    function oC(e, t) {
      if (jD(), Xv = Jn, Tg = pe, (pn & (na | Ms)) !== xi)
        throw new Error("Should not already be working.");
      var a = e.callbackNode, s = Ql();
      if (s && e.callbackNode !== a)
        return null;
      var f = Af(e, e === Wa ? bi : pe);
      if (f === pe)
        return null;
      var v = !Uf(e, f) && !zm(e, f) && !t, _ = v ? MO(e, f) : bg(e, f);
      if (_ !== Zl) {
        if (_ === ld) {
          var E = zp(e);
          E !== pe && (f = E, _ = WS(e, E));
        }
        if (_ === Vv) {
          var x = Zv;
          throw fd(e, pe), of(e, f), Ro(e, pr()), x;
        }
        if (_ === US)
          of(e, f);
        else {
          var k = !Uf(e, f), O = e.current.alternate;
          if (k && !_O(O)) {
            if (_ = bg(e, f), _ === ld) {
              var V = zp(e);
              V !== pe && (f = V, _ = WS(e, V));
            }
            if (_ === Vv) {
              var B = Zv;
              throw fd(e, pe), of(e, f), Ro(e, pr()), B;
            }
          }
          e.finishedWork = O, e.finishedLanes = f, gO(e, _, f);
        }
      }
      return Ro(e, pr()), e.callbackNode === a ? oC.bind(null, e) : null;
    }
    function WS(e, t) {
      var a = Gv;
      if (Gr(e)) {
        var s = fd(e, t);
        s.flags |= Cr, jR(e.containerInfo);
      }
      var f = bg(e, t);
      if (f !== ld) {
        var v = Mo;
        Mo = a, v !== null && sC(v);
      }
      return f;
    }
    function sC(e) {
      Mo === null ? Mo = e : Mo.push.apply(Mo, e);
    }
    function gO(e, t, a) {
      switch (t) {
        case Zl:
        case Vv:
          throw new Error("Root did not complete. This is a bug in React.");
        case ld: {
          dd(e, Mo, $l);
          break;
        }
        case yg: {
          if (of(e, a), ch(a) && // do not delay if we're inside an act() scope
          !EC()) {
            var s = jS + nC - pr();
            if (s > 10) {
              var f = Af(e, pe);
              if (f !== pe)
                break;
              var v = e.suspendedLanes;
              if (!Rl(v, a)) {
                Za(), Hp(e, v);
                break;
              }
              e.timeoutHandle = B_(dd.bind(null, e, Mo, $l), s);
              break;
            }
          }
          dd(e, Mo, $l);
          break;
        }
        case Wv: {
          if (of(e, a), Am(a))
            break;
          if (!EC()) {
            var _ = Pm(e, a), E = _, x = pr() - E, k = IO(x) - x;
            if (k > 10) {
              e.timeoutHandle = B_(dd.bind(null, e, Mo, $l), k);
              break;
            }
          }
          dd(e, Mo, $l);
          break;
        }
        case tC: {
          dd(e, Mo, $l);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function _O(e) {
      for (var t = e; ; ) {
        if (t.flags & Rf) {
          var a = t.updateQueue;
          if (a !== null) {
            var s = a.stores;
            if (s !== null)
              for (var f = 0; f < s.length; f++) {
                var v = s[f], _ = v.getSnapshot, E = v.value;
                try {
                  if (!at(_(), E))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var x = t.child;
        if (t.subtreeFlags & Rf && x !== null) {
          x.return = t, t = x;
          continue;
        }
        if (t === e)
          return !0;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e)
            return !0;
          t = t.return;
        }
        t.sibling.return = t.return, t = t.sibling;
      }
      return !0;
    }
    function of(e, t) {
      t = Dc(t, _g), t = Dc(t, $v), Fp(e, t);
    }
    function uC(e) {
      if (FD(), (pn & (na | Ms)) !== xi)
        throw new Error("Should not already be working.");
      Ql();
      var t = Af(e, pe);
      if (!ga(t, Dt))
        return Ro(e, pr()), null;
      var a = bg(e, t);
      if (e.tag !== $c && a === ld) {
        var s = zp(e);
        s !== pe && (t = s, a = WS(e, s));
      }
      if (a === Vv) {
        var f = Zv;
        throw fd(e, pe), of(e, t), Ro(e, pr()), f;
      }
      if (a === US)
        throw new Error("Root did not complete. This is a bug in React.");
      var v = e.current.alternate;
      return e.finishedWork = v, e.finishedLanes = t, dd(e, Mo, $l), Ro(e, pr()), null;
    }
    function SO(e, t) {
      t !== pe && (kc(e, Zt(t, Dt)), Ro(e, pr()), (pn & (na | Ms)) === xi && (Qv(), Gc()));
    }
    function ZS(e, t) {
      var a = pn;
      pn |= eC;
      try {
        return e(t);
      } finally {
        pn = a, pn === xi && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !uu.isBatchingLegacy && (Qv(), iT());
      }
    }
    function wO(e, t, a, s, f) {
      var v = So(), _ = ta.transition;
      try {
        return ta.transition = null, $r(zi), e(t, a, s, f);
      } finally {
        $r(v), ta.transition = _, pn === xi && Qv();
      }
    }
    function Gl(e) {
      rf !== null && rf.tag === $c && (pn & (na | Ms)) === xi && Ql();
      var t = pn;
      pn |= eC;
      var a = ta.transition, s = So();
      try {
        return ta.transition = null, $r(zi), e ? e() : void 0;
      } finally {
        $r(s), ta.transition = a, pn = t, (pn & (na | Ms)) === xi && Gc();
      }
    }
    function lC() {
      return (pn & (na | Ms)) !== xi;
    }
    function xg(e, t) {
      Sa(IS, Xu, e), Xu = Zt(Xu, t);
    }
    function $S(e) {
      Xu = IS.current, _a(IS, e);
    }
    function fd(e, t) {
      e.finishedWork = null, e.finishedLanes = pe;
      var a = e.timeoutHandle;
      if (a !== Y_ && (e.timeoutHandle = Y_, QM(a)), Ar !== null)
        for (var s = Ar.return; s !== null; ) {
          var f = s.alternate;
          I1(f, s), s = s.return;
        }
      Wa = e;
      var v = hd(e.current, null);
      return Ar = v, bi = Xu = t, Mi = Zl, Zv = null, gg = pe, $v = pe, _g = pe, Gv = null, Mo = null, pD(), eu.discardPendingWarnings(), v;
    }
    function cC(e, t) {
      do {
        var a = Ar;
        try {
          if (Ny(), FT(), nt(), zS.current = null, a === null || a.return === null) {
            Mi = Vv, Zv = t, Ar = null;
            return;
          }
          if (Oe && a.mode & bt && fg(a, !0), qe)
            if (_l(), t !== null && typeof t == "object" && typeof t.then == "function") {
              var s = t;
              Om(a, s, bi);
            } else
              Wd(a, t, bi);
          WD(e, a.return, a, t, bi), pC(a);
        } catch (f) {
          t = f, Ar === a && a !== null ? (a = a.return, Ar = a) : a = Ar;
          continue;
        }
        return;
      } while (!0);
    }
    function fC() {
      var e = AS.current;
      return AS.current = og, e === null ? og : e;
    }
    function dC(e) {
      AS.current = e;
    }
    function EO() {
      jS = pr();
    }
    function Jv(e) {
      gg = Zt(e, gg);
    }
    function TO() {
      Mi === Zl && (Mi = yg);
    }
    function GS() {
      (Mi === Zl || Mi === yg || Mi === ld) && (Mi = Wv), Wa !== null && (zf(gg) || zf($v)) && of(Wa, bi);
    }
    function CO(e) {
      Mi !== Wv && (Mi = ld), Gv === null ? Gv = [e] : Gv.push(e);
    }
    function xO() {
      return Mi === Zl;
    }
    function bg(e, t) {
      var a = pn;
      pn |= na;
      var s = fC();
      if (Wa !== e || bi !== t) {
        if (_i) {
          var f = e.memoizedUpdaters;
          f.size > 0 && (em(e, bi), f.clear()), hh(e, t);
        }
        $l = Vp(), fd(e, t);
      }
      Go(t);
      do
        try {
          bO();
          break;
        } catch (v) {
          cC(e, v);
        }
      while (!0);
      if (Ny(), pn = a, dC(s), Ar !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Cc(), Wa = null, bi = pe, Mi;
    }
    function bO() {
      for (; Ar !== null; )
        hC(Ar);
    }
    function MO(e, t) {
      var a = pn;
      pn |= na;
      var s = fC();
      if (Wa !== e || bi !== t) {
        if (_i) {
          var f = e.memoizedUpdaters;
          f.size > 0 && (em(e, bi), f.clear()), hh(e, t);
        }
        $l = Vp(), Qv(), fd(e, t);
      }
      Go(t);
      do
        try {
          RO();
          break;
        } catch (v) {
          cC(e, v);
        }
      while (!0);
      return Ny(), dC(s), pn = a, Ar !== null ? (Of(), Zl) : (Cc(), Wa = null, bi = pe, Mi);
    }
    function RO() {
      for (; Ar !== null && !jd(); )
        hC(Ar);
    }
    function hC(e) {
      var t = e.alternate;
      Qt(e);
      var a;
      (e.mode & bt) !== Tt ? (lS(e), a = QS(t, e, Xu), fg(e, !0)) : a = QS(t, e, Xu), nt(), e.memoizedProps = e.pendingProps, a === null ? pC(e) : Ar = a, zS.current = null;
    }
    function pC(e) {
      var t = e;
      do {
        var a = t.alternate, s = t.return;
        if ((t.flags & Ia) === pt) {
          Qt(t);
          var f = void 0;
          if ((t.mode & bt) === Tt ? f = U1(a, t, Xu) : (lS(t), f = U1(a, t, Xu), fg(t, !1)), nt(), f !== null) {
            Ar = f;
            return;
          }
        } else {
          var v = Tk(a, t);
          if (v !== null) {
            v.flags &= Em, Ar = v;
            return;
          }
          if ((t.mode & bt) !== Tt) {
            fg(t, !1);
            for (var _ = t.actualDuration, E = t.child; E !== null; )
              _ += E.actualDuration, E = E.sibling;
            t.actualDuration = _;
          }
          if (s !== null)
            s.flags |= Ia, s.subtreeFlags = pt, s.deletions = null;
          else {
            Mi = US, Ar = null;
            return;
          }
        }
        var x = t.sibling;
        if (x !== null) {
          Ar = x;
          return;
        }
        t = s, Ar = t;
      } while (t !== null);
      Mi === Zl && (Mi = tC);
    }
    function dd(e, t, a) {
      var s = So(), f = ta.transition;
      try {
        ta.transition = null, $r(zi), DO(e, t, a, s);
      } finally {
        ta.transition = f, $r(s);
      }
      return null;
    }
    function DO(e, t, a, s) {
      do
        Ql();
      while (rf !== null);
      if (FO(), (pn & (na | Ms)) !== xi)
        throw new Error("Should not already be working.");
      var f = e.finishedWork, v = e.finishedLanes;
      if (Bd(v), f === null)
        return Op(), null;
      if (v === pe && C("root.finishedLanes should not be empty during a commit. This is a bug in React."), e.finishedWork = null, e.finishedLanes = pe, f === e.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      e.callbackNode = null, e.callbackPriority = hn;
      var _ = Zt(f.lanes, f.childLanes);
      Bp(e, _), e === Wa && (Wa = null, Ar = null, bi = pe), ((f.subtreeFlags & mo) !== pt || (f.flags & mo) !== pt) && (cd || (cd = !0, BS = a, XS(ys, function() {
        return Ql(), null;
      })));
      var E = (f.subtreeFlags & (wc | pa | Ai | mo)) !== pt, x = (f.flags & (wc | pa | Ai | mo)) !== pt;
      if (E || x) {
        var k = ta.transition;
        ta.transition = null;
        var O = So();
        $r(zi);
        var V = pn;
        pn |= Ms, zS.current = null, Rk(e, f), f1(), Bk(e, f, v), BM(e.containerInfo), e.current = f, Lm(v), Yk(f, e, v), Tc(), xm(), pn = V, $r(O), ta.transition = k;
      } else
        e.current = f, f1();
      var B = cd;
      if (cd ? (cd = !1, rf = e, qv = v) : (np = 0, Eg = null), _ = e.pendingLanes, _ === pe && (tp = null), B || gC(e.current, !1), Vs(f.stateNode, s), _i && e.memoizedUpdaters.clear(), uO(), Ro(e, pr()), t !== null)
        for (var ne = e.onRecoverableError, re = 0; re < t.length; re++) {
          var de = t[re], Ge = de.stack, wt = de.digest;
          ne(de.value, {
            componentStack: Ge,
            digest: wt
          });
        }
      if (Sg) {
        Sg = !1;
        var dt = FS;
        throw FS = null, dt;
      }
      return ga(qv, Dt) && e.tag !== $c && Ql(), _ = e.pendingLanes, ga(_, Dt) ? (ID(), e === YS ? Kv++ : (Kv = 0, YS = e)) : Kv = 0, Gc(), Op(), null;
    }
    function Ql() {
      if (rf !== null) {
        var e = Ff(qv), t = h_($s, e), a = ta.transition, s = So();
        try {
          return ta.transition = null, $r(t), OO();
        } finally {
          $r(s), ta.transition = a;
        }
      }
      return !1;
    }
    function kO(e) {
      HS.push(e), cd || (cd = !0, XS(ys, function() {
        return Ql(), null;
      }));
    }
    function OO() {
      if (rf === null)
        return !1;
      var e = BS;
      BS = null;
      var t = rf, a = qv;
      if (rf = null, qv = pe, (pn & (na | Ms)) !== xi)
        throw new Error("Cannot flush passive effects while already rendering.");
      VS = !0, wg = !1, Nm(a);
      var s = pn;
      pn |= Ms, qk(t.current), Zk(t, t.current, a, e);
      {
        var f = HS;
        HS = [];
        for (var v = 0; v < f.length; v++) {
          var _ = f[v];
          Lk(t, _);
        }
      }
      kf(), gC(t.current, !0), pn = s, Gc(), wg ? t === Eg ? np++ : (np = 0, Eg = t) : np = 0, VS = !1, wg = !1, Lu(t);
      {
        var E = t.current.stateNode;
        E.effectDuration = 0, E.passiveEffectDuration = 0;
      }
      return !0;
    }
    function vC(e) {
      return tp !== null && tp.has(e);
    }
    function LO(e) {
      tp === null ? tp = /* @__PURE__ */ new Set([e]) : tp.add(e);
    }
    function NO(e) {
      Sg || (Sg = !0, FS = e);
    }
    var PO = NO;
    function mC(e, t, a) {
      var s = sd(a, t), f = h1(e, s, Dt), v = qc(e, f, Dt), _ = Za();
      v !== null && (Dl(v, Dt, _), Ro(v, _));
    }
    function sr(e, t, a) {
      if (xk(a), tm(!1), e.tag === H) {
        mC(e, e, a);
        return;
      }
      var s = null;
      for (s = t; s !== null; ) {
        if (s.tag === H) {
          mC(s, e, a);
          return;
        } else if (s.tag === j) {
          var f = s.type, v = s.stateNode;
          if (typeof f.getDerivedStateFromError == "function" || typeof v.componentDidCatch == "function" && !vC(v)) {
            var _ = sd(a, e), E = vS(s, _, Dt), x = qc(s, E, Dt), k = Za();
            x !== null && (Dl(x, Dt, k), Ro(x, k));
            return;
          }
        }
        s = s.return;
      }
      C(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, a);
    }
    function AO(e, t, a) {
      var s = e.pingCache;
      s !== null && s.delete(t);
      var f = Za();
      Hp(e, a), VO(e), Wa === e && Rl(bi, a) && (Mi === Wv || Mi === yg && ch(bi) && pr() - jS < nC ? fd(e, pe) : _g = Zt(_g, a)), Ro(e, f);
    }
    function yC(e, t) {
      t === hn && (t = vO(e));
      var a = Za(), s = xo(e, t);
      s !== null && (Dl(s, t, a), Ro(s, a));
    }
    function zO(e) {
      var t = e.memoizedState, a = hn;
      t !== null && (a = t.retryLane), yC(e, a);
    }
    function UO(e, t) {
      var a = hn, s;
      switch (e.tag) {
        case G:
          s = e.stateNode;
          var f = e.memoizedState;
          f !== null && (a = f.retryLane);
          break;
        case Xe:
          s = e.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      s !== null && s.delete(t), yC(e, a);
    }
    function IO(e) {
      return e < 120 ? 120 : e < 480 ? 480 : e < 1080 ? 1080 : e < 1920 ? 1920 : e < 3e3 ? 3e3 : e < 4320 ? 4320 : fO(e / 1960) * 1960;
    }
    function jO() {
      if (Kv > hO)
        throw Kv = 0, YS = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      np > pO && (np = 0, Eg = null, C("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function FO() {
      eu.flushLegacyContextWarning(), eu.flushPendingUnsafeLifecycleWarnings();
    }
    function gC(e, t) {
      Qt(e), Mg(e, ha, aO), t && Mg(e, gl, oO), Mg(e, ha, rO), t && Mg(e, gl, iO), nt();
    }
    function Mg(e, t, a) {
      for (var s = e, f = null; s !== null; ) {
        var v = s.subtreeFlags & t;
        s !== f && s.child !== null && v !== pt ? s = s.child : ((s.flags & t) !== pt && a(s), s.sibling !== null ? s = s.sibling : s = f = s.return);
      }
    }
    var Rg = null;
    function _C(e) {
      {
        if ((pn & na) !== xi || !(e.mode & Jt))
          return;
        var t = e.tag;
        if (t !== Z && t !== H && t !== j && t !== z && t !== ve && t !== Me && t !== ze)
          return;
        var a = Ot(e) || "ReactComponent";
        if (Rg !== null) {
          if (Rg.has(a))
            return;
          Rg.add(a);
        } else
          Rg = /* @__PURE__ */ new Set([a]);
        var s = Wn;
        try {
          Qt(e), C("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          s ? Qt(e) : nt();
        }
      }
    }
    var QS;
    {
      var HO = null;
      QS = function(e, t, a) {
        var s = MC(HO, t);
        try {
          return L1(e, t, a);
        } catch (v) {
          if (eD() || v !== null && typeof v == "object" && typeof v.then == "function")
            throw v;
          if (Ny(), FT(), I1(e, t), MC(t, s), t.mode & bt && lS(t), vs(null, L1, null, e, t, a), Sp()) {
            var f = Mf();
            typeof f == "object" && f !== null && f._suppressLogging && typeof v == "object" && v !== null && !v._suppressLogging && (v._suppressLogging = !0);
          }
          throw v;
        }
      };
    }
    var SC = !1, qS;
    qS = /* @__PURE__ */ new Set();
    function BO(e) {
      if (pi && !AD())
        switch (e.tag) {
          case z:
          case ve:
          case ze: {
            var t = Ar && Ot(Ar) || "Unknown", a = t;
            if (!qS.has(a)) {
              qS.add(a);
              var s = Ot(e) || "Unknown";
              C("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", s, t, t);
            }
            break;
          }
          case j: {
            SC || (C("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), SC = !0);
            break;
          }
        }
    }
    function em(e, t) {
      if (_i) {
        var a = e.memoizedUpdaters;
        a.forEach(function(s) {
          Yp(e, s, t);
        });
      }
    }
    var KS = {};
    function XS(e, t) {
      {
        var a = uu.current;
        return a !== null ? (a.push(t), KS) : Id(e, t);
      }
    }
    function wC(e) {
      if (e !== KS)
        return Cm(e);
    }
    function EC() {
      return uu.current !== null;
    }
    function YO(e) {
      {
        if (e.mode & Jt) {
          if (!J1())
            return;
        } else if (!cO() || pn !== xi || e.tag !== z && e.tag !== ve && e.tag !== ze)
          return;
        if (uu.current === null) {
          var t = Wn;
          try {
            Qt(e), C(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Ot(e));
          } finally {
            t ? Qt(e) : nt();
          }
        }
      }
    }
    function VO(e) {
      e.tag !== $c && J1() && uu.current === null && C(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function tm(e) {
      aC = e;
    }
    var Rs = null, rp = null, WO = function(e) {
      Rs = e;
    };
    function ip(e) {
      {
        if (Rs === null)
          return e;
        var t = Rs(e);
        return t === void 0 ? e : t.current;
      }
    }
    function JS(e) {
      return ip(e);
    }
    function ew(e) {
      {
        if (Rs === null)
          return e;
        var t = Rs(e);
        if (t === void 0) {
          if (e != null && typeof e.render == "function") {
            var a = ip(e.render);
            if (e.render !== a) {
              var s = {
                $$typeof: Be,
                render: a
              };
              return e.displayName !== void 0 && (s.displayName = e.displayName), s;
            }
          }
          return e;
        }
        return t.current;
      }
    }
    function TC(e, t) {
      {
        if (Rs === null)
          return !1;
        var a = e.elementType, s = t.type, f = !1, v = typeof s == "object" && s !== null ? s.$$typeof : null;
        switch (e.tag) {
          case j: {
            typeof s == "function" && (f = !0);
            break;
          }
          case z: {
            (typeof s == "function" || v === mt) && (f = !0);
            break;
          }
          case ve: {
            (v === Be || v === mt) && (f = !0);
            break;
          }
          case Me:
          case ze: {
            (v === jt || v === mt) && (f = !0);
            break;
          }
          default:
            return !1;
        }
        if (f) {
          var _ = Rs(a);
          if (_ !== void 0 && _ === Rs(s))
            return !0;
        }
        return !1;
      }
    }
    function CC(e) {
      {
        if (Rs === null || typeof WeakSet != "function")
          return;
        rp === null && (rp = /* @__PURE__ */ new WeakSet()), rp.add(e);
      }
    }
    var ZO = function(e, t) {
      {
        if (Rs === null)
          return;
        var a = t.staleFamilies, s = t.updatedFamilies;
        Ql(), Gl(function() {
          tw(e.current, s, a);
        });
      }
    }, $O = function(e, t) {
      {
        if (e.context !== qo)
          return;
        Ql(), Gl(function() {
          nm(t, e, null, null);
        });
      }
    };
    function tw(e, t, a) {
      {
        var s = e.alternate, f = e.child, v = e.sibling, _ = e.tag, E = e.type, x = null;
        switch (_) {
          case z:
          case ze:
          case j:
            x = E;
            break;
          case ve:
            x = E.render;
            break;
        }
        if (Rs === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var k = !1, O = !1;
        if (x !== null) {
          var V = Rs(x);
          V !== void 0 && (a.has(V) ? O = !0 : t.has(V) && (_ === j ? O = !0 : k = !0));
        }
        if (rp !== null && (rp.has(e) || s !== null && rp.has(s)) && (O = !0), O && (e._debugNeedsRemount = !0), O || k) {
          var B = xo(e, Dt);
          B !== null && Ri(B, e, Dt, Jn);
        }
        f !== null && !O && tw(f, t, a), v !== null && tw(v, t, a);
      }
    }
    var GO = function(e, t) {
      {
        var a = /* @__PURE__ */ new Set(), s = new Set(t.map(function(f) {
          return f.current;
        }));
        return nw(e.current, s, a), a;
      }
    };
    function nw(e, t, a) {
      {
        var s = e.child, f = e.sibling, v = e.tag, _ = e.type, E = null;
        switch (v) {
          case z:
          case ze:
          case j:
            E = _;
            break;
          case ve:
            E = _.render;
            break;
        }
        var x = !1;
        E !== null && t.has(E) && (x = !0), x ? QO(e, a) : s !== null && nw(s, t, a), f !== null && nw(f, t, a);
      }
    }
    function QO(e, t) {
      {
        var a = qO(e, t);
        if (a)
          return;
        for (var s = e; ; ) {
          switch (s.tag) {
            case J:
              t.add(s.stateNode);
              return;
            case $:
              t.add(s.stateNode.containerInfo);
              return;
            case H:
              t.add(s.stateNode.containerInfo);
              return;
          }
          if (s.return === null)
            throw new Error("Expected to reach root first.");
          s = s.return;
        }
      }
    }
    function qO(e, t) {
      for (var a = e, s = !1; ; ) {
        if (a.tag === J)
          s = !0, t.add(a.stateNode);
        else if (a.child !== null) {
          a.child.return = a, a = a.child;
          continue;
        }
        if (a === e)
          return s;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === e)
            return s;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
      return !1;
    }
    var rw;
    {
      rw = !1;
      try {
        var xC = Object.preventExtensions({});
      } catch {
        rw = !0;
      }
    }
    function KO(e, t, a, s) {
      this.tag = e, this.key = a, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = t, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = s, this.flags = pt, this.subtreeFlags = pt, this.deletions = null, this.lanes = pe, this.childLanes = pe, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !rw && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Ko = function(e, t, a, s) {
      return new KO(e, t, a, s);
    };
    function iw(e) {
      var t = e.prototype;
      return !!(t && t.isReactComponent);
    }
    function XO(e) {
      return typeof e == "function" && !iw(e) && e.defaultProps === void 0;
    }
    function JO(e) {
      if (typeof e == "function")
        return iw(e) ? j : z;
      if (e != null) {
        var t = e.$$typeof;
        if (t === Be)
          return ve;
        if (t === jt)
          return Me;
      }
      return Z;
    }
    function hd(e, t) {
      var a = e.alternate;
      a === null ? (a = Ko(e.tag, t, e.key, e.mode), a.elementType = e.elementType, a.type = e.type, a.stateNode = e.stateNode, a._debugSource = e._debugSource, a._debugOwner = e._debugOwner, a._debugHookTypes = e._debugHookTypes, a.alternate = e, e.alternate = a) : (a.pendingProps = t, a.type = e.type, a.flags = pt, a.subtreeFlags = pt, a.deletions = null, a.actualDuration = 0, a.actualStartTime = -1), a.flags = e.flags & gi, a.childLanes = e.childLanes, a.lanes = e.lanes, a.child = e.child, a.memoizedProps = e.memoizedProps, a.memoizedState = e.memoizedState, a.updateQueue = e.updateQueue;
      var s = e.dependencies;
      switch (a.dependencies = s === null ? null : {
        lanes: s.lanes,
        firstContext: s.firstContext
      }, a.sibling = e.sibling, a.index = e.index, a.ref = e.ref, a.selfBaseDuration = e.selfBaseDuration, a.treeBaseDuration = e.treeBaseDuration, a._debugNeedsRemount = e._debugNeedsRemount, a.tag) {
        case Z:
        case z:
        case ze:
          a.type = ip(e.type);
          break;
        case j:
          a.type = JS(e.type);
          break;
        case ve:
          a.type = ew(e.type);
          break;
      }
      return a;
    }
    function eL(e, t) {
      e.flags &= gi | rr;
      var a = e.alternate;
      if (a === null)
        e.childLanes = pe, e.lanes = t, e.child = null, e.subtreeFlags = pt, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null, e.selfBaseDuration = 0, e.treeBaseDuration = 0;
      else {
        e.childLanes = a.childLanes, e.lanes = a.lanes, e.child = a.child, e.subtreeFlags = pt, e.deletions = null, e.memoizedProps = a.memoizedProps, e.memoizedState = a.memoizedState, e.updateQueue = a.updateQueue, e.type = a.type;
        var s = a.dependencies;
        e.dependencies = s === null ? null : {
          lanes: s.lanes,
          firstContext: s.firstContext
        }, e.selfBaseDuration = a.selfBaseDuration, e.treeBaseDuration = a.treeBaseDuration;
      }
      return e;
    }
    function tL(e, t, a) {
      var s;
      return e === xy ? (s = Jt, t === !0 && (s |= vr, s |= go)) : s = Tt, _i && (s |= bt), Ko(H, null, null, s);
    }
    function aw(e, t, a, s, f, v) {
      var _ = Z, E = e;
      if (typeof e == "function")
        iw(e) ? (_ = j, E = JS(E)) : E = ip(E);
      else if (typeof e == "string")
        _ = J;
      else
        e:
          switch (e) {
            case We:
              return sf(a.children, f, v, t);
            case Ra:
              _ = ue, f |= vr, (f & Jt) !== Tt && (f |= go);
              break;
            case U:
              return nL(a, f, v, t);
            case Ut:
              return rL(a, f, v, t);
            case $t:
              return iL(a, f, v, t);
            case Vn:
              return bC(a, f, v, t);
            case Ur:
            case wr:
            case Ja:
            case No:
            case Yn:
            default: {
              if (typeof e == "object" && e !== null)
                switch (e.$$typeof) {
                  case _e:
                    _ = He;
                    break e;
                  case ke:
                    _ = Ke;
                    break e;
                  case Be:
                    _ = ve, E = ew(E);
                    break e;
                  case jt:
                    _ = Me;
                    break e;
                  case mt:
                    _ = kt, E = null;
                    break e;
                }
              var x = "";
              {
                (e === void 0 || typeof e == "object" && e !== null && Object.keys(e).length === 0) && (x += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var k = s ? Ot(s) : null;
                k && (x += `

Check the render method of \`` + k + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (e == null ? e : typeof e) + "." + x));
            }
          }
      var O = Ko(_, a, t, f);
      return O.elementType = e, O.type = E, O.lanes = v, O._debugOwner = s, O;
    }
    function ow(e, t, a) {
      var s = null;
      s = e._owner;
      var f = e.type, v = e.key, _ = e.props, E = aw(f, v, _, s, t, a);
      return E._debugSource = e._source, E._debugOwner = e._owner, E;
    }
    function sf(e, t, a, s) {
      var f = Ko(ce, e, s, t);
      return f.lanes = a, f;
    }
    function nL(e, t, a, s) {
      typeof e.id != "string" && C('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof e.id);
      var f = Ko(ye, e, s, t | bt);
      return f.elementType = U, f.lanes = a, f.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, f;
    }
    function rL(e, t, a, s) {
      var f = Ko(G, e, s, t);
      return f.elementType = Ut, f.lanes = a, f;
    }
    function iL(e, t, a, s) {
      var f = Ko(Xe, e, s, t);
      return f.elementType = $t, f.lanes = a, f;
    }
    function bC(e, t, a, s) {
      var f = Ko(ut, e, s, t);
      f.elementType = Vn, f.lanes = a;
      var v = {
        isHidden: !1
      };
      return f.stateNode = v, f;
    }
    function sw(e, t, a) {
      var s = Ko(oe, e, null, t);
      return s.lanes = a, s;
    }
    function aL() {
      var e = Ko(J, null, null, Tt);
      return e.elementType = "DELETED", e;
    }
    function oL(e) {
      var t = Ko(Nt, null, null, Tt);
      return t.stateNode = e, t;
    }
    function uw(e, t, a) {
      var s = e.children !== null ? e.children : [], f = Ko($, s, e.key, t);
      return f.lanes = a, f.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: e.implementation
      }, f;
    }
    function MC(e, t) {
      return e === null && (e = Ko(Z, null, null, Tt)), e.tag = t.tag, e.key = t.key, e.elementType = t.elementType, e.type = t.type, e.stateNode = t.stateNode, e.return = t.return, e.child = t.child, e.sibling = t.sibling, e.index = t.index, e.ref = t.ref, e.pendingProps = t.pendingProps, e.memoizedProps = t.memoizedProps, e.updateQueue = t.updateQueue, e.memoizedState = t.memoizedState, e.dependencies = t.dependencies, e.mode = t.mode, e.flags = t.flags, e.subtreeFlags = t.subtreeFlags, e.deletions = t.deletions, e.lanes = t.lanes, e.childLanes = t.childLanes, e.alternate = t.alternate, e.actualDuration = t.actualDuration, e.actualStartTime = t.actualStartTime, e.selfBaseDuration = t.selfBaseDuration, e.treeBaseDuration = t.treeBaseDuration, e._debugSource = t._debugSource, e._debugOwner = t._debugOwner, e._debugNeedsRemount = t._debugNeedsRemount, e._debugHookTypes = t._debugHookTypes, e;
    }
    function sL(e, t, a, s, f) {
      this.tag = t, this.containerInfo = e, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = Y_, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = hn, this.eventTimes = dh(pe), this.expirationTimes = dh(Jn), this.pendingLanes = pe, this.suspendedLanes = pe, this.pingedLanes = pe, this.expiredLanes = pe, this.mutableReadLanes = pe, this.finishedLanes = pe, this.entangledLanes = pe, this.entanglements = dh(pe), this.identifierPrefix = s, this.onRecoverableError = f, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var v = this.pendingUpdatersLaneMap = [], _ = 0; _ < ar; _++)
          v.push(/* @__PURE__ */ new Set());
      }
      switch (t) {
        case xy:
          this._debugRootType = a ? "hydrateRoot()" : "createRoot()";
          break;
        case $c:
          this._debugRootType = a ? "hydrate()" : "render()";
          break;
      }
    }
    function RC(e, t, a, s, f, v, _, E, x, k) {
      var O = new sL(e, t, a, E, x), V = tL(t, v);
      O.current = V, V.stateNode = O;
      {
        var B = {
          element: s,
          isDehydrated: a,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        V.memoizedState = B;
      }
      return m0(V), O;
    }
    var lw = "18.2.0";
    function uL(e, t, a) {
      var s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return ki(s), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: tr,
        key: s == null ? null : "" + s,
        children: e,
        containerInfo: t,
        implementation: a
      };
    }
    var cw, fw;
    cw = !1, fw = {};
    function DC(e) {
      if (!e)
        return qo;
      var t = ca(e), a = WR(t);
      if (t.tag === j) {
        var s = t.type;
        if (Wu(s))
          return tT(t, s, a);
      }
      return a;
    }
    function lL(e, t) {
      {
        var a = ca(e);
        if (a === void 0) {
          if (typeof e.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var s = Object.keys(e).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + s);
        }
        var f = yo(a);
        if (f === null)
          return null;
        if (f.mode & vr) {
          var v = Ot(a) || "Component";
          if (!fw[v]) {
            fw[v] = !0;
            var _ = Wn;
            try {
              Qt(f), a.mode & vr ? C("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", t, t, v) : C("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", t, t, v);
            } finally {
              _ ? Qt(_) : nt();
            }
          }
        }
        return f.stateNode;
      }
    }
    function kC(e, t, a, s, f, v, _, E) {
      var x = !1, k = null;
      return RC(e, t, x, k, a, s, f, v, _);
    }
    function OC(e, t, a, s, f, v, _, E, x, k) {
      var O = !0, V = RC(a, s, O, e, f, v, _, E, x);
      V.context = DC(null);
      var B = V.current, ne = Za(), re = af(B), de = Vl(ne, re);
      return de.callback = t ?? null, qc(B, de, re), mO(V, re, ne), V;
    }
    function nm(e, t, a, s) {
      bm(t, e);
      var f = t.current, v = Za(), _ = af(f);
      Sl(_);
      var E = DC(a);
      t.context === null ? t.context = E : t.pendingContext = E, pi && Wn !== null && !cw && (cw = !0, C(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Ot(Wn) || "Unknown"));
      var x = Vl(v, _);
      x.payload = {
        element: e
      }, s = s === void 0 ? null : s, s !== null && (typeof s != "function" && C("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", s), x.callback = s);
      var k = qc(f, x, _);
      return k !== null && (Ri(k, f, _, v), Iy(k, f, _)), _;
    }
    function Dg(e) {
      var t = e.current;
      if (!t.child)
        return null;
      switch (t.child.tag) {
        case J:
          return t.child.stateNode;
        default:
          return t.child.stateNode;
      }
    }
    function cL(e) {
      switch (e.tag) {
        case H: {
          var t = e.stateNode;
          if (Gr(t)) {
            var a = l_(t);
            SO(t, a);
          }
          break;
        }
        case G: {
          Gl(function() {
            var f = xo(e, Dt);
            if (f !== null) {
              var v = Za();
              Ri(f, e, Dt, v);
            }
          });
          var s = Dt;
          dw(e, s);
          break;
        }
      }
    }
    function LC(e, t) {
      var a = e.memoizedState;
      a !== null && a.dehydrated !== null && (a.retryLane = Im(a.retryLane, t));
    }
    function dw(e, t) {
      LC(e, t);
      var a = e.alternate;
      a && LC(a, t);
    }
    function fL(e) {
      if (e.tag === G) {
        var t = xc, a = xo(e, t);
        if (a !== null) {
          var s = Za();
          Ri(a, e, t, s);
        }
        dw(e, t);
      }
    }
    function dL(e) {
      if (e.tag === G) {
        var t = af(e), a = xo(e, t);
        if (a !== null) {
          var s = Za();
          Ri(a, e, t, s);
        }
        dw(e, t);
      }
    }
    function NC(e) {
      var t = Tm(e);
      return t === null ? null : t.stateNode;
    }
    var PC = function(e) {
      return null;
    };
    function hL(e) {
      return PC(e);
    }
    var AC = function(e) {
      return !1;
    };
    function pL(e) {
      return AC(e);
    }
    var zC = null, UC = null, IC = null, jC = null, FC = null, HC = null, BC = null, YC = null, VC = null;
    {
      var WC = function(e, t, a) {
        var s = t[a], f = Ht(e) ? e.slice() : Gt({}, e);
        return a + 1 === t.length ? (Ht(f) ? f.splice(s, 1) : delete f[s], f) : (f[s] = WC(e[s], t, a + 1), f);
      }, ZC = function(e, t) {
        return WC(e, t, 0);
      }, $C = function(e, t, a, s) {
        var f = t[s], v = Ht(e) ? e.slice() : Gt({}, e);
        if (s + 1 === t.length) {
          var _ = a[s];
          v[_] = v[f], Ht(v) ? v.splice(f, 1) : delete v[f];
        } else
          v[f] = $C(
            // $FlowFixMe number or string is fine here
            e[f],
            t,
            a,
            s + 1
          );
        return v;
      }, GC = function(e, t, a) {
        if (t.length !== a.length) {
          M("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var s = 0; s < a.length - 1; s++)
            if (t[s] !== a[s]) {
              M("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return $C(e, t, a, 0);
      }, QC = function(e, t, a, s) {
        if (a >= t.length)
          return s;
        var f = t[a], v = Ht(e) ? e.slice() : Gt({}, e);
        return v[f] = QC(e[f], t, a + 1, s), v;
      }, qC = function(e, t, a) {
        return QC(e, t, 0, a);
      }, hw = function(e, t) {
        for (var a = e.memoizedState; a !== null && t > 0; )
          a = a.next, t--;
        return a;
      };
      zC = function(e, t, a, s) {
        var f = hw(e, t);
        if (f !== null) {
          var v = qC(f.memoizedState, a, s);
          f.memoizedState = v, f.baseState = v, e.memoizedProps = Gt({}, e.memoizedProps);
          var _ = xo(e, Dt);
          _ !== null && Ri(_, e, Dt, Jn);
        }
      }, UC = function(e, t, a) {
        var s = hw(e, t);
        if (s !== null) {
          var f = ZC(s.memoizedState, a);
          s.memoizedState = f, s.baseState = f, e.memoizedProps = Gt({}, e.memoizedProps);
          var v = xo(e, Dt);
          v !== null && Ri(v, e, Dt, Jn);
        }
      }, IC = function(e, t, a, s) {
        var f = hw(e, t);
        if (f !== null) {
          var v = GC(f.memoizedState, a, s);
          f.memoizedState = v, f.baseState = v, e.memoizedProps = Gt({}, e.memoizedProps);
          var _ = xo(e, Dt);
          _ !== null && Ri(_, e, Dt, Jn);
        }
      }, jC = function(e, t, a) {
        e.pendingProps = qC(e.memoizedProps, t, a), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var s = xo(e, Dt);
        s !== null && Ri(s, e, Dt, Jn);
      }, FC = function(e, t) {
        e.pendingProps = ZC(e.memoizedProps, t), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var a = xo(e, Dt);
        a !== null && Ri(a, e, Dt, Jn);
      }, HC = function(e, t, a) {
        e.pendingProps = GC(e.memoizedProps, t, a), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var s = xo(e, Dt);
        s !== null && Ri(s, e, Dt, Jn);
      }, BC = function(e) {
        var t = xo(e, Dt);
        t !== null && Ri(t, e, Dt, Jn);
      }, YC = function(e) {
        PC = e;
      }, VC = function(e) {
        AC = e;
      };
    }
    function vL(e) {
      var t = yo(e);
      return t === null ? null : t.stateNode;
    }
    function mL(e) {
      return null;
    }
    function yL() {
      return Wn;
    }
    function gL(e) {
      var t = e.findFiberByHostInstance, a = d.ReactCurrentDispatcher;
      return Dp({
        bundleType: e.bundleType,
        version: e.version,
        rendererPackageName: e.rendererPackageName,
        rendererConfig: e.rendererConfig,
        overrideHookState: zC,
        overrideHookStateDeletePath: UC,
        overrideHookStateRenamePath: IC,
        overrideProps: jC,
        overridePropsDeletePath: FC,
        overridePropsRenamePath: HC,
        setErrorHandler: YC,
        setSuspenseHandler: VC,
        scheduleUpdate: BC,
        currentDispatcherRef: a,
        findHostInstanceByFiber: vL,
        findFiberByHostInstance: t || mL,
        // React Refresh
        findHostInstancesForRefresh: GO,
        scheduleRefresh: ZO,
        scheduleRoot: $O,
        setRefreshHandler: WO,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: yL,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: lw
      });
    }
    var KC = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(e) {
      console.error(e);
    };
    function pw(e) {
      this._internalRoot = e;
    }
    kg.prototype.render = pw.prototype.render = function(e) {
      var t = this._internalRoot;
      if (t === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? C("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : Og(arguments[1]) ? C("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && C("You passed a second argument to root.render(...) but it only accepts one argument.");
        var a = t.containerInfo;
        if (a.nodeType !== En) {
          var s = NC(t.current);
          s && s.parentNode !== a && C("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      nm(e, t, null, null);
    }, kg.prototype.unmount = pw.prototype.unmount = function() {
      typeof arguments[0] == "function" && C("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var e = this._internalRoot;
      if (e !== null) {
        this._internalRoot = null;
        var t = e.containerInfo;
        lC() && C("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), Gl(function() {
          nm(null, e, null, null);
        }), qE(t);
      }
    };
    function _L(e, t) {
      if (!Og(e))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      XC(e);
      var a = !1, s = !1, f = "", v = KC;
      t != null && (t.hydrate ? M("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof t == "object" && t !== null && t.$$typeof === Xa && C(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), t.unstable_strictMode === !0 && (a = !0), t.identifierPrefix !== void 0 && (f = t.identifierPrefix), t.onRecoverableError !== void 0 && (v = t.onRecoverableError), t.transitionCallbacks !== void 0 && t.transitionCallbacks);
      var _ = kC(e, xy, null, a, s, f, v);
      gy(_.current, e);
      var E = e.nodeType === En ? e.parentNode : e;
      return cv(E), new pw(_);
    }
    function kg(e) {
      this._internalRoot = e;
    }
    function SL(e) {
      e && Zm(e);
    }
    kg.prototype.unstable_scheduleHydration = SL;
    function wL(e, t, a) {
      if (!Og(e))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      XC(e), t === void 0 && C("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var s = a ?? null, f = a != null && a.hydratedSources || null, v = !1, _ = !1, E = "", x = KC;
      a != null && (a.unstable_strictMode === !0 && (v = !0), a.identifierPrefix !== void 0 && (E = a.identifierPrefix), a.onRecoverableError !== void 0 && (x = a.onRecoverableError));
      var k = OC(t, null, e, xy, s, v, _, E, x);
      if (gy(k.current, e), cv(e), f)
        for (var O = 0; O < f.length; O++) {
          var V = f[O];
          DD(k, V);
        }
      return new kg(k);
    }
    function Og(e) {
      return !!(e && (e.nodeType === yi || e.nodeType === ri || e.nodeType === Is || !xe));
    }
    function rm(e) {
      return !!(e && (e.nodeType === yi || e.nodeType === ri || e.nodeType === Is || e.nodeType === En && e.nodeValue === " react-mount-point-unstable "));
    }
    function XC(e) {
      e.nodeType === yi && e.tagName && e.tagName.toUpperCase() === "BODY" && C("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), wv(e) && (e._reactRootContainer ? C("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : C("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var EL = d.ReactCurrentOwner, JC;
    JC = function(e) {
      if (e._reactRootContainer && e.nodeType !== En) {
        var t = NC(e._reactRootContainer.current);
        t && t.parentNode !== e && C("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var a = !!e._reactRootContainer, s = vw(e), f = !!(s && Wc(s));
      f && !a && C("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), e.nodeType === yi && e.tagName && e.tagName.toUpperCase() === "BODY" && C("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function vw(e) {
      return e ? e.nodeType === ri ? e.documentElement : e.firstChild : null;
    }
    function ex() {
    }
    function TL(e, t, a, s, f) {
      if (f) {
        if (typeof s == "function") {
          var v = s;
          s = function() {
            var B = Dg(_);
            v.call(B);
          };
        }
        var _ = OC(
          t,
          s,
          e,
          $c,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          ex
        );
        e._reactRootContainer = _, gy(_.current, e);
        var E = e.nodeType === En ? e.parentNode : e;
        return cv(E), Gl(), _;
      } else {
        for (var x; x = e.lastChild; )
          e.removeChild(x);
        if (typeof s == "function") {
          var k = s;
          s = function() {
            var B = Dg(O);
            k.call(B);
          };
        }
        var O = kC(
          e,
          $c,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          ex
        );
        e._reactRootContainer = O, gy(O.current, e);
        var V = e.nodeType === En ? e.parentNode : e;
        return cv(V), Gl(function() {
          nm(t, O, a, s);
        }), O;
      }
    }
    function CL(e, t) {
      e !== null && typeof e != "function" && C("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", t, e);
    }
    function Lg(e, t, a, s, f) {
      JC(a), CL(f === void 0 ? null : f, "render");
      var v = a._reactRootContainer, _;
      if (!v)
        _ = TL(a, t, e, f, s);
      else {
        if (_ = v, typeof f == "function") {
          var E = f;
          f = function() {
            var x = Dg(_);
            E.call(x);
          };
        }
        nm(t, _, e, f);
      }
      return Dg(_);
    }
    function xL(e) {
      {
        var t = EL.current;
        if (t !== null && t.stateNode !== null) {
          var a = t.stateNode._warnedAboutRefsInRender;
          a || C("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", rn(t.type) || "A component"), t.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return e == null ? null : e.nodeType === yi ? e : lL(e, "findDOMNode");
    }
    function bL(e, t, a) {
      if (C("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !rm(t))
        throw new Error("Target container is not a DOM element.");
      {
        var s = wv(t) && t._reactRootContainer === void 0;
        s && C("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return Lg(null, e, t, !0, a);
    }
    function ML(e, t, a) {
      if (C("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !rm(t))
        throw new Error("Target container is not a DOM element.");
      {
        var s = wv(t) && t._reactRootContainer === void 0;
        s && C("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return Lg(null, e, t, !1, a);
    }
    function RL(e, t, a, s) {
      if (C("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !rm(a))
        throw new Error("Target container is not a DOM element.");
      if (e == null || !Hs(e))
        throw new Error("parentComponent must be a valid React Component");
      return Lg(e, t, a, !1, s);
    }
    function DL(e) {
      if (!rm(e))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var t = wv(e) && e._reactRootContainer === void 0;
        t && C("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (e._reactRootContainer) {
        {
          var a = vw(e), s = a && !Wc(a);
          s && C("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return Gl(function() {
          Lg(null, null, e, !1, function() {
            e._reactRootContainer = null, qE(e);
          });
        }), !0;
      } else {
        {
          var f = vw(e), v = !!(f && Wc(f)), _ = e.nodeType === yi && rm(e.parentNode) && !!e.parentNode._reactRootContainer;
          v && C("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", _ ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    tt(cL), Fm(fL), Bf(dL), Zp(So), Bm(jf), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && C("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), Pd(LM), ie(ZS, wO, Gl);
    function kL(e, t) {
      var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!Og(t))
        throw new Error("Target container is not a DOM element.");
      return uL(e, t, null, a);
    }
    function OL(e, t, a, s) {
      return RL(e, t, a, s);
    }
    var mw = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Wc, Ah, _y, r, h, ZS]
    };
    function LL(e, t) {
      return mw.usingClientEntryPoint || C('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), _L(e, t);
    }
    function NL(e, t, a) {
      return mw.usingClientEntryPoint || C('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), wL(e, t, a);
    }
    function PL(e) {
      return lC() && C("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), Gl(e);
    }
    var AL = gL({
      findFiberByHostInstance: Xf,
      bundleType: 1,
      version: lw,
      rendererPackageName: "react-dom"
    });
    if (!AL && yn && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var tx = window.location.protocol;
      /^(https?|file):$/.test(tx) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (tx === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    ko.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = mw, ko.createPortal = kL, ko.createRoot = LL, ko.findDOMNode = xL, ko.flushSync = PL, ko.hydrate = bL, ko.hydrateRoot = NL, ko.render = ML, ko.unmountComponentAtNode = DL, ko.unstable_batchedUpdates = ZS, ko.unstable_renderSubtreeIntoContainer = OL, ko.version = lw, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), ko;
}
function Yx() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Yx);
    } catch (o) {
      console.error(o);
    }
  }
}
process.env.NODE_ENV === "production" ? (Yx(), JL()) : eN();
function tN(o) {
  throw new Error('Could not dynamically require "' + o + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
//! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var Vx;
function Ye() {
  return Vx.apply(null, arguments);
}
function nN(o) {
  Vx = o;
}
function cu(o) {
  return o instanceof Array || Object.prototype.toString.call(o) === "[object Array]";
}
function md(o) {
  return o != null && Object.prototype.toString.call(o) === "[object Object]";
}
function Pn(o, c) {
  return Object.prototype.hasOwnProperty.call(o, c);
}
function Qw(o) {
  if (Object.getOwnPropertyNames)
    return Object.getOwnPropertyNames(o).length === 0;
  var c;
  for (c in o)
    if (Pn(o, c))
      return !1;
  return !0;
}
function Oo(o) {
  return o === void 0;
}
function nc(o) {
  return typeof o == "number" || Object.prototype.toString.call(o) === "[object Number]";
}
function gm(o) {
  return o instanceof Date || Object.prototype.toString.call(o) === "[object Date]";
}
function Wx(o, c) {
  var d = [], m, w = o.length;
  for (m = 0; m < w; ++m)
    d.push(c(o[m], m));
  return d;
}
function ff(o, c) {
  for (var d in c)
    Pn(c, d) && (o[d] = c[d]);
  return Pn(c, "toString") && (o.toString = c.toString), Pn(c, "valueOf") && (o.valueOf = c.valueOf), o;
}
function rl(o, c, d, m) {
  return vb(o, c, d, m, !0).utc();
}
function rN() {
  return {
    empty: !1,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: !1,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: !1,
    userInvalidated: !1,
    iso: !1,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: !1,
    weekdayMismatch: !1
  };
}
function en(o) {
  return o._pf == null && (o._pf = rN()), o._pf;
}
var Aw;
Array.prototype.some ? Aw = Array.prototype.some : Aw = function(o) {
  var c = Object(this), d = c.length >>> 0, m;
  for (m = 0; m < d; m++)
    if (m in c && o.call(this, c[m], m, c))
      return !0;
  return !1;
};
function qw(o) {
  if (o._isValid == null) {
    var c = en(o), d = Aw.call(c.parsedDateParts, function(w) {
      return w != null;
    }), m = !isNaN(o._d.getTime()) && c.overflow < 0 && !c.empty && !c.invalidEra && !c.invalidMonth && !c.invalidWeekday && !c.weekdayMismatch && !c.nullInput && !c.invalidFormat && !c.userInvalidated && (!c.meridiem || c.meridiem && d);
    if (o._strict && (m = m && c.charsLeftOver === 0 && c.unusedTokens.length === 0 && c.bigHour === void 0), Object.isFrozen == null || !Object.isFrozen(o))
      o._isValid = m;
    else
      return m;
  }
  return o._isValid;
}
function Qg(o) {
  var c = rl(NaN);
  return o != null ? ff(en(c), o) : en(c).userInvalidated = !0, c;
}
var mx = Ye.momentProperties = [], _w = !1;
function Kw(o, c) {
  var d, m, w, M = mx.length;
  if (Oo(c._isAMomentObject) || (o._isAMomentObject = c._isAMomentObject), Oo(c._i) || (o._i = c._i), Oo(c._f) || (o._f = c._f), Oo(c._l) || (o._l = c._l), Oo(c._strict) || (o._strict = c._strict), Oo(c._tzm) || (o._tzm = c._tzm), Oo(c._isUTC) || (o._isUTC = c._isUTC), Oo(c._offset) || (o._offset = c._offset), Oo(c._pf) || (o._pf = en(c)), Oo(c._locale) || (o._locale = c._locale), M > 0)
    for (d = 0; d < M; d++)
      m = mx[d], w = c[m], Oo(w) || (o[m] = w);
  return o;
}
function _m(o) {
  Kw(this, o), this._d = new Date(o._d != null ? o._d.getTime() : NaN), this.isValid() || (this._d = /* @__PURE__ */ new Date(NaN)), _w === !1 && (_w = !0, Ye.updateOffset(this), _w = !1);
}
function fu(o) {
  return o instanceof _m || o != null && o._isAMomentObject != null;
}
function Zx(o) {
  Ye.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + o);
}
function ks(o, c) {
  var d = !0;
  return ff(function() {
    if (Ye.deprecationHandler != null && Ye.deprecationHandler(null, o), d) {
      var m = [], w, M, C, W = arguments.length;
      for (M = 0; M < W; M++) {
        if (w = "", typeof arguments[M] == "object") {
          w += `
[` + M + "] ";
          for (C in arguments[0])
            Pn(arguments[0], C) && (w += C + ": " + arguments[0][C] + ", ");
          w = w.slice(0, -2);
        } else
          w = arguments[M];
        m.push(w);
      }
      Zx(
        o + `
Arguments: ` + Array.prototype.slice.call(m).join("") + `
` + new Error().stack
      ), d = !1;
    }
    return c.apply(this, arguments);
  }, c);
}
var yx = {};
function $x(o, c) {
  Ye.deprecationHandler != null && Ye.deprecationHandler(o, c), yx[o] || (Zx(c), yx[o] = !0);
}
Ye.suppressDeprecationWarnings = !1;
Ye.deprecationHandler = null;
function il(o) {
  return typeof Function < "u" && o instanceof Function || Object.prototype.toString.call(o) === "[object Function]";
}
function iN(o) {
  var c, d;
  for (d in o)
    Pn(o, d) && (c = o[d], il(c) ? this[d] = c : this["_" + d] = c);
  this._config = o, this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function zw(o, c) {
  var d = ff({}, o), m;
  for (m in c)
    Pn(c, m) && (md(o[m]) && md(c[m]) ? (d[m] = {}, ff(d[m], o[m]), ff(d[m], c[m])) : c[m] != null ? d[m] = c[m] : delete d[m]);
  for (m in o)
    Pn(o, m) && !Pn(c, m) && md(o[m]) && (d[m] = ff({}, d[m]));
  return d;
}
function Xw(o) {
  o != null && this.set(o);
}
var Uw;
Object.keys ? Uw = Object.keys : Uw = function(o) {
  var c, d = [];
  for (c in o)
    Pn(o, c) && d.push(c);
  return d;
};
var aN = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function oN(o, c, d) {
  var m = this._calendar[o] || this._calendar.sameElse;
  return il(m) ? m.call(c, d) : m;
}
function nl(o, c, d) {
  var m = "" + Math.abs(o), w = c - m.length, M = o >= 0;
  return (M ? d ? "+" : "" : "-") + Math.pow(10, Math.max(0, w)).toString().substr(1) + m;
}
var Jw = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, Ag = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, Sw = {}, lp = {};
function Ct(o, c, d, m) {
  var w = m;
  typeof m == "string" && (w = function() {
    return this[m]();
  }), o && (lp[o] = w), c && (lp[c[0]] = function() {
    return nl(w.apply(this, arguments), c[1], c[2]);
  }), d && (lp[d] = function() {
    return this.localeData().ordinal(
      w.apply(this, arguments),
      o
    );
  });
}
function sN(o) {
  return o.match(/\[[\s\S]/) ? o.replace(/^\[|\]$/g, "") : o.replace(/\\/g, "");
}
function uN(o) {
  var c = o.match(Jw), d, m;
  for (d = 0, m = c.length; d < m; d++)
    lp[c[d]] ? c[d] = lp[c[d]] : c[d] = sN(c[d]);
  return function(w) {
    var M = "", C;
    for (C = 0; C < m; C++)
      M += il(c[C]) ? c[C].call(w, o) : c[C];
    return M;
  };
}
function Ug(o, c) {
  return o.isValid() ? (c = Gx(c, o.localeData()), Sw[c] = Sw[c] || uN(c), Sw[c](o)) : o.localeData().invalidDate();
}
function Gx(o, c) {
  var d = 5;
  function m(w) {
    return c.longDateFormat(w) || w;
  }
  for (Ag.lastIndex = 0; d >= 0 && Ag.test(o); )
    o = o.replace(
      Ag,
      m
    ), Ag.lastIndex = 0, d -= 1;
  return o;
}
var lN = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function cN(o) {
  var c = this._longDateFormat[o], d = this._longDateFormat[o.toUpperCase()];
  return c || !d ? c : (this._longDateFormat[o] = d.match(Jw).map(function(m) {
    return m === "MMMM" || m === "MM" || m === "DD" || m === "dddd" ? m.slice(1) : m;
  }).join(""), this._longDateFormat[o]);
}
var fN = "Invalid date";
function dN() {
  return this._invalidDate;
}
var hN = "%d", pN = /\d{1,2}/;
function vN(o) {
  return this._ordinal.replace("%d", o);
}
var mN = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function yN(o, c, d, m) {
  var w = this._relativeTime[d];
  return il(w) ? w(o, c, d, m) : w.replace(/%d/i, o);
}
function gN(o, c) {
  var d = this._relativeTime[o > 0 ? "future" : "past"];
  return il(d) ? d(c) : d.replace(/%s/i, c);
}
var fm = {};
function xa(o, c) {
  var d = o.toLowerCase();
  fm[d] = fm[d + "s"] = fm[c] = o;
}
function Os(o) {
  return typeof o == "string" ? fm[o] || fm[o.toLowerCase()] : void 0;
}
function eE(o) {
  var c = {}, d, m;
  for (m in o)
    Pn(o, m) && (d = Os(m), d && (c[d] = o[m]));
  return c;
}
var Qx = {};
function ba(o, c) {
  Qx[o] = c;
}
function _N(o) {
  var c = [], d;
  for (d in o)
    Pn(o, d) && c.push({ unit: d, priority: Qx[d] });
  return c.sort(function(m, w) {
    return m.priority - w.priority;
  }), c;
}
function qg(o) {
  return o % 4 === 0 && o % 100 !== 0 || o % 400 === 0;
}
function Ds(o) {
  return o < 0 ? Math.ceil(o) || 0 : Math.floor(o);
}
function fn(o) {
  var c = +o, d = 0;
  return c !== 0 && isFinite(c) && (d = Ds(c)), d;
}
function vp(o, c) {
  return function(d) {
    return d != null ? (qx(this, o, d), Ye.updateOffset(this, c), this) : Fg(this, o);
  };
}
function Fg(o, c) {
  return o.isValid() ? o._d["get" + (o._isUTC ? "UTC" : "") + c]() : NaN;
}
function qx(o, c, d) {
  o.isValid() && !isNaN(d) && (c === "FullYear" && qg(o.year()) && o.month() === 1 && o.date() === 29 ? (d = fn(d), o._d["set" + (o._isUTC ? "UTC" : "") + c](
    d,
    o.month(),
    n_(d, o.month())
  )) : o._d["set" + (o._isUTC ? "UTC" : "") + c](d));
}
function SN(o) {
  return o = Os(o), il(this[o]) ? this[o]() : this;
}
function wN(o, c) {
  if (typeof o == "object") {
    o = eE(o);
    var d = _N(o), m, w = d.length;
    for (m = 0; m < w; m++)
      this[d[m].unit](o[d[m].unit]);
  } else if (o = Os(o), il(this[o]))
    return this[o](c);
  return this;
}
var Kx = /\d/, ts = /\d\d/, Xx = /\d{3}/, tE = /\d{4}/, Kg = /[+-]?\d{6}/, _r = /\d\d?/, Jx = /\d\d\d\d?/, eb = /\d\d\d\d\d\d?/, Xg = /\d{1,3}/, nE = /\d{1,4}/, Jg = /[+-]?\d{1,6}/, mp = /\d+/, e_ = /[+-]?\d+/, EN = /Z|[+-]\d\d:?\d\d/gi, t_ = /Z|[+-]\d\d(?::?\d\d)?/gi, TN = /[+-]?\d+(\.\d{1,3})?/, Sm = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, Hg;
Hg = {};
function rt(o, c, d) {
  Hg[o] = il(c) ? c : function(m, w) {
    return m && d ? d : c;
  };
}
function CN(o, c) {
  return Pn(Hg, o) ? Hg[o](c._strict, c._locale) : new RegExp(xN(o));
}
function xN(o) {
  return Jo(
    o.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(c, d, m, w, M) {
        return d || m || w || M;
      }
    )
  );
}
function Jo(o) {
  return o.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var Iw = {};
function nr(o, c) {
  var d, m = c, w;
  for (typeof o == "string" && (o = [o]), nc(c) && (m = function(M, C) {
    C[c] = fn(M);
  }), w = o.length, d = 0; d < w; d++)
    Iw[o[d]] = m;
}
function wm(o, c) {
  nr(o, function(d, m, w, M) {
    w._w = w._w || {}, c(d, w._w, w, M);
  });
}
function bN(o, c, d) {
  c != null && Pn(Iw, o) && Iw[o](c, d._a, d, o);
}
var Ca = 0, Jl = 1, el = 2, Di = 3, lu = 4, ec = 5, vd = 6, MN = 7, RN = 8;
function DN(o, c) {
  return (o % c + c) % c;
}
var Kr;
Array.prototype.indexOf ? Kr = Array.prototype.indexOf : Kr = function(o) {
  var c;
  for (c = 0; c < this.length; ++c)
    if (this[c] === o)
      return c;
  return -1;
};
function n_(o, c) {
  if (isNaN(o) || isNaN(c))
    return NaN;
  var d = DN(c, 12);
  return o += (c - d) / 12, d === 1 ? qg(o) ? 29 : 28 : 31 - d % 7 % 2;
}
Ct("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
Ct("MMM", 0, 0, function(o) {
  return this.localeData().monthsShort(this, o);
});
Ct("MMMM", 0, 0, function(o) {
  return this.localeData().months(this, o);
});
xa("month", "M");
ba("month", 8);
rt("M", _r);
rt("MM", _r, ts);
rt("MMM", function(o, c) {
  return c.monthsShortRegex(o);
});
rt("MMMM", function(o, c) {
  return c.monthsRegex(o);
});
nr(["M", "MM"], function(o, c) {
  c[Jl] = fn(o) - 1;
});
nr(["MMM", "MMMM"], function(o, c, d, m) {
  var w = d._locale.monthsParse(o, m, d._strict);
  w != null ? c[Jl] = w : en(d).invalidMonth = o;
});
var kN = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), tb = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), nb = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, ON = Sm, LN = Sm;
function NN(o, c) {
  return o ? cu(this._months) ? this._months[o.month()] : this._months[(this._months.isFormat || nb).test(c) ? "format" : "standalone"][o.month()] : cu(this._months) ? this._months : this._months.standalone;
}
function PN(o, c) {
  return o ? cu(this._monthsShort) ? this._monthsShort[o.month()] : this._monthsShort[nb.test(c) ? "format" : "standalone"][o.month()] : cu(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
}
function AN(o, c, d) {
  var m, w, M, C = o.toLocaleLowerCase();
  if (!this._monthsParse)
    for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], m = 0; m < 12; ++m)
      M = rl([2e3, m]), this._shortMonthsParse[m] = this.monthsShort(
        M,
        ""
      ).toLocaleLowerCase(), this._longMonthsParse[m] = this.months(M, "").toLocaleLowerCase();
  return d ? c === "MMM" ? (w = Kr.call(this._shortMonthsParse, C), w !== -1 ? w : null) : (w = Kr.call(this._longMonthsParse, C), w !== -1 ? w : null) : c === "MMM" ? (w = Kr.call(this._shortMonthsParse, C), w !== -1 ? w : (w = Kr.call(this._longMonthsParse, C), w !== -1 ? w : null)) : (w = Kr.call(this._longMonthsParse, C), w !== -1 ? w : (w = Kr.call(this._shortMonthsParse, C), w !== -1 ? w : null));
}
function zN(o, c, d) {
  var m, w, M;
  if (this._monthsParseExact)
    return AN.call(this, o, c, d);
  for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), m = 0; m < 12; m++) {
    if (w = rl([2e3, m]), d && !this._longMonthsParse[m] && (this._longMonthsParse[m] = new RegExp(
      "^" + this.months(w, "").replace(".", "") + "$",
      "i"
    ), this._shortMonthsParse[m] = new RegExp(
      "^" + this.monthsShort(w, "").replace(".", "") + "$",
      "i"
    )), !d && !this._monthsParse[m] && (M = "^" + this.months(w, "") + "|^" + this.monthsShort(w, ""), this._monthsParse[m] = new RegExp(M.replace(".", ""), "i")), d && c === "MMMM" && this._longMonthsParse[m].test(o))
      return m;
    if (d && c === "MMM" && this._shortMonthsParse[m].test(o))
      return m;
    if (!d && this._monthsParse[m].test(o))
      return m;
  }
}
function rb(o, c) {
  var d;
  if (!o.isValid())
    return o;
  if (typeof c == "string") {
    if (/^\d+$/.test(c))
      c = fn(c);
    else if (c = o.localeData().monthsParse(c), !nc(c))
      return o;
  }
  return d = Math.min(o.date(), n_(o.year(), c)), o._d["set" + (o._isUTC ? "UTC" : "") + "Month"](c, d), o;
}
function ib(o) {
  return o != null ? (rb(this, o), Ye.updateOffset(this, !0), this) : Fg(this, "Month");
}
function UN() {
  return n_(this.year(), this.month());
}
function IN(o) {
  return this._monthsParseExact ? (Pn(this, "_monthsRegex") || ab.call(this), o ? this._monthsShortStrictRegex : this._monthsShortRegex) : (Pn(this, "_monthsShortRegex") || (this._monthsShortRegex = ON), this._monthsShortStrictRegex && o ? this._monthsShortStrictRegex : this._monthsShortRegex);
}
function jN(o) {
  return this._monthsParseExact ? (Pn(this, "_monthsRegex") || ab.call(this), o ? this._monthsStrictRegex : this._monthsRegex) : (Pn(this, "_monthsRegex") || (this._monthsRegex = LN), this._monthsStrictRegex && o ? this._monthsStrictRegex : this._monthsRegex);
}
function ab() {
  function o(C, W) {
    return W.length - C.length;
  }
  var c = [], d = [], m = [], w, M;
  for (w = 0; w < 12; w++)
    M = rl([2e3, w]), c.push(this.monthsShort(M, "")), d.push(this.months(M, "")), m.push(this.months(M, "")), m.push(this.monthsShort(M, ""));
  for (c.sort(o), d.sort(o), m.sort(o), w = 0; w < 12; w++)
    c[w] = Jo(c[w]), d[w] = Jo(d[w]);
  for (w = 0; w < 24; w++)
    m[w] = Jo(m[w]);
  this._monthsRegex = new RegExp("^(" + m.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp(
    "^(" + d.join("|") + ")",
    "i"
  ), this._monthsShortStrictRegex = new RegExp(
    "^(" + c.join("|") + ")",
    "i"
  );
}
Ct("Y", 0, 0, function() {
  var o = this.year();
  return o <= 9999 ? nl(o, 4) : "+" + o;
});
Ct(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
Ct(0, ["YYYY", 4], 0, "year");
Ct(0, ["YYYYY", 5], 0, "year");
Ct(0, ["YYYYYY", 6, !0], 0, "year");
xa("year", "y");
ba("year", 1);
rt("Y", e_);
rt("YY", _r, ts);
rt("YYYY", nE, tE);
rt("YYYYY", Jg, Kg);
rt("YYYYYY", Jg, Kg);
nr(["YYYYY", "YYYYYY"], Ca);
nr("YYYY", function(o, c) {
  c[Ca] = o.length === 2 ? Ye.parseTwoDigitYear(o) : fn(o);
});
nr("YY", function(o, c) {
  c[Ca] = Ye.parseTwoDigitYear(o);
});
nr("Y", function(o, c) {
  c[Ca] = parseInt(o, 10);
});
function dm(o) {
  return qg(o) ? 366 : 365;
}
Ye.parseTwoDigitYear = function(o) {
  return fn(o) + (fn(o) > 68 ? 1900 : 2e3);
};
var ob = vp("FullYear", !0);
function FN() {
  return qg(this.year());
}
function HN(o, c, d, m, w, M, C) {
  var W;
  return o < 100 && o >= 0 ? (W = new Date(o + 400, c, d, m, w, M, C), isFinite(W.getFullYear()) && W.setFullYear(o)) : W = new Date(o, c, d, m, w, M, C), W;
}
function hm(o) {
  var c, d;
  return o < 100 && o >= 0 ? (d = Array.prototype.slice.call(arguments), d[0] = o + 400, c = new Date(Date.UTC.apply(null, d)), isFinite(c.getUTCFullYear()) && c.setUTCFullYear(o)) : c = new Date(Date.UTC.apply(null, arguments)), c;
}
function Bg(o, c, d) {
  var m = 7 + c - d, w = (7 + hm(o, 0, m).getUTCDay() - c) % 7;
  return -w + m - 1;
}
function sb(o, c, d, m, w) {
  var M = (7 + d - m) % 7, C = Bg(o, m, w), W = 1 + 7 * (c - 1) + M + C, z, j;
  return W <= 0 ? (z = o - 1, j = dm(z) + W) : W > dm(o) ? (z = o + 1, j = W - dm(o)) : (z = o, j = W), {
    year: z,
    dayOfYear: j
  };
}
function pm(o, c, d) {
  var m = Bg(o.year(), c, d), w = Math.floor((o.dayOfYear() - m - 1) / 7) + 1, M, C;
  return w < 1 ? (C = o.year() - 1, M = w + tc(C, c, d)) : w > tc(o.year(), c, d) ? (M = w - tc(o.year(), c, d), C = o.year() + 1) : (C = o.year(), M = w), {
    week: M,
    year: C
  };
}
function tc(o, c, d) {
  var m = Bg(o, c, d), w = Bg(o + 1, c, d);
  return (dm(o) - m + w) / 7;
}
Ct("w", ["ww", 2], "wo", "week");
Ct("W", ["WW", 2], "Wo", "isoWeek");
xa("week", "w");
xa("isoWeek", "W");
ba("week", 5);
ba("isoWeek", 5);
rt("w", _r);
rt("ww", _r, ts);
rt("W", _r);
rt("WW", _r, ts);
wm(
  ["w", "ww", "W", "WW"],
  function(o, c, d, m) {
    c[m.substr(0, 1)] = fn(o);
  }
);
function BN(o) {
  return pm(o, this._week.dow, this._week.doy).week;
}
var YN = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function VN() {
  return this._week.dow;
}
function WN() {
  return this._week.doy;
}
function ZN(o) {
  var c = this.localeData().week(this);
  return o == null ? c : this.add((o - c) * 7, "d");
}
function $N(o) {
  var c = pm(this, 1, 4).week;
  return o == null ? c : this.add((o - c) * 7, "d");
}
Ct("d", 0, "do", "day");
Ct("dd", 0, 0, function(o) {
  return this.localeData().weekdaysMin(this, o);
});
Ct("ddd", 0, 0, function(o) {
  return this.localeData().weekdaysShort(this, o);
});
Ct("dddd", 0, 0, function(o) {
  return this.localeData().weekdays(this, o);
});
Ct("e", 0, 0, "weekday");
Ct("E", 0, 0, "isoWeekday");
xa("day", "d");
xa("weekday", "e");
xa("isoWeekday", "E");
ba("day", 11);
ba("weekday", 11);
ba("isoWeekday", 11);
rt("d", _r);
rt("e", _r);
rt("E", _r);
rt("dd", function(o, c) {
  return c.weekdaysMinRegex(o);
});
rt("ddd", function(o, c) {
  return c.weekdaysShortRegex(o);
});
rt("dddd", function(o, c) {
  return c.weekdaysRegex(o);
});
wm(["dd", "ddd", "dddd"], function(o, c, d, m) {
  var w = d._locale.weekdaysParse(o, m, d._strict);
  w != null ? c.d = w : en(d).invalidWeekday = o;
});
wm(["d", "e", "E"], function(o, c, d, m) {
  c[m] = fn(o);
});
function GN(o, c) {
  return typeof o != "string" ? o : isNaN(o) ? (o = c.weekdaysParse(o), typeof o == "number" ? o : null) : parseInt(o, 10);
}
function QN(o, c) {
  return typeof o == "string" ? c.weekdaysParse(o) % 7 || 7 : isNaN(o) ? null : o;
}
function rE(o, c) {
  return o.slice(c, 7).concat(o.slice(0, c));
}
var qN = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), ub = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), KN = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), XN = Sm, JN = Sm, eP = Sm;
function tP(o, c) {
  var d = cu(this._weekdays) ? this._weekdays : this._weekdays[o && o !== !0 && this._weekdays.isFormat.test(c) ? "format" : "standalone"];
  return o === !0 ? rE(d, this._week.dow) : o ? d[o.day()] : d;
}
function nP(o) {
  return o === !0 ? rE(this._weekdaysShort, this._week.dow) : o ? this._weekdaysShort[o.day()] : this._weekdaysShort;
}
function rP(o) {
  return o === !0 ? rE(this._weekdaysMin, this._week.dow) : o ? this._weekdaysMin[o.day()] : this._weekdaysMin;
}
function iP(o, c, d) {
  var m, w, M, C = o.toLocaleLowerCase();
  if (!this._weekdaysParse)
    for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], m = 0; m < 7; ++m)
      M = rl([2e3, 1]).day(m), this._minWeekdaysParse[m] = this.weekdaysMin(
        M,
        ""
      ).toLocaleLowerCase(), this._shortWeekdaysParse[m] = this.weekdaysShort(
        M,
        ""
      ).toLocaleLowerCase(), this._weekdaysParse[m] = this.weekdays(M, "").toLocaleLowerCase();
  return d ? c === "dddd" ? (w = Kr.call(this._weekdaysParse, C), w !== -1 ? w : null) : c === "ddd" ? (w = Kr.call(this._shortWeekdaysParse, C), w !== -1 ? w : null) : (w = Kr.call(this._minWeekdaysParse, C), w !== -1 ? w : null) : c === "dddd" ? (w = Kr.call(this._weekdaysParse, C), w !== -1 || (w = Kr.call(this._shortWeekdaysParse, C), w !== -1) ? w : (w = Kr.call(this._minWeekdaysParse, C), w !== -1 ? w : null)) : c === "ddd" ? (w = Kr.call(this._shortWeekdaysParse, C), w !== -1 || (w = Kr.call(this._weekdaysParse, C), w !== -1) ? w : (w = Kr.call(this._minWeekdaysParse, C), w !== -1 ? w : null)) : (w = Kr.call(this._minWeekdaysParse, C), w !== -1 || (w = Kr.call(this._weekdaysParse, C), w !== -1) ? w : (w = Kr.call(this._shortWeekdaysParse, C), w !== -1 ? w : null));
}
function aP(o, c, d) {
  var m, w, M;
  if (this._weekdaysParseExact)
    return iP.call(this, o, c, d);
  for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), m = 0; m < 7; m++) {
    if (w = rl([2e3, 1]).day(m), d && !this._fullWeekdaysParse[m] && (this._fullWeekdaysParse[m] = new RegExp(
      "^" + this.weekdays(w, "").replace(".", "\\.?") + "$",
      "i"
    ), this._shortWeekdaysParse[m] = new RegExp(
      "^" + this.weekdaysShort(w, "").replace(".", "\\.?") + "$",
      "i"
    ), this._minWeekdaysParse[m] = new RegExp(
      "^" + this.weekdaysMin(w, "").replace(".", "\\.?") + "$",
      "i"
    )), this._weekdaysParse[m] || (M = "^" + this.weekdays(w, "") + "|^" + this.weekdaysShort(w, "") + "|^" + this.weekdaysMin(w, ""), this._weekdaysParse[m] = new RegExp(M.replace(".", ""), "i")), d && c === "dddd" && this._fullWeekdaysParse[m].test(o))
      return m;
    if (d && c === "ddd" && this._shortWeekdaysParse[m].test(o))
      return m;
    if (d && c === "dd" && this._minWeekdaysParse[m].test(o))
      return m;
    if (!d && this._weekdaysParse[m].test(o))
      return m;
  }
}
function oP(o) {
  if (!this.isValid())
    return o != null ? this : NaN;
  var c = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  return o != null ? (o = GN(o, this.localeData()), this.add(o - c, "d")) : c;
}
function sP(o) {
  if (!this.isValid())
    return o != null ? this : NaN;
  var c = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return o == null ? c : this.add(o - c, "d");
}
function uP(o) {
  if (!this.isValid())
    return o != null ? this : NaN;
  if (o != null) {
    var c = QN(o, this.localeData());
    return this.day(this.day() % 7 ? c : c - 7);
  } else
    return this.day() || 7;
}
function lP(o) {
  return this._weekdaysParseExact ? (Pn(this, "_weekdaysRegex") || iE.call(this), o ? this._weekdaysStrictRegex : this._weekdaysRegex) : (Pn(this, "_weekdaysRegex") || (this._weekdaysRegex = XN), this._weekdaysStrictRegex && o ? this._weekdaysStrictRegex : this._weekdaysRegex);
}
function cP(o) {
  return this._weekdaysParseExact ? (Pn(this, "_weekdaysRegex") || iE.call(this), o ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (Pn(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = JN), this._weekdaysShortStrictRegex && o ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
}
function fP(o) {
  return this._weekdaysParseExact ? (Pn(this, "_weekdaysRegex") || iE.call(this), o ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (Pn(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = eP), this._weekdaysMinStrictRegex && o ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
}
function iE() {
  function o(Z, H) {
    return H.length - Z.length;
  }
  var c = [], d = [], m = [], w = [], M, C, W, z, j;
  for (M = 0; M < 7; M++)
    C = rl([2e3, 1]).day(M), W = Jo(this.weekdaysMin(C, "")), z = Jo(this.weekdaysShort(C, "")), j = Jo(this.weekdays(C, "")), c.push(W), d.push(z), m.push(j), w.push(W), w.push(z), w.push(j);
  c.sort(o), d.sort(o), m.sort(o), w.sort(o), this._weekdaysRegex = new RegExp("^(" + w.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp(
    "^(" + m.join("|") + ")",
    "i"
  ), this._weekdaysShortStrictRegex = new RegExp(
    "^(" + d.join("|") + ")",
    "i"
  ), this._weekdaysMinStrictRegex = new RegExp(
    "^(" + c.join("|") + ")",
    "i"
  );
}
function aE() {
  return this.hours() % 12 || 12;
}
function dP() {
  return this.hours() || 24;
}
Ct("H", ["HH", 2], 0, "hour");
Ct("h", ["hh", 2], 0, aE);
Ct("k", ["kk", 2], 0, dP);
Ct("hmm", 0, 0, function() {
  return "" + aE.apply(this) + nl(this.minutes(), 2);
});
Ct("hmmss", 0, 0, function() {
  return "" + aE.apply(this) + nl(this.minutes(), 2) + nl(this.seconds(), 2);
});
Ct("Hmm", 0, 0, function() {
  return "" + this.hours() + nl(this.minutes(), 2);
});
Ct("Hmmss", 0, 0, function() {
  return "" + this.hours() + nl(this.minutes(), 2) + nl(this.seconds(), 2);
});
function lb(o, c) {
  Ct(o, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      c
    );
  });
}
lb("a", !0);
lb("A", !1);
xa("hour", "h");
ba("hour", 13);
function cb(o, c) {
  return c._meridiemParse;
}
rt("a", cb);
rt("A", cb);
rt("H", _r);
rt("h", _r);
rt("k", _r);
rt("HH", _r, ts);
rt("hh", _r, ts);
rt("kk", _r, ts);
rt("hmm", Jx);
rt("hmmss", eb);
rt("Hmm", Jx);
rt("Hmmss", eb);
nr(["H", "HH"], Di);
nr(["k", "kk"], function(o, c, d) {
  var m = fn(o);
  c[Di] = m === 24 ? 0 : m;
});
nr(["a", "A"], function(o, c, d) {
  d._isPm = d._locale.isPM(o), d._meridiem = o;
});
nr(["h", "hh"], function(o, c, d) {
  c[Di] = fn(o), en(d).bigHour = !0;
});
nr("hmm", function(o, c, d) {
  var m = o.length - 2;
  c[Di] = fn(o.substr(0, m)), c[lu] = fn(o.substr(m)), en(d).bigHour = !0;
});
nr("hmmss", function(o, c, d) {
  var m = o.length - 4, w = o.length - 2;
  c[Di] = fn(o.substr(0, m)), c[lu] = fn(o.substr(m, 2)), c[ec] = fn(o.substr(w)), en(d).bigHour = !0;
});
nr("Hmm", function(o, c, d) {
  var m = o.length - 2;
  c[Di] = fn(o.substr(0, m)), c[lu] = fn(o.substr(m));
});
nr("Hmmss", function(o, c, d) {
  var m = o.length - 4, w = o.length - 2;
  c[Di] = fn(o.substr(0, m)), c[lu] = fn(o.substr(m, 2)), c[ec] = fn(o.substr(w));
});
function hP(o) {
  return (o + "").toLowerCase().charAt(0) === "p";
}
var pP = /[ap]\.?m?\.?/i, vP = vp("Hours", !0);
function mP(o, c, d) {
  return o > 11 ? d ? "pm" : "PM" : d ? "am" : "AM";
}
var fb = {
  calendar: aN,
  longDateFormat: lN,
  invalidDate: fN,
  ordinal: hN,
  dayOfMonthOrdinalParse: pN,
  relativeTime: mN,
  months: kN,
  monthsShort: tb,
  week: YN,
  weekdays: qN,
  weekdaysMin: KN,
  weekdaysShort: ub,
  meridiemParse: pP
}, Mr = {}, sm = {}, vm;
function yP(o, c) {
  var d, m = Math.min(o.length, c.length);
  for (d = 0; d < m; d += 1)
    if (o[d] !== c[d])
      return d;
  return m;
}
function gx(o) {
  return o && o.toLowerCase().replace("_", "-");
}
function gP(o) {
  for (var c = 0, d, m, w, M; c < o.length; ) {
    for (M = gx(o[c]).split("-"), d = M.length, m = gx(o[c + 1]), m = m ? m.split("-") : null; d > 0; ) {
      if (w = r_(M.slice(0, d).join("-")), w)
        return w;
      if (m && m.length >= d && yP(M, m) >= d - 1)
        break;
      d--;
    }
    c++;
  }
  return vm;
}
function _P(o) {
  return o.match("^[^/\\\\]*$") != null;
}
function r_(o) {
  var c = null, d;
  if (Mr[o] === void 0 && typeof module < "u" && module && module.exports && _P(o))
    try {
      c = vm._abbr, d = tN, d("./locale/" + o), hf(c);
    } catch {
      Mr[o] = null;
    }
  return Mr[o];
}
function hf(o, c) {
  var d;
  return o && (Oo(c) ? d = ac(o) : d = oE(o, c), d ? vm = d : typeof console < "u" && console.warn && console.warn(
    "Locale " + o + " not found. Did you forget to load it?"
  )), vm._abbr;
}
function oE(o, c) {
  if (c !== null) {
    var d, m = fb;
    if (c.abbr = o, Mr[o] != null)
      $x(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      ), m = Mr[o]._config;
    else if (c.parentLocale != null)
      if (Mr[c.parentLocale] != null)
        m = Mr[c.parentLocale]._config;
      else if (d = r_(c.parentLocale), d != null)
        m = d._config;
      else
        return sm[c.parentLocale] || (sm[c.parentLocale] = []), sm[c.parentLocale].push({
          name: o,
          config: c
        }), null;
    return Mr[o] = new Xw(zw(m, c)), sm[o] && sm[o].forEach(function(w) {
      oE(w.name, w.config);
    }), hf(o), Mr[o];
  } else
    return delete Mr[o], null;
}
function SP(o, c) {
  if (c != null) {
    var d, m, w = fb;
    Mr[o] != null && Mr[o].parentLocale != null ? Mr[o].set(zw(Mr[o]._config, c)) : (m = r_(o), m != null && (w = m._config), c = zw(w, c), m == null && (c.abbr = o), d = new Xw(c), d.parentLocale = Mr[o], Mr[o] = d), hf(o);
  } else
    Mr[o] != null && (Mr[o].parentLocale != null ? (Mr[o] = Mr[o].parentLocale, o === hf() && hf(o)) : Mr[o] != null && delete Mr[o]);
  return Mr[o];
}
function ac(o) {
  var c;
  if (o && o._locale && o._locale._abbr && (o = o._locale._abbr), !o)
    return vm;
  if (!cu(o)) {
    if (c = r_(o), c)
      return c;
    o = [o];
  }
  return gP(o);
}
function wP() {
  return Uw(Mr);
}
function sE(o) {
  var c, d = o._a;
  return d && en(o).overflow === -2 && (c = d[Jl] < 0 || d[Jl] > 11 ? Jl : d[el] < 1 || d[el] > n_(d[Ca], d[Jl]) ? el : d[Di] < 0 || d[Di] > 24 || d[Di] === 24 && (d[lu] !== 0 || d[ec] !== 0 || d[vd] !== 0) ? Di : d[lu] < 0 || d[lu] > 59 ? lu : d[ec] < 0 || d[ec] > 59 ? ec : d[vd] < 0 || d[vd] > 999 ? vd : -1, en(o)._overflowDayOfYear && (c < Ca || c > el) && (c = el), en(o)._overflowWeeks && c === -1 && (c = MN), en(o)._overflowWeekday && c === -1 && (c = RN), en(o).overflow = c), o;
}
var EP = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, TP = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, CP = /Z|[+-]\d\d(?::?\d\d)?/, zg = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, !1],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, !1],
  ["YYYY", /\d{4}/, !1]
], ww = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], xP = /^\/?Date\((-?\d+)/i, bP = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, MP = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function db(o) {
  var c, d, m = o._i, w = EP.exec(m) || TP.exec(m), M, C, W, z, j = zg.length, Z = ww.length;
  if (w) {
    for (en(o).iso = !0, c = 0, d = j; c < d; c++)
      if (zg[c][1].exec(w[1])) {
        C = zg[c][0], M = zg[c][2] !== !1;
        break;
      }
    if (C == null) {
      o._isValid = !1;
      return;
    }
    if (w[3]) {
      for (c = 0, d = Z; c < d; c++)
        if (ww[c][1].exec(w[3])) {
          W = (w[2] || " ") + ww[c][0];
          break;
        }
      if (W == null) {
        o._isValid = !1;
        return;
      }
    }
    if (!M && W != null) {
      o._isValid = !1;
      return;
    }
    if (w[4])
      if (CP.exec(w[4]))
        z = "Z";
      else {
        o._isValid = !1;
        return;
      }
    o._f = C + (W || "") + (z || ""), lE(o);
  } else
    o._isValid = !1;
}
function RP(o, c, d, m, w, M) {
  var C = [
    DP(o),
    tb.indexOf(c),
    parseInt(d, 10),
    parseInt(m, 10),
    parseInt(w, 10)
  ];
  return M && C.push(parseInt(M, 10)), C;
}
function DP(o) {
  var c = parseInt(o, 10);
  return c <= 49 ? 2e3 + c : c <= 999 ? 1900 + c : c;
}
function kP(o) {
  return o.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function OP(o, c, d) {
  if (o) {
    var m = ub.indexOf(o), w = new Date(
      c[0],
      c[1],
      c[2]
    ).getDay();
    if (m !== w)
      return en(d).weekdayMismatch = !0, d._isValid = !1, !1;
  }
  return !0;
}
function LP(o, c, d) {
  if (o)
    return MP[o];
  if (c)
    return 0;
  var m = parseInt(d, 10), w = m % 100, M = (m - w) / 100;
  return M * 60 + w;
}
function hb(o) {
  var c = bP.exec(kP(o._i)), d;
  if (c) {
    if (d = RP(
      c[4],
      c[3],
      c[2],
      c[5],
      c[6],
      c[7]
    ), !OP(c[1], d, o))
      return;
    o._a = d, o._tzm = LP(c[8], c[9], c[10]), o._d = hm.apply(null, o._a), o._d.setUTCMinutes(o._d.getUTCMinutes() - o._tzm), en(o).rfc2822 = !0;
  } else
    o._isValid = !1;
}
function NP(o) {
  var c = xP.exec(o._i);
  if (c !== null) {
    o._d = /* @__PURE__ */ new Date(+c[1]);
    return;
  }
  if (db(o), o._isValid === !1)
    delete o._isValid;
  else
    return;
  if (hb(o), o._isValid === !1)
    delete o._isValid;
  else
    return;
  o._strict ? o._isValid = !1 : Ye.createFromInputFallback(o);
}
Ye.createFromInputFallback = ks(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(o) {
    o._d = /* @__PURE__ */ new Date(o._i + (o._useUTC ? " UTC" : ""));
  }
);
function sp(o, c, d) {
  return o ?? c ?? d;
}
function PP(o) {
  var c = new Date(Ye.now());
  return o._useUTC ? [
    c.getUTCFullYear(),
    c.getUTCMonth(),
    c.getUTCDate()
  ] : [c.getFullYear(), c.getMonth(), c.getDate()];
}
function uE(o) {
  var c, d, m = [], w, M, C;
  if (!o._d) {
    for (w = PP(o), o._w && o._a[el] == null && o._a[Jl] == null && AP(o), o._dayOfYear != null && (C = sp(o._a[Ca], w[Ca]), (o._dayOfYear > dm(C) || o._dayOfYear === 0) && (en(o)._overflowDayOfYear = !0), d = hm(C, 0, o._dayOfYear), o._a[Jl] = d.getUTCMonth(), o._a[el] = d.getUTCDate()), c = 0; c < 3 && o._a[c] == null; ++c)
      o._a[c] = m[c] = w[c];
    for (; c < 7; c++)
      o._a[c] = m[c] = o._a[c] == null ? c === 2 ? 1 : 0 : o._a[c];
    o._a[Di] === 24 && o._a[lu] === 0 && o._a[ec] === 0 && o._a[vd] === 0 && (o._nextDay = !0, o._a[Di] = 0), o._d = (o._useUTC ? hm : HN).apply(
      null,
      m
    ), M = o._useUTC ? o._d.getUTCDay() : o._d.getDay(), o._tzm != null && o._d.setUTCMinutes(o._d.getUTCMinutes() - o._tzm), o._nextDay && (o._a[Di] = 24), o._w && typeof o._w.d < "u" && o._w.d !== M && (en(o).weekdayMismatch = !0);
  }
}
function AP(o) {
  var c, d, m, w, M, C, W, z, j;
  c = o._w, c.GG != null || c.W != null || c.E != null ? (M = 1, C = 4, d = sp(
    c.GG,
    o._a[Ca],
    pm(gr(), 1, 4).year
  ), m = sp(c.W, 1), w = sp(c.E, 1), (w < 1 || w > 7) && (z = !0)) : (M = o._locale._week.dow, C = o._locale._week.doy, j = pm(gr(), M, C), d = sp(c.gg, o._a[Ca], j.year), m = sp(c.w, j.week), c.d != null ? (w = c.d, (w < 0 || w > 6) && (z = !0)) : c.e != null ? (w = c.e + M, (c.e < 0 || c.e > 6) && (z = !0)) : w = M), m < 1 || m > tc(d, M, C) ? en(o)._overflowWeeks = !0 : z != null ? en(o)._overflowWeekday = !0 : (W = sb(d, m, w, M, C), o._a[Ca] = W.year, o._dayOfYear = W.dayOfYear);
}
Ye.ISO_8601 = function() {
};
Ye.RFC_2822 = function() {
};
function lE(o) {
  if (o._f === Ye.ISO_8601) {
    db(o);
    return;
  }
  if (o._f === Ye.RFC_2822) {
    hb(o);
    return;
  }
  o._a = [], en(o).empty = !0;
  var c = "" + o._i, d, m, w, M, C, W = c.length, z = 0, j, Z;
  for (w = Gx(o._f, o._locale).match(Jw) || [], Z = w.length, d = 0; d < Z; d++)
    M = w[d], m = (c.match(CN(M, o)) || [])[0], m && (C = c.substr(0, c.indexOf(m)), C.length > 0 && en(o).unusedInput.push(C), c = c.slice(
      c.indexOf(m) + m.length
    ), z += m.length), lp[M] ? (m ? en(o).empty = !1 : en(o).unusedTokens.push(M), bN(M, m, o)) : o._strict && !m && en(o).unusedTokens.push(M);
  en(o).charsLeftOver = W - z, c.length > 0 && en(o).unusedInput.push(c), o._a[Di] <= 12 && en(o).bigHour === !0 && o._a[Di] > 0 && (en(o).bigHour = void 0), en(o).parsedDateParts = o._a.slice(0), en(o).meridiem = o._meridiem, o._a[Di] = zP(
    o._locale,
    o._a[Di],
    o._meridiem
  ), j = en(o).era, j !== null && (o._a[Ca] = o._locale.erasConvertYear(j, o._a[Ca])), uE(o), sE(o);
}
function zP(o, c, d) {
  var m;
  return d == null ? c : o.meridiemHour != null ? o.meridiemHour(c, d) : (o.isPM != null && (m = o.isPM(d), m && c < 12 && (c += 12), !m && c === 12 && (c = 0)), c);
}
function UP(o) {
  var c, d, m, w, M, C, W = !1, z = o._f.length;
  if (z === 0) {
    en(o).invalidFormat = !0, o._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (w = 0; w < z; w++)
    M = 0, C = !1, c = Kw({}, o), o._useUTC != null && (c._useUTC = o._useUTC), c._f = o._f[w], lE(c), qw(c) && (C = !0), M += en(c).charsLeftOver, M += en(c).unusedTokens.length * 10, en(c).score = M, W ? M < m && (m = M, d = c) : (m == null || M < m || C) && (m = M, d = c, C && (W = !0));
  ff(o, d || c);
}
function IP(o) {
  if (!o._d) {
    var c = eE(o._i), d = c.day === void 0 ? c.date : c.day;
    o._a = Wx(
      [c.year, c.month, d, c.hour, c.minute, c.second, c.millisecond],
      function(m) {
        return m && parseInt(m, 10);
      }
    ), uE(o);
  }
}
function jP(o) {
  var c = new _m(sE(pb(o)));
  return c._nextDay && (c.add(1, "d"), c._nextDay = void 0), c;
}
function pb(o) {
  var c = o._i, d = o._f;
  return o._locale = o._locale || ac(o._l), c === null || d === void 0 && c === "" ? Qg({ nullInput: !0 }) : (typeof c == "string" && (o._i = c = o._locale.preparse(c)), fu(c) ? new _m(sE(c)) : (gm(c) ? o._d = c : cu(d) ? UP(o) : d ? lE(o) : FP(o), qw(o) || (o._d = null), o));
}
function FP(o) {
  var c = o._i;
  Oo(c) ? o._d = new Date(Ye.now()) : gm(c) ? o._d = new Date(c.valueOf()) : typeof c == "string" ? NP(o) : cu(c) ? (o._a = Wx(c.slice(0), function(d) {
    return parseInt(d, 10);
  }), uE(o)) : md(c) ? IP(o) : nc(c) ? o._d = new Date(c) : Ye.createFromInputFallback(o);
}
function vb(o, c, d, m, w) {
  var M = {};
  return (c === !0 || c === !1) && (m = c, c = void 0), (d === !0 || d === !1) && (m = d, d = void 0), (md(o) && Qw(o) || cu(o) && o.length === 0) && (o = void 0), M._isAMomentObject = !0, M._useUTC = M._isUTC = w, M._l = d, M._i = o, M._f = c, M._strict = m, jP(M);
}
function gr(o, c, d, m) {
  return vb(o, c, d, m, !1);
}
var HP = ks(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var o = gr.apply(null, arguments);
    return this.isValid() && o.isValid() ? o < this ? this : o : Qg();
  }
), BP = ks(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var o = gr.apply(null, arguments);
    return this.isValid() && o.isValid() ? o > this ? this : o : Qg();
  }
);
function mb(o, c) {
  var d, m;
  if (c.length === 1 && cu(c[0]) && (c = c[0]), !c.length)
    return gr();
  for (d = c[0], m = 1; m < c.length; ++m)
    (!c[m].isValid() || c[m][o](d)) && (d = c[m]);
  return d;
}
function YP() {
  var o = [].slice.call(arguments, 0);
  return mb("isBefore", o);
}
function VP() {
  var o = [].slice.call(arguments, 0);
  return mb("isAfter", o);
}
var WP = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
}, um = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function ZP(o) {
  var c, d = !1, m, w = um.length;
  for (c in o)
    if (Pn(o, c) && !(Kr.call(um, c) !== -1 && (o[c] == null || !isNaN(o[c]))))
      return !1;
  for (m = 0; m < w; ++m)
    if (o[um[m]]) {
      if (d)
        return !1;
      parseFloat(o[um[m]]) !== fn(o[um[m]]) && (d = !0);
    }
  return !0;
}
function $P() {
  return this._isValid;
}
function GP() {
  return du(NaN);
}
function i_(o) {
  var c = eE(o), d = c.year || 0, m = c.quarter || 0, w = c.month || 0, M = c.week || c.isoWeek || 0, C = c.day || 0, W = c.hour || 0, z = c.minute || 0, j = c.second || 0, Z = c.millisecond || 0;
  this._isValid = ZP(c), this._milliseconds = +Z + j * 1e3 + // 1000
  z * 6e4 + // 1000 * 60
  W * 1e3 * 60 * 60, this._days = +C + M * 7, this._months = +w + m * 3 + d * 12, this._data = {}, this._locale = ac(), this._bubble();
}
function Ig(o) {
  return o instanceof i_;
}
function jw(o) {
  return o < 0 ? Math.round(-1 * o) * -1 : Math.round(o);
}
function QP(o, c, d) {
  var m = Math.min(o.length, c.length), w = Math.abs(o.length - c.length), M = 0, C;
  for (C = 0; C < m; C++)
    (d && o[C] !== c[C] || !d && fn(o[C]) !== fn(c[C])) && M++;
  return M + w;
}
function yb(o, c) {
  Ct(o, 0, 0, function() {
    var d = this.utcOffset(), m = "+";
    return d < 0 && (d = -d, m = "-"), m + nl(~~(d / 60), 2) + c + nl(~~d % 60, 2);
  });
}
yb("Z", ":");
yb("ZZ", "");
rt("Z", t_);
rt("ZZ", t_);
nr(["Z", "ZZ"], function(o, c, d) {
  d._useUTC = !0, d._tzm = cE(t_, o);
});
var qP = /([\+\-]|\d\d)/gi;
function cE(o, c) {
  var d = (c || "").match(o), m, w, M;
  return d === null ? null : (m = d[d.length - 1] || [], w = (m + "").match(qP) || ["-", 0, 0], M = +(w[1] * 60) + fn(w[2]), M === 0 ? 0 : w[0] === "+" ? M : -M);
}
function fE(o, c) {
  var d, m;
  return c._isUTC ? (d = c.clone(), m = (fu(o) || gm(o) ? o.valueOf() : gr(o).valueOf()) - d.valueOf(), d._d.setTime(d._d.valueOf() + m), Ye.updateOffset(d, !1), d) : gr(o).local();
}
function Fw(o) {
  return -Math.round(o._d.getTimezoneOffset());
}
Ye.updateOffset = function() {
};
function KP(o, c, d) {
  var m = this._offset || 0, w;
  if (!this.isValid())
    return o != null ? this : NaN;
  if (o != null) {
    if (typeof o == "string") {
      if (o = cE(t_, o), o === null)
        return this;
    } else
      Math.abs(o) < 16 && !d && (o = o * 60);
    return !this._isUTC && c && (w = Fw(this)), this._offset = o, this._isUTC = !0, w != null && this.add(w, "m"), m !== o && (!c || this._changeInProgress ? Sb(
      this,
      du(o - m, "m"),
      1,
      !1
    ) : this._changeInProgress || (this._changeInProgress = !0, Ye.updateOffset(this, !0), this._changeInProgress = null)), this;
  } else
    return this._isUTC ? m : Fw(this);
}
function XP(o, c) {
  return o != null ? (typeof o != "string" && (o = -o), this.utcOffset(o, c), this) : -this.utcOffset();
}
function JP(o) {
  return this.utcOffset(0, o);
}
function eA(o) {
  return this._isUTC && (this.utcOffset(0, o), this._isUTC = !1, o && this.subtract(Fw(this), "m")), this;
}
function tA() {
  if (this._tzm != null)
    this.utcOffset(this._tzm, !1, !0);
  else if (typeof this._i == "string") {
    var o = cE(EN, this._i);
    o != null ? this.utcOffset(o) : this.utcOffset(0, !0);
  }
  return this;
}
function nA(o) {
  return this.isValid() ? (o = o ? gr(o).utcOffset() : 0, (this.utcOffset() - o) % 60 === 0) : !1;
}
function rA() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function iA() {
  if (!Oo(this._isDSTShifted))
    return this._isDSTShifted;
  var o = {}, c;
  return Kw(o, this), o = pb(o), o._a ? (c = o._isUTC ? rl(o._a) : gr(o._a), this._isDSTShifted = this.isValid() && QP(o._a, c.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted;
}
function aA() {
  return this.isValid() ? !this._isUTC : !1;
}
function oA() {
  return this.isValid() ? this._isUTC : !1;
}
function gb() {
  return this.isValid() ? this._isUTC && this._offset === 0 : !1;
}
var sA = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, uA = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function du(o, c) {
  var d = o, m = null, w, M, C;
  return Ig(o) ? d = {
    ms: o._milliseconds,
    d: o._days,
    M: o._months
  } : nc(o) || !isNaN(+o) ? (d = {}, c ? d[c] = +o : d.milliseconds = +o) : (m = sA.exec(o)) ? (w = m[1] === "-" ? -1 : 1, d = {
    y: 0,
    d: fn(m[el]) * w,
    h: fn(m[Di]) * w,
    m: fn(m[lu]) * w,
    s: fn(m[ec]) * w,
    ms: fn(jw(m[vd] * 1e3)) * w
    // the millisecond decimal point is included in the match
  }) : (m = uA.exec(o)) ? (w = m[1] === "-" ? -1 : 1, d = {
    y: pd(m[2], w),
    M: pd(m[3], w),
    w: pd(m[4], w),
    d: pd(m[5], w),
    h: pd(m[6], w),
    m: pd(m[7], w),
    s: pd(m[8], w)
  }) : d == null ? d = {} : typeof d == "object" && ("from" in d || "to" in d) && (C = lA(
    gr(d.from),
    gr(d.to)
  ), d = {}, d.ms = C.milliseconds, d.M = C.months), M = new i_(d), Ig(o) && Pn(o, "_locale") && (M._locale = o._locale), Ig(o) && Pn(o, "_isValid") && (M._isValid = o._isValid), M;
}
du.fn = i_.prototype;
du.invalid = GP;
function pd(o, c) {
  var d = o && parseFloat(o.replace(",", "."));
  return (isNaN(d) ? 0 : d) * c;
}
function _x(o, c) {
  var d = {};
  return d.months = c.month() - o.month() + (c.year() - o.year()) * 12, o.clone().add(d.months, "M").isAfter(c) && --d.months, d.milliseconds = +c - +o.clone().add(d.months, "M"), d;
}
function lA(o, c) {
  var d;
  return o.isValid() && c.isValid() ? (c = fE(c, o), o.isBefore(c) ? d = _x(o, c) : (d = _x(c, o), d.milliseconds = -d.milliseconds, d.months = -d.months), d) : { milliseconds: 0, months: 0 };
}
function _b(o, c) {
  return function(d, m) {
    var w, M;
    return m !== null && !isNaN(+m) && ($x(
      c,
      "moment()." + c + "(period, number) is deprecated. Please use moment()." + c + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
    ), M = d, d = m, m = M), w = du(d, m), Sb(this, w, o), this;
  };
}
function Sb(o, c, d, m) {
  var w = c._milliseconds, M = jw(c._days), C = jw(c._months);
  o.isValid() && (m = m ?? !0, C && rb(o, Fg(o, "Month") + C * d), M && qx(o, "Date", Fg(o, "Date") + M * d), w && o._d.setTime(o._d.valueOf() + w * d), m && Ye.updateOffset(o, M || C));
}
var cA = _b(1, "add"), fA = _b(-1, "subtract");
function wb(o) {
  return typeof o == "string" || o instanceof String;
}
function dA(o) {
  return fu(o) || gm(o) || wb(o) || nc(o) || pA(o) || hA(o) || o === null || o === void 0;
}
function hA(o) {
  var c = md(o) && !Qw(o), d = !1, m = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], w, M, C = m.length;
  for (w = 0; w < C; w += 1)
    M = m[w], d = d || Pn(o, M);
  return c && d;
}
function pA(o) {
  var c = cu(o), d = !1;
  return c && (d = o.filter(function(m) {
    return !nc(m) && wb(o);
  }).length === 0), c && d;
}
function vA(o) {
  var c = md(o) && !Qw(o), d = !1, m = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], w, M;
  for (w = 0; w < m.length; w += 1)
    M = m[w], d = d || Pn(o, M);
  return c && d;
}
function mA(o, c) {
  var d = o.diff(c, "days", !0);
  return d < -6 ? "sameElse" : d < -1 ? "lastWeek" : d < 0 ? "lastDay" : d < 1 ? "sameDay" : d < 2 ? "nextDay" : d < 7 ? "nextWeek" : "sameElse";
}
function yA(o, c) {
  arguments.length === 1 && (arguments[0] ? dA(arguments[0]) ? (o = arguments[0], c = void 0) : vA(arguments[0]) && (c = arguments[0], o = void 0) : (o = void 0, c = void 0));
  var d = o || gr(), m = fE(d, this).startOf("day"), w = Ye.calendarFormat(this, m) || "sameElse", M = c && (il(c[w]) ? c[w].call(this, d) : c[w]);
  return this.format(
    M || this.localeData().calendar(w, this, gr(d))
  );
}
function gA() {
  return new _m(this);
}
function _A(o, c) {
  var d = fu(o) ? o : gr(o);
  return this.isValid() && d.isValid() ? (c = Os(c) || "millisecond", c === "millisecond" ? this.valueOf() > d.valueOf() : d.valueOf() < this.clone().startOf(c).valueOf()) : !1;
}
function SA(o, c) {
  var d = fu(o) ? o : gr(o);
  return this.isValid() && d.isValid() ? (c = Os(c) || "millisecond", c === "millisecond" ? this.valueOf() < d.valueOf() : this.clone().endOf(c).valueOf() < d.valueOf()) : !1;
}
function wA(o, c, d, m) {
  var w = fu(o) ? o : gr(o), M = fu(c) ? c : gr(c);
  return this.isValid() && w.isValid() && M.isValid() ? (m = m || "()", (m[0] === "(" ? this.isAfter(w, d) : !this.isBefore(w, d)) && (m[1] === ")" ? this.isBefore(M, d) : !this.isAfter(M, d))) : !1;
}
function EA(o, c) {
  var d = fu(o) ? o : gr(o), m;
  return this.isValid() && d.isValid() ? (c = Os(c) || "millisecond", c === "millisecond" ? this.valueOf() === d.valueOf() : (m = d.valueOf(), this.clone().startOf(c).valueOf() <= m && m <= this.clone().endOf(c).valueOf())) : !1;
}
function TA(o, c) {
  return this.isSame(o, c) || this.isAfter(o, c);
}
function CA(o, c) {
  return this.isSame(o, c) || this.isBefore(o, c);
}
function xA(o, c, d) {
  var m, w, M;
  if (!this.isValid())
    return NaN;
  if (m = fE(o, this), !m.isValid())
    return NaN;
  switch (w = (m.utcOffset() - this.utcOffset()) * 6e4, c = Os(c), c) {
    case "year":
      M = jg(this, m) / 12;
      break;
    case "month":
      M = jg(this, m);
      break;
    case "quarter":
      M = jg(this, m) / 3;
      break;
    case "second":
      M = (this - m) / 1e3;
      break;
    case "minute":
      M = (this - m) / 6e4;
      break;
    case "hour":
      M = (this - m) / 36e5;
      break;
    case "day":
      M = (this - m - w) / 864e5;
      break;
    case "week":
      M = (this - m - w) / 6048e5;
      break;
    default:
      M = this - m;
  }
  return d ? M : Ds(M);
}
function jg(o, c) {
  if (o.date() < c.date())
    return -jg(c, o);
  var d = (c.year() - o.year()) * 12 + (c.month() - o.month()), m = o.clone().add(d, "months"), w, M;
  return c - m < 0 ? (w = o.clone().add(d - 1, "months"), M = (c - m) / (m - w)) : (w = o.clone().add(d + 1, "months"), M = (c - m) / (w - m)), -(d + M) || 0;
}
Ye.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
Ye.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function bA() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function MA(o) {
  if (!this.isValid())
    return null;
  var c = o !== !0, d = c ? this.clone().utc() : this;
  return d.year() < 0 || d.year() > 9999 ? Ug(
    d,
    c ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
  ) : il(Date.prototype.toISOString) ? c ? this.toDate().toISOString() : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", Ug(d, "Z")) : Ug(
    d,
    c ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function RA() {
  if (!this.isValid())
    return "moment.invalid(/* " + this._i + " */)";
  var o = "moment", c = "", d, m, w, M;
  return this.isLocal() || (o = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", c = "Z"), d = "[" + o + '("]', m = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", w = "-MM-DD[T]HH:mm:ss.SSS", M = c + '[")]', this.format(d + m + w + M);
}
function DA(o) {
  o || (o = this.isUtc() ? Ye.defaultFormatUtc : Ye.defaultFormat);
  var c = Ug(this, o);
  return this.localeData().postformat(c);
}
function kA(o, c) {
  return this.isValid() && (fu(o) && o.isValid() || gr(o).isValid()) ? du({ to: this, from: o }).locale(this.locale()).humanize(!c) : this.localeData().invalidDate();
}
function OA(o) {
  return this.from(gr(), o);
}
function LA(o, c) {
  return this.isValid() && (fu(o) && o.isValid() || gr(o).isValid()) ? du({ from: this, to: o }).locale(this.locale()).humanize(!c) : this.localeData().invalidDate();
}
function NA(o) {
  return this.to(gr(), o);
}
function Eb(o) {
  var c;
  return o === void 0 ? this._locale._abbr : (c = ac(o), c != null && (this._locale = c), this);
}
var Tb = ks(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(o) {
    return o === void 0 ? this.localeData() : this.locale(o);
  }
);
function Cb() {
  return this._locale;
}
var Yg = 1e3, cp = 60 * Yg, Vg = 60 * cp, xb = (365 * 400 + 97) * 24 * Vg;
function fp(o, c) {
  return (o % c + c) % c;
}
function bb(o, c, d) {
  return o < 100 && o >= 0 ? new Date(o + 400, c, d) - xb : new Date(o, c, d).valueOf();
}
function Mb(o, c, d) {
  return o < 100 && o >= 0 ? Date.UTC(o + 400, c, d) - xb : Date.UTC(o, c, d);
}
function PA(o) {
  var c, d;
  if (o = Os(o), o === void 0 || o === "millisecond" || !this.isValid())
    return this;
  switch (d = this._isUTC ? Mb : bb, o) {
    case "year":
      c = d(this.year(), 0, 1);
      break;
    case "quarter":
      c = d(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      c = d(this.year(), this.month(), 1);
      break;
    case "week":
      c = d(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      c = d(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      c = d(this.year(), this.month(), this.date());
      break;
    case "hour":
      c = this._d.valueOf(), c -= fp(
        c + (this._isUTC ? 0 : this.utcOffset() * cp),
        Vg
      );
      break;
    case "minute":
      c = this._d.valueOf(), c -= fp(c, cp);
      break;
    case "second":
      c = this._d.valueOf(), c -= fp(c, Yg);
      break;
  }
  return this._d.setTime(c), Ye.updateOffset(this, !0), this;
}
function AA(o) {
  var c, d;
  if (o = Os(o), o === void 0 || o === "millisecond" || !this.isValid())
    return this;
  switch (d = this._isUTC ? Mb : bb, o) {
    case "year":
      c = d(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      c = d(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      c = d(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      c = d(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      c = d(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      c = d(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      c = this._d.valueOf(), c += Vg - fp(
        c + (this._isUTC ? 0 : this.utcOffset() * cp),
        Vg
      ) - 1;
      break;
    case "minute":
      c = this._d.valueOf(), c += cp - fp(c, cp) - 1;
      break;
    case "second":
      c = this._d.valueOf(), c += Yg - fp(c, Yg) - 1;
      break;
  }
  return this._d.setTime(c), Ye.updateOffset(this, !0), this;
}
function zA() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function UA() {
  return Math.floor(this.valueOf() / 1e3);
}
function IA() {
  return new Date(this.valueOf());
}
function jA() {
  var o = this;
  return [
    o.year(),
    o.month(),
    o.date(),
    o.hour(),
    o.minute(),
    o.second(),
    o.millisecond()
  ];
}
function FA() {
  var o = this;
  return {
    years: o.year(),
    months: o.month(),
    date: o.date(),
    hours: o.hours(),
    minutes: o.minutes(),
    seconds: o.seconds(),
    milliseconds: o.milliseconds()
  };
}
function HA() {
  return this.isValid() ? this.toISOString() : null;
}
function BA() {
  return qw(this);
}
function YA() {
  return ff({}, en(this));
}
function VA() {
  return en(this).overflow;
}
function WA() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
Ct("N", 0, 0, "eraAbbr");
Ct("NN", 0, 0, "eraAbbr");
Ct("NNN", 0, 0, "eraAbbr");
Ct("NNNN", 0, 0, "eraName");
Ct("NNNNN", 0, 0, "eraNarrow");
Ct("y", ["y", 1], "yo", "eraYear");
Ct("y", ["yy", 2], 0, "eraYear");
Ct("y", ["yyy", 3], 0, "eraYear");
Ct("y", ["yyyy", 4], 0, "eraYear");
rt("N", dE);
rt("NN", dE);
rt("NNN", dE);
rt("NNNN", nz);
rt("NNNNN", rz);
nr(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(o, c, d, m) {
    var w = d._locale.erasParse(o, m, d._strict);
    w ? en(d).era = w : en(d).invalidEra = o;
  }
);
rt("y", mp);
rt("yy", mp);
rt("yyy", mp);
rt("yyyy", mp);
rt("yo", iz);
nr(["y", "yy", "yyy", "yyyy"], Ca);
nr(["yo"], function(o, c, d, m) {
  var w;
  d._locale._eraYearOrdinalRegex && (w = o.match(d._locale._eraYearOrdinalRegex)), d._locale.eraYearOrdinalParse ? c[Ca] = d._locale.eraYearOrdinalParse(o, w) : c[Ca] = parseInt(o, 10);
});
function ZA(o, c) {
  var d, m, w, M = this._eras || ac("en")._eras;
  for (d = 0, m = M.length; d < m; ++d) {
    switch (typeof M[d].since) {
      case "string":
        w = Ye(M[d].since).startOf("day"), M[d].since = w.valueOf();
        break;
    }
    switch (typeof M[d].until) {
      case "undefined":
        M[d].until = 1 / 0;
        break;
      case "string":
        w = Ye(M[d].until).startOf("day").valueOf(), M[d].until = w.valueOf();
        break;
    }
  }
  return M;
}
function $A(o, c, d) {
  var m, w, M = this.eras(), C, W, z;
  for (o = o.toUpperCase(), m = 0, w = M.length; m < w; ++m)
    if (C = M[m].name.toUpperCase(), W = M[m].abbr.toUpperCase(), z = M[m].narrow.toUpperCase(), d)
      switch (c) {
        case "N":
        case "NN":
        case "NNN":
          if (W === o)
            return M[m];
          break;
        case "NNNN":
          if (C === o)
            return M[m];
          break;
        case "NNNNN":
          if (z === o)
            return M[m];
          break;
      }
    else if ([C, W, z].indexOf(o) >= 0)
      return M[m];
}
function GA(o, c) {
  var d = o.since <= o.until ? 1 : -1;
  return c === void 0 ? Ye(o.since).year() : Ye(o.since).year() + (c - o.offset) * d;
}
function QA() {
  var o, c, d, m = this.localeData().eras();
  for (o = 0, c = m.length; o < c; ++o)
    if (d = this.clone().startOf("day").valueOf(), m[o].since <= d && d <= m[o].until || m[o].until <= d && d <= m[o].since)
      return m[o].name;
  return "";
}
function qA() {
  var o, c, d, m = this.localeData().eras();
  for (o = 0, c = m.length; o < c; ++o)
    if (d = this.clone().startOf("day").valueOf(), m[o].since <= d && d <= m[o].until || m[o].until <= d && d <= m[o].since)
      return m[o].narrow;
  return "";
}
function KA() {
  var o, c, d, m = this.localeData().eras();
  for (o = 0, c = m.length; o < c; ++o)
    if (d = this.clone().startOf("day").valueOf(), m[o].since <= d && d <= m[o].until || m[o].until <= d && d <= m[o].since)
      return m[o].abbr;
  return "";
}
function XA() {
  var o, c, d, m, w = this.localeData().eras();
  for (o = 0, c = w.length; o < c; ++o)
    if (d = w[o].since <= w[o].until ? 1 : -1, m = this.clone().startOf("day").valueOf(), w[o].since <= m && m <= w[o].until || w[o].until <= m && m <= w[o].since)
      return (this.year() - Ye(w[o].since).year()) * d + w[o].offset;
  return this.year();
}
function JA(o) {
  return Pn(this, "_erasNameRegex") || hE.call(this), o ? this._erasNameRegex : this._erasRegex;
}
function ez(o) {
  return Pn(this, "_erasAbbrRegex") || hE.call(this), o ? this._erasAbbrRegex : this._erasRegex;
}
function tz(o) {
  return Pn(this, "_erasNarrowRegex") || hE.call(this), o ? this._erasNarrowRegex : this._erasRegex;
}
function dE(o, c) {
  return c.erasAbbrRegex(o);
}
function nz(o, c) {
  return c.erasNameRegex(o);
}
function rz(o, c) {
  return c.erasNarrowRegex(o);
}
function iz(o, c) {
  return c._eraYearOrdinalRegex || mp;
}
function hE() {
  var o = [], c = [], d = [], m = [], w, M, C = this.eras();
  for (w = 0, M = C.length; w < M; ++w)
    c.push(Jo(C[w].name)), o.push(Jo(C[w].abbr)), d.push(Jo(C[w].narrow)), m.push(Jo(C[w].name)), m.push(Jo(C[w].abbr)), m.push(Jo(C[w].narrow));
  this._erasRegex = new RegExp("^(" + m.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + c.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + o.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp(
    "^(" + d.join("|") + ")",
    "i"
  );
}
Ct(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
Ct(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function a_(o, c) {
  Ct(0, [o, o.length], 0, c);
}
a_("gggg", "weekYear");
a_("ggggg", "weekYear");
a_("GGGG", "isoWeekYear");
a_("GGGGG", "isoWeekYear");
xa("weekYear", "gg");
xa("isoWeekYear", "GG");
ba("weekYear", 1);
ba("isoWeekYear", 1);
rt("G", e_);
rt("g", e_);
rt("GG", _r, ts);
rt("gg", _r, ts);
rt("GGGG", nE, tE);
rt("gggg", nE, tE);
rt("GGGGG", Jg, Kg);
rt("ggggg", Jg, Kg);
wm(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(o, c, d, m) {
    c[m.substr(0, 2)] = fn(o);
  }
);
wm(["gg", "GG"], function(o, c, d, m) {
  c[m] = Ye.parseTwoDigitYear(o);
});
function az(o) {
  return Rb.call(
    this,
    o,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function oz(o) {
  return Rb.call(
    this,
    o,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function sz() {
  return tc(this.year(), 1, 4);
}
function uz() {
  return tc(this.isoWeekYear(), 1, 4);
}
function lz() {
  var o = this.localeData()._week;
  return tc(this.year(), o.dow, o.doy);
}
function cz() {
  var o = this.localeData()._week;
  return tc(this.weekYear(), o.dow, o.doy);
}
function Rb(o, c, d, m, w) {
  var M;
  return o == null ? pm(this, m, w).year : (M = tc(o, m, w), c > M && (c = M), fz.call(this, o, c, d, m, w));
}
function fz(o, c, d, m, w) {
  var M = sb(o, c, d, m, w), C = hm(M.year, 0, M.dayOfYear);
  return this.year(C.getUTCFullYear()), this.month(C.getUTCMonth()), this.date(C.getUTCDate()), this;
}
Ct("Q", 0, "Qo", "quarter");
xa("quarter", "Q");
ba("quarter", 7);
rt("Q", Kx);
nr("Q", function(o, c) {
  c[Jl] = (fn(o) - 1) * 3;
});
function dz(o) {
  return o == null ? Math.ceil((this.month() + 1) / 3) : this.month((o - 1) * 3 + this.month() % 3);
}
Ct("D", ["DD", 2], "Do", "date");
xa("date", "D");
ba("date", 9);
rt("D", _r);
rt("DD", _r, ts);
rt("Do", function(o, c) {
  return o ? c._dayOfMonthOrdinalParse || c._ordinalParse : c._dayOfMonthOrdinalParseLenient;
});
nr(["D", "DD"], el);
nr("Do", function(o, c) {
  c[el] = fn(o.match(_r)[0]);
});
var Db = vp("Date", !0);
Ct("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
xa("dayOfYear", "DDD");
ba("dayOfYear", 4);
rt("DDD", Xg);
rt("DDDD", Xx);
nr(["DDD", "DDDD"], function(o, c, d) {
  d._dayOfYear = fn(o);
});
function hz(o) {
  var c = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return o == null ? c : this.add(o - c, "d");
}
Ct("m", ["mm", 2], 0, "minute");
xa("minute", "m");
ba("minute", 14);
rt("m", _r);
rt("mm", _r, ts);
nr(["m", "mm"], lu);
var pz = vp("Minutes", !1);
Ct("s", ["ss", 2], 0, "second");
xa("second", "s");
ba("second", 15);
rt("s", _r);
rt("ss", _r, ts);
nr(["s", "ss"], ec);
var vz = vp("Seconds", !1);
Ct("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
Ct(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
Ct(0, ["SSS", 3], 0, "millisecond");
Ct(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
Ct(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
Ct(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
Ct(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
Ct(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
Ct(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
xa("millisecond", "ms");
ba("millisecond", 16);
rt("S", Xg, Kx);
rt("SS", Xg, ts);
rt("SSS", Xg, Xx);
var df, kb;
for (df = "SSSS"; df.length <= 9; df += "S")
  rt(df, mp);
function mz(o, c) {
  c[vd] = fn(("0." + o) * 1e3);
}
for (df = "S"; df.length <= 9; df += "S")
  nr(df, mz);
kb = vp("Milliseconds", !1);
Ct("z", 0, 0, "zoneAbbr");
Ct("zz", 0, 0, "zoneName");
function yz() {
  return this._isUTC ? "UTC" : "";
}
function gz() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var be = _m.prototype;
be.add = cA;
be.calendar = yA;
be.clone = gA;
be.diff = xA;
be.endOf = AA;
be.format = DA;
be.from = kA;
be.fromNow = OA;
be.to = LA;
be.toNow = NA;
be.get = SN;
be.invalidAt = VA;
be.isAfter = _A;
be.isBefore = SA;
be.isBetween = wA;
be.isSame = EA;
be.isSameOrAfter = TA;
be.isSameOrBefore = CA;
be.isValid = BA;
be.lang = Tb;
be.locale = Eb;
be.localeData = Cb;
be.max = BP;
be.min = HP;
be.parsingFlags = YA;
be.set = wN;
be.startOf = PA;
be.subtract = fA;
be.toArray = jA;
be.toObject = FA;
be.toDate = IA;
be.toISOString = MA;
be.inspect = RA;
typeof Symbol < "u" && Symbol.for != null && (be[Symbol.for("nodejs.util.inspect.custom")] = function() {
  return "Moment<" + this.format() + ">";
});
be.toJSON = HA;
be.toString = bA;
be.unix = UA;
be.valueOf = zA;
be.creationData = WA;
be.eraName = QA;
be.eraNarrow = qA;
be.eraAbbr = KA;
be.eraYear = XA;
be.year = ob;
be.isLeapYear = FN;
be.weekYear = az;
be.isoWeekYear = oz;
be.quarter = be.quarters = dz;
be.month = ib;
be.daysInMonth = UN;
be.week = be.weeks = ZN;
be.isoWeek = be.isoWeeks = $N;
be.weeksInYear = lz;
be.weeksInWeekYear = cz;
be.isoWeeksInYear = sz;
be.isoWeeksInISOWeekYear = uz;
be.date = Db;
be.day = be.days = oP;
be.weekday = sP;
be.isoWeekday = uP;
be.dayOfYear = hz;
be.hour = be.hours = vP;
be.minute = be.minutes = pz;
be.second = be.seconds = vz;
be.millisecond = be.milliseconds = kb;
be.utcOffset = KP;
be.utc = JP;
be.local = eA;
be.parseZone = tA;
be.hasAlignedHourOffset = nA;
be.isDST = rA;
be.isLocal = aA;
be.isUtcOffset = oA;
be.isUtc = gb;
be.isUTC = gb;
be.zoneAbbr = yz;
be.zoneName = gz;
be.dates = ks(
  "dates accessor is deprecated. Use date instead.",
  Db
);
be.months = ks(
  "months accessor is deprecated. Use month instead",
  ib
);
be.years = ks(
  "years accessor is deprecated. Use year instead",
  ob
);
be.zone = ks(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  XP
);
be.isDSTShifted = ks(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  iA
);
function _z(o) {
  return gr(o * 1e3);
}
function Sz() {
  return gr.apply(null, arguments).parseZone();
}
function Ob(o) {
  return o;
}
var An = Xw.prototype;
An.calendar = oN;
An.longDateFormat = cN;
An.invalidDate = dN;
An.ordinal = vN;
An.preparse = Ob;
An.postformat = Ob;
An.relativeTime = yN;
An.pastFuture = gN;
An.set = iN;
An.eras = ZA;
An.erasParse = $A;
An.erasConvertYear = GA;
An.erasAbbrRegex = ez;
An.erasNameRegex = JA;
An.erasNarrowRegex = tz;
An.months = NN;
An.monthsShort = PN;
An.monthsParse = zN;
An.monthsRegex = jN;
An.monthsShortRegex = IN;
An.week = BN;
An.firstDayOfYear = WN;
An.firstDayOfWeek = VN;
An.weekdays = tP;
An.weekdaysMin = rP;
An.weekdaysShort = nP;
An.weekdaysParse = aP;
An.weekdaysRegex = lP;
An.weekdaysShortRegex = cP;
An.weekdaysMinRegex = fP;
An.isPM = hP;
An.meridiem = mP;
function Wg(o, c, d, m) {
  var w = ac(), M = rl().set(m, c);
  return w[d](M, o);
}
function Lb(o, c, d) {
  if (nc(o) && (c = o, o = void 0), o = o || "", c != null)
    return Wg(o, c, d, "month");
  var m, w = [];
  for (m = 0; m < 12; m++)
    w[m] = Wg(o, m, d, "month");
  return w;
}
function pE(o, c, d, m) {
  typeof o == "boolean" ? (nc(c) && (d = c, c = void 0), c = c || "") : (c = o, d = c, o = !1, nc(c) && (d = c, c = void 0), c = c || "");
  var w = ac(), M = o ? w._week.dow : 0, C, W = [];
  if (d != null)
    return Wg(c, (d + M) % 7, m, "day");
  for (C = 0; C < 7; C++)
    W[C] = Wg(c, (C + M) % 7, m, "day");
  return W;
}
function wz(o, c) {
  return Lb(o, c, "months");
}
function Ez(o, c) {
  return Lb(o, c, "monthsShort");
}
function Tz(o, c, d) {
  return pE(o, c, d, "weekdays");
}
function Cz(o, c, d) {
  return pE(o, c, d, "weekdaysShort");
}
function xz(o, c, d) {
  return pE(o, c, d, "weekdaysMin");
}
hf("en", {
  eras: [
    {
      since: "0001-01-01",
      until: 1 / 0,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -1 / 0,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(o) {
    var c = o % 10, d = fn(o % 100 / 10) === 1 ? "th" : c === 1 ? "st" : c === 2 ? "nd" : c === 3 ? "rd" : "th";
    return o + d;
  }
});
Ye.lang = ks(
  "moment.lang is deprecated. Use moment.locale instead.",
  hf
);
Ye.langData = ks(
  "moment.langData is deprecated. Use moment.localeData instead.",
  ac
);
var Kl = Math.abs;
function bz() {
  var o = this._data;
  return this._milliseconds = Kl(this._milliseconds), this._days = Kl(this._days), this._months = Kl(this._months), o.milliseconds = Kl(o.milliseconds), o.seconds = Kl(o.seconds), o.minutes = Kl(o.minutes), o.hours = Kl(o.hours), o.months = Kl(o.months), o.years = Kl(o.years), this;
}
function Nb(o, c, d, m) {
  var w = du(c, d);
  return o._milliseconds += m * w._milliseconds, o._days += m * w._days, o._months += m * w._months, o._bubble();
}
function Mz(o, c) {
  return Nb(this, o, c, 1);
}
function Rz(o, c) {
  return Nb(this, o, c, -1);
}
function Sx(o) {
  return o < 0 ? Math.floor(o) : Math.ceil(o);
}
function Dz() {
  var o = this._milliseconds, c = this._days, d = this._months, m = this._data, w, M, C, W, z;
  return o >= 0 && c >= 0 && d >= 0 || o <= 0 && c <= 0 && d <= 0 || (o += Sx(Hw(d) + c) * 864e5, c = 0, d = 0), m.milliseconds = o % 1e3, w = Ds(o / 1e3), m.seconds = w % 60, M = Ds(w / 60), m.minutes = M % 60, C = Ds(M / 60), m.hours = C % 24, c += Ds(C / 24), z = Ds(Pb(c)), d += z, c -= Sx(Hw(z)), W = Ds(d / 12), d %= 12, m.days = c, m.months = d, m.years = W, this;
}
function Pb(o) {
  return o * 4800 / 146097;
}
function Hw(o) {
  return o * 146097 / 4800;
}
function kz(o) {
  if (!this.isValid())
    return NaN;
  var c, d, m = this._milliseconds;
  if (o = Os(o), o === "month" || o === "quarter" || o === "year")
    switch (c = this._days + m / 864e5, d = this._months + Pb(c), o) {
      case "month":
        return d;
      case "quarter":
        return d / 3;
      case "year":
        return d / 12;
    }
  else
    switch (c = this._days + Math.round(Hw(this._months)), o) {
      case "week":
        return c / 7 + m / 6048e5;
      case "day":
        return c + m / 864e5;
      case "hour":
        return c * 24 + m / 36e5;
      case "minute":
        return c * 1440 + m / 6e4;
      case "second":
        return c * 86400 + m / 1e3;
      case "millisecond":
        return Math.floor(c * 864e5) + m;
      default:
        throw new Error("Unknown unit " + o);
    }
}
function Oz() {
  return this.isValid() ? this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + fn(this._months / 12) * 31536e6 : NaN;
}
function oc(o) {
  return function() {
    return this.as(o);
  };
}
var Lz = oc("ms"), Nz = oc("s"), Pz = oc("m"), Az = oc("h"), zz = oc("d"), Uz = oc("w"), Iz = oc("M"), jz = oc("Q"), Fz = oc("y");
function Hz() {
  return du(this);
}
function Bz(o) {
  return o = Os(o), this.isValid() ? this[o + "s"]() : NaN;
}
function _d(o) {
  return function() {
    return this.isValid() ? this._data[o] : NaN;
  };
}
var Yz = _d("milliseconds"), Vz = _d("seconds"), Wz = _d("minutes"), Zz = _d("hours"), $z = _d("days"), Gz = _d("months"), Qz = _d("years");
function qz() {
  return Ds(this.days() / 7);
}
var Xl = Math.round, up = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function Kz(o, c, d, m, w) {
  return w.relativeTime(c || 1, !!d, o, m);
}
function Xz(o, c, d, m) {
  var w = du(o).abs(), M = Xl(w.as("s")), C = Xl(w.as("m")), W = Xl(w.as("h")), z = Xl(w.as("d")), j = Xl(w.as("M")), Z = Xl(w.as("w")), H = Xl(w.as("y")), $ = M <= d.ss && ["s", M] || M < d.s && ["ss", M] || C <= 1 && ["m"] || C < d.m && ["mm", C] || W <= 1 && ["h"] || W < d.h && ["hh", W] || z <= 1 && ["d"] || z < d.d && ["dd", z];
  return d.w != null && ($ = $ || Z <= 1 && ["w"] || Z < d.w && ["ww", Z]), $ = $ || j <= 1 && ["M"] || j < d.M && ["MM", j] || H <= 1 && ["y"] || ["yy", H], $[2] = c, $[3] = +o > 0, $[4] = m, Kz.apply(null, $);
}
function Jz(o) {
  return o === void 0 ? Xl : typeof o == "function" ? (Xl = o, !0) : !1;
}
function e2(o, c) {
  return up[o] === void 0 ? !1 : c === void 0 ? up[o] : (up[o] = c, o === "s" && (up.ss = c - 1), !0);
}
function t2(o, c) {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var d = !1, m = up, w, M;
  return typeof o == "object" && (c = o, o = !1), typeof o == "boolean" && (d = o), typeof c == "object" && (m = Object.assign({}, up, c), c.s != null && c.ss == null && (m.ss = c.s - 1)), w = this.localeData(), M = Xz(this, !d, m, w), d && (M = w.pastFuture(+this, M)), w.postformat(M);
}
var Ew = Math.abs;
function op(o) {
  return (o > 0) - (o < 0) || +o;
}
function o_() {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var o = Ew(this._milliseconds) / 1e3, c = Ew(this._days), d = Ew(this._months), m, w, M, C, W = this.asSeconds(), z, j, Z, H;
  return W ? (m = Ds(o / 60), w = Ds(m / 60), o %= 60, m %= 60, M = Ds(d / 12), d %= 12, C = o ? o.toFixed(3).replace(/\.?0+$/, "") : "", z = W < 0 ? "-" : "", j = op(this._months) !== op(W) ? "-" : "", Z = op(this._days) !== op(W) ? "-" : "", H = op(this._milliseconds) !== op(W) ? "-" : "", z + "P" + (M ? j + M + "Y" : "") + (d ? j + d + "M" : "") + (c ? Z + c + "D" : "") + (w || m || o ? "T" : "") + (w ? H + w + "H" : "") + (m ? H + m + "M" : "") + (o ? H + C + "S" : "")) : "P0D";
}
var xn = i_.prototype;
xn.isValid = $P;
xn.abs = bz;
xn.add = Mz;
xn.subtract = Rz;
xn.as = kz;
xn.asMilliseconds = Lz;
xn.asSeconds = Nz;
xn.asMinutes = Pz;
xn.asHours = Az;
xn.asDays = zz;
xn.asWeeks = Uz;
xn.asMonths = Iz;
xn.asQuarters = jz;
xn.asYears = Fz;
xn.valueOf = Oz;
xn._bubble = Dz;
xn.clone = Hz;
xn.get = Bz;
xn.milliseconds = Yz;
xn.seconds = Vz;
xn.minutes = Wz;
xn.hours = Zz;
xn.days = $z;
xn.weeks = qz;
xn.months = Gz;
xn.years = Qz;
xn.humanize = t2;
xn.toISOString = o_;
xn.toString = o_;
xn.toJSON = o_;
xn.locale = Eb;
xn.localeData = Cb;
xn.toIsoString = ks(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  o_
);
xn.lang = Tb;
Ct("X", 0, 0, "unix");
Ct("x", 0, 0, "valueOf");
rt("x", e_);
rt("X", TN);
nr("X", function(o, c, d) {
  d._d = new Date(parseFloat(o) * 1e3);
});
nr("x", function(o, c, d) {
  d._d = new Date(fn(o));
});
//! moment.js
Ye.version = "2.29.4";
nN(gr);
Ye.fn = be;
Ye.min = YP;
Ye.max = VP;
Ye.now = WP;
Ye.utc = rl;
Ye.unix = _z;
Ye.months = wz;
Ye.isDate = gm;
Ye.locale = hf;
Ye.invalid = Qg;
Ye.duration = du;
Ye.isMoment = fu;
Ye.weekdays = Tz;
Ye.parseZone = Sz;
Ye.localeData = ac;
Ye.isDuration = Ig;
Ye.monthsShort = Ez;
Ye.weekdaysMin = xz;
Ye.defineLocale = oE;
Ye.updateLocale = SP;
Ye.locales = wP;
Ye.weekdaysShort = Cz;
Ye.normalizeUnits = Os;
Ye.relativeTimeRounding = Jz;
Ye.relativeTimeThreshold = e2;
Ye.calendarFormat = mA;
Ye.prototype = be;
Ye.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
var Ab = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, wx = Et.createContext && Et.createContext(Ab), pf = globalThis && globalThis.__assign || function() {
  return pf = Object.assign || function(o) {
    for (var c, d = 1, m = arguments.length; d < m; d++) {
      c = arguments[d];
      for (var w in c)
        Object.prototype.hasOwnProperty.call(c, w) && (o[w] = c[w]);
    }
    return o;
  }, pf.apply(this, arguments);
}, n2 = globalThis && globalThis.__rest || function(o, c) {
  var d = {};
  for (var m in o)
    Object.prototype.hasOwnProperty.call(o, m) && c.indexOf(m) < 0 && (d[m] = o[m]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var w = 0, m = Object.getOwnPropertySymbols(o); w < m.length; w++)
      c.indexOf(m[w]) < 0 && Object.prototype.propertyIsEnumerable.call(o, m[w]) && (d[m[w]] = o[m[w]]);
  return d;
};
function zb(o) {
  return o && o.map(function(c, d) {
    return Et.createElement(c.tag, pf({
      key: d
    }, c.attr), zb(c.child));
  });
}
function r2(o) {
  return function(c) {
    return Et.createElement(i2, pf({
      attr: pf({}, o.attr)
    }, c), zb(o.child));
  };
}
function i2(o) {
  var c = function(d) {
    var m = o.attr, w = o.size, M = o.title, C = n2(o, ["attr", "size", "title"]), W = w || d.size || "1em", z;
    return d.className && (z = d.className), o.className && (z = (z ? z + " " : "") + o.className), Et.createElement("svg", pf({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, d.attr, m, C, {
      className: z,
      style: pf(pf({
        color: o.color || d.color
      }, d.style), o.style),
      height: W,
      width: W,
      xmlns: "http://www.w3.org/2000/svg"
    }), M && Et.createElement("title", null, M), o.children);
  };
  return wx !== void 0 ? Et.createElement(wx.Consumer, null, function(d) {
    return c(d);
  }) : c(Ab);
}
var Bw = { exports: {} };
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
(function(o, c) {
  (function(d, m) {
    m(c);
  })(IL, function(d) {
    var m = "1.9.4";
    function w(r) {
      var u, h, y, T;
      for (h = 1, y = arguments.length; h < y; h++) {
        T = arguments[h];
        for (u in T)
          r[u] = T[u];
      }
      return r;
    }
    var M = Object.create || function() {
      function r() {
      }
      return function(u) {
        return r.prototype = u, new r();
      };
    }();
    function C(r, u) {
      var h = Array.prototype.slice;
      if (r.bind)
        return r.bind.apply(r, h.call(arguments, 1));
      var y = h.call(arguments, 2);
      return function() {
        return r.apply(u, y.length ? y.concat(h.call(arguments)) : arguments);
      };
    }
    var W = 0;
    function z(r) {
      return "_leaflet_id" in r || (r._leaflet_id = ++W), r._leaflet_id;
    }
    function j(r, u, h) {
      var y, T, D, I;
      return I = function() {
        y = !1, T && (D.apply(h, T), T = !1);
      }, D = function() {
        y ? T = arguments : (r.apply(h, arguments), setTimeout(I, u), y = !0);
      }, D;
    }
    function Z(r, u, h) {
      var y = u[1], T = u[0], D = y - T;
      return r === y && h ? r : ((r - T) % D + D) % D + T;
    }
    function H() {
      return !1;
    }
    function $(r, u) {
      if (u === !1)
        return r;
      var h = Math.pow(10, u === void 0 ? 6 : u);
      return Math.round(r * h) / h;
    }
    function J(r) {
      return r.trim ? r.trim() : r.replace(/^\s+|\s+$/g, "");
    }
    function oe(r) {
      return J(r).split(/\s+/);
    }
    function ce(r, u) {
      Object.prototype.hasOwnProperty.call(r, "options") || (r.options = r.options ? M(r.options) : {});
      for (var h in u)
        r.options[h] = u[h];
      return r.options;
    }
    function ue(r, u, h) {
      var y = [];
      for (var T in r)
        y.push(encodeURIComponent(h ? T.toUpperCase() : T) + "=" + encodeURIComponent(r[T]));
      return (!u || u.indexOf("?") === -1 ? "?" : "&") + y.join("&");
    }
    var Ke = /\{ *([\w_ -]+) *\}/g;
    function He(r, u) {
      return r.replace(Ke, function(h, y) {
        var T = u[y];
        if (T === void 0)
          throw new Error("No value provided for variable " + h);
        return typeof T == "function" && (T = T(u)), T;
      });
    }
    var ve = Array.isArray || function(r) {
      return Object.prototype.toString.call(r) === "[object Array]";
    };
    function ye(r, u) {
      for (var h = 0; h < r.length; h++)
        if (r[h] === u)
          return h;
      return -1;
    }
    var G = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
    function Me(r) {
      return window["webkit" + r] || window["moz" + r] || window["ms" + r];
    }
    var ze = 0;
    function kt(r) {
      var u = +/* @__PURE__ */ new Date(), h = Math.max(0, 16 - (u - ze));
      return ze = u + h, window.setTimeout(r, h);
    }
    var It = window.requestAnimationFrame || Me("RequestAnimationFrame") || kt, Nt = window.cancelAnimationFrame || Me("CancelAnimationFrame") || Me("CancelRequestAnimationFrame") || function(r) {
      window.clearTimeout(r);
    };
    function Xe(r, u, h) {
      if (h && It === kt)
        r.call(u);
      else
        return It.call(window, C(r, u));
    }
    function Mt(r) {
      r && Nt.call(window, r);
    }
    var ut = {
      __proto__: null,
      extend: w,
      create: M,
      bind: C,
      get lastId() {
        return W;
      },
      stamp: z,
      throttle: j,
      wrapNum: Z,
      falseFn: H,
      formatNum: $,
      trim: J,
      splitWords: oe,
      setOptions: ce,
      getParamString: ue,
      template: He,
      isArray: ve,
      indexOf: ye,
      emptyImageUrl: G,
      requestFn: It,
      cancelFn: Nt,
      requestAnimFrame: Xe,
      cancelAnimFrame: Mt
    };
    function lt() {
    }
    lt.extend = function(r) {
      var u = function() {
        ce(this), this.initialize && this.initialize.apply(this, arguments), this.callInitHooks();
      }, h = u.__super__ = this.prototype, y = M(h);
      y.constructor = u, u.prototype = y;
      for (var T in this)
        Object.prototype.hasOwnProperty.call(this, T) && T !== "prototype" && T !== "__super__" && (u[T] = this[T]);
      return r.statics && w(u, r.statics), r.includes && (tn(r.includes), w.apply(null, [y].concat(r.includes))), w(y, r), delete y.statics, delete y.includes, y.options && (y.options = h.options ? M(h.options) : {}, w(y.options, r.options)), y._initHooks = [], y.callInitHooks = function() {
        if (!this._initHooksCalled) {
          h.callInitHooks && h.callInitHooks.call(this), this._initHooksCalled = !0;
          for (var D = 0, I = y._initHooks.length; D < I; D++)
            y._initHooks[D].call(this);
        }
      }, u;
    }, lt.include = function(r) {
      var u = this.prototype.options;
      return w(this.prototype, r), r.options && (this.prototype.options = u, this.mergeOptions(r.options)), this;
    }, lt.mergeOptions = function(r) {
      return w(this.prototype.options, r), this;
    }, lt.addInitHook = function(r) {
      var u = Array.prototype.slice.call(arguments, 1), h = typeof r == "function" ? r : function() {
        this[r].apply(this, u);
      };
      return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(h), this;
    };
    function tn(r) {
      if (!(typeof L > "u" || !L || !L.Mixin)) {
        r = ve(r) ? r : [r];
        for (var u = 0; u < r.length; u++)
          r[u] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
      }
    }
    var vt = {
      /* @method on(type: String, fn: Function, context?: Object): this
       * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
       *
       * @alternative
       * @method on(eventMap: Object): this
       * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
       */
      on: function(r, u, h) {
        if (typeof r == "object")
          for (var y in r)
            this._on(y, r[y], u);
        else {
          r = oe(r);
          for (var T = 0, D = r.length; T < D; T++)
            this._on(r[T], u, h);
        }
        return this;
      },
      /* @method off(type: String, fn?: Function, context?: Object): this
       * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
       *
       * @alternative
       * @method off(eventMap: Object): this
       * Removes a set of type/listener pairs.
       *
       * @alternative
       * @method off: this
       * Removes all listeners to all events on the object. This includes implicitly attached events.
       */
      off: function(r, u, h) {
        if (!arguments.length)
          delete this._events;
        else if (typeof r == "object")
          for (var y in r)
            this._off(y, r[y], u);
        else {
          r = oe(r);
          for (var T = arguments.length === 1, D = 0, I = r.length; D < I; D++)
            T ? this._off(r[D]) : this._off(r[D], u, h);
        }
        return this;
      },
      // attach listener (without syntactic sugar now)
      _on: function(r, u, h, y) {
        if (typeof u != "function") {
          console.warn("wrong listener type: " + typeof u);
          return;
        }
        if (this._listens(r, u, h) === !1) {
          h === this && (h = void 0);
          var T = { fn: u, ctx: h };
          y && (T.once = !0), this._events = this._events || {}, this._events[r] = this._events[r] || [], this._events[r].push(T);
        }
      },
      _off: function(r, u, h) {
        var y, T, D;
        if (this._events && (y = this._events[r], !!y)) {
          if (arguments.length === 1) {
            if (this._firingCount)
              for (T = 0, D = y.length; T < D; T++)
                y[T].fn = H;
            delete this._events[r];
            return;
          }
          if (typeof u != "function") {
            console.warn("wrong listener type: " + typeof u);
            return;
          }
          var I = this._listens(r, u, h);
          if (I !== !1) {
            var Q = y[I];
            this._firingCount && (Q.fn = H, this._events[r] = y = y.slice()), y.splice(I, 1);
          }
        }
      },
      // @method fire(type: String, data?: Object, propagate?: Boolean): this
      // Fires an event of the specified type. You can optionally provide a data
      // object  the first argument of the listener function will contain its
      // properties. The event can optionally be propagated to event parents.
      fire: function(r, u, h) {
        if (!this.listens(r, h))
          return this;
        var y = w({}, u, {
          type: r,
          target: this,
          sourceTarget: u && u.sourceTarget || this
        });
        if (this._events) {
          var T = this._events[r];
          if (T) {
            this._firingCount = this._firingCount + 1 || 1;
            for (var D = 0, I = T.length; D < I; D++) {
              var Q = T[D], ie = Q.fn;
              Q.once && this.off(r, ie, Q.ctx), ie.call(Q.ctx || this, y);
            }
            this._firingCount--;
          }
        }
        return h && this._propagateEvent(y), this;
      },
      // @method listens(type: String, propagate?: Boolean): Boolean
      // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
      // Returns `true` if a particular event type has any listeners attached to it.
      // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
      listens: function(r, u, h, y) {
        typeof r != "string" && console.warn('"string" type argument expected');
        var T = u;
        typeof u != "function" && (y = !!u, T = void 0, h = void 0);
        var D = this._events && this._events[r];
        if (D && D.length && this._listens(r, T, h) !== !1)
          return !0;
        if (y) {
          for (var I in this._eventParents)
            if (this._eventParents[I].listens(r, u, h, y))
              return !0;
        }
        return !1;
      },
      // returns the index (number) or false
      _listens: function(r, u, h) {
        if (!this._events)
          return !1;
        var y = this._events[r] || [];
        if (!u)
          return !!y.length;
        h === this && (h = void 0);
        for (var T = 0, D = y.length; T < D; T++)
          if (y[T].fn === u && y[T].ctx === h)
            return T;
        return !1;
      },
      // @method once(): this
      // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
      once: function(r, u, h) {
        if (typeof r == "object")
          for (var y in r)
            this._on(y, r[y], u, !0);
        else {
          r = oe(r);
          for (var T = 0, D = r.length; T < D; T++)
            this._on(r[T], u, h, !0);
        }
        return this;
      },
      // @method addEventParent(obj: Evented): this
      // Adds an event parent - an `Evented` that will receive propagated events
      addEventParent: function(r) {
        return this._eventParents = this._eventParents || {}, this._eventParents[z(r)] = r, this;
      },
      // @method removeEventParent(obj: Evented): this
      // Removes an event parent, so it will stop receiving propagated events
      removeEventParent: function(r) {
        return this._eventParents && delete this._eventParents[z(r)], this;
      },
      _propagateEvent: function(r) {
        for (var u in this._eventParents)
          this._eventParents[u].fire(r.type, w({
            layer: r.target,
            propagatedFrom: r.target
          }, r), !0);
      }
    };
    vt.addEventListener = vt.on, vt.removeEventListener = vt.clearAllEventListeners = vt.off, vt.addOneTimeEventListener = vt.once, vt.fireEvent = vt.fire, vt.hasEventListeners = vt.listens;
    var Ne = lt.extend(vt);
    function le(r, u, h) {
      this.x = h ? Math.round(r) : r, this.y = h ? Math.round(u) : u;
    }
    var Je = Math.trunc || function(r) {
      return r > 0 ? Math.floor(r) : Math.ceil(r);
    };
    le.prototype = {
      // @method clone(): Point
      // Returns a copy of the current point.
      clone: function() {
        return new le(this.x, this.y);
      },
      // @method add(otherPoint: Point): Point
      // Returns the result of addition of the current and the given points.
      add: function(r) {
        return this.clone()._add(N(r));
      },
      _add: function(r) {
        return this.x += r.x, this.y += r.y, this;
      },
      // @method subtract(otherPoint: Point): Point
      // Returns the result of subtraction of the given point from the current.
      subtract: function(r) {
        return this.clone()._subtract(N(r));
      },
      _subtract: function(r) {
        return this.x -= r.x, this.y -= r.y, this;
      },
      // @method divideBy(num: Number): Point
      // Returns the result of division of the current point by the given number.
      divideBy: function(r) {
        return this.clone()._divideBy(r);
      },
      _divideBy: function(r) {
        return this.x /= r, this.y /= r, this;
      },
      // @method multiplyBy(num: Number): Point
      // Returns the result of multiplication of the current point by the given number.
      multiplyBy: function(r) {
        return this.clone()._multiplyBy(r);
      },
      _multiplyBy: function(r) {
        return this.x *= r, this.y *= r, this;
      },
      // @method scaleBy(scale: Point): Point
      // Multiply each coordinate of the current point by each coordinate of
      // `scale`. In linear algebra terms, multiply the point by the
      // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
      // defined by `scale`.
      scaleBy: function(r) {
        return new le(this.x * r.x, this.y * r.y);
      },
      // @method unscaleBy(scale: Point): Point
      // Inverse of `scaleBy`. Divide each coordinate of the current point by
      // each coordinate of `scale`.
      unscaleBy: function(r) {
        return new le(this.x / r.x, this.y / r.y);
      },
      // @method round(): Point
      // Returns a copy of the current point with rounded coordinates.
      round: function() {
        return this.clone()._round();
      },
      _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      },
      // @method floor(): Point
      // Returns a copy of the current point with floored coordinates (rounded down).
      floor: function() {
        return this.clone()._floor();
      },
      _floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
      },
      // @method ceil(): Point
      // Returns a copy of the current point with ceiled coordinates (rounded up).
      ceil: function() {
        return this.clone()._ceil();
      },
      _ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
      },
      // @method trunc(): Point
      // Returns a copy of the current point with truncated coordinates (rounded towards zero).
      trunc: function() {
        return this.clone()._trunc();
      },
      _trunc: function() {
        return this.x = Je(this.x), this.y = Je(this.y), this;
      },
      // @method distanceTo(otherPoint: Point): Number
      // Returns the cartesian distance between the current and the given points.
      distanceTo: function(r) {
        r = N(r);
        var u = r.x - this.x, h = r.y - this.y;
        return Math.sqrt(u * u + h * h);
      },
      // @method equals(otherPoint: Point): Boolean
      // Returns `true` if the given point has the same coordinates.
      equals: function(r) {
        return r = N(r), r.x === this.x && r.y === this.y;
      },
      // @method contains(otherPoint: Point): Boolean
      // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
      contains: function(r) {
        return r = N(r), Math.abs(r.x) <= Math.abs(this.x) && Math.abs(r.y) <= Math.abs(this.y);
      },
      // @method toString(): String
      // Returns a string representation of the point for debugging purposes.
      toString: function() {
        return "Point(" + $(this.x) + ", " + $(this.y) + ")";
      }
    };
    function N(r, u, h) {
      return r instanceof le ? r : ve(r) ? new le(r[0], r[1]) : r == null ? r : typeof r == "object" && "x" in r && "y" in r ? new le(r.x, r.y) : new le(r, u, h);
    }
    function se(r, u) {
      if (r)
        for (var h = u ? [r, u] : r, y = 0, T = h.length; y < T; y++)
          this.extend(h[y]);
    }
    se.prototype = {
      // @method extend(point: Point): this
      // Extends the bounds to contain the given point.
      // @alternative
      // @method extend(otherBounds: Bounds): this
      // Extend the bounds to contain the given bounds
      extend: function(r) {
        var u, h;
        if (!r)
          return this;
        if (r instanceof le || typeof r[0] == "number" || "x" in r)
          u = h = N(r);
        else if (r = xe(r), u = r.min, h = r.max, !u || !h)
          return this;
        return !this.min && !this.max ? (this.min = u.clone(), this.max = h.clone()) : (this.min.x = Math.min(u.x, this.min.x), this.max.x = Math.max(h.x, this.max.x), this.min.y = Math.min(u.y, this.min.y), this.max.y = Math.max(h.y, this.max.y)), this;
      },
      // @method getCenter(round?: Boolean): Point
      // Returns the center point of the bounds.
      getCenter: function(r) {
        return N(
          (this.min.x + this.max.x) / 2,
          (this.min.y + this.max.y) / 2,
          r
        );
      },
      // @method getBottomLeft(): Point
      // Returns the bottom-left point of the bounds.
      getBottomLeft: function() {
        return N(this.min.x, this.max.y);
      },
      // @method getTopRight(): Point
      // Returns the top-right point of the bounds.
      getTopRight: function() {
        return N(this.max.x, this.min.y);
      },
      // @method getTopLeft(): Point
      // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
      getTopLeft: function() {
        return this.min;
      },
      // @method getBottomRight(): Point
      // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
      getBottomRight: function() {
        return this.max;
      },
      // @method getSize(): Point
      // Returns the size of the given bounds
      getSize: function() {
        return this.max.subtract(this.min);
      },
      // @method contains(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle contains the given one.
      // @alternative
      // @method contains(point: Point): Boolean
      // Returns `true` if the rectangle contains the given point.
      contains: function(r) {
        var u, h;
        return typeof r[0] == "number" || r instanceof le ? r = N(r) : r = xe(r), r instanceof se ? (u = r.min, h = r.max) : u = h = r, u.x >= this.min.x && h.x <= this.max.x && u.y >= this.min.y && h.y <= this.max.y;
      },
      // @method intersects(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle intersects the given bounds. Two bounds
      // intersect if they have at least one point in common.
      intersects: function(r) {
        r = xe(r);
        var u = this.min, h = this.max, y = r.min, T = r.max, D = T.x >= u.x && y.x <= h.x, I = T.y >= u.y && y.y <= h.y;
        return D && I;
      },
      // @method overlaps(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle overlaps the given bounds. Two bounds
      // overlap if their intersection is an area.
      overlaps: function(r) {
        r = xe(r);
        var u = this.min, h = this.max, y = r.min, T = r.max, D = T.x > u.x && y.x < h.x, I = T.y > u.y && y.y < h.y;
        return D && I;
      },
      // @method isValid(): Boolean
      // Returns `true` if the bounds are properly initialized.
      isValid: function() {
        return !!(this.min && this.max);
      },
      // @method pad(bufferRatio: Number): Bounds
      // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
      // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
      // Negative values will retract the bounds.
      pad: function(r) {
        var u = this.min, h = this.max, y = Math.abs(u.x - h.x) * r, T = Math.abs(u.y - h.y) * r;
        return xe(
          N(u.x - y, u.y - T),
          N(h.x + y, h.y + T)
        );
      },
      // @method equals(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle is equivalent to the given bounds.
      equals: function(r) {
        return r ? (r = xe(r), this.min.equals(r.getTopLeft()) && this.max.equals(r.getBottomRight())) : !1;
      }
    };
    function xe(r, u) {
      return !r || r instanceof se ? r : new se(r, u);
    }
    function et(r, u) {
      if (r)
        for (var h = u ? [r, u] : r, y = 0, T = h.length; y < T; y++)
          this.extend(h[y]);
    }
    et.prototype = {
      // @method extend(latlng: LatLng): this
      // Extend the bounds to contain the given point
      // @alternative
      // @method extend(otherBounds: LatLngBounds): this
      // Extend the bounds to contain the given bounds
      extend: function(r) {
        var u = this._southWest, h = this._northEast, y, T;
        if (r instanceof qe)
          y = r, T = r;
        else if (r instanceof et) {
          if (y = r._southWest, T = r._northEast, !y || !T)
            return this;
        } else
          return r ? this.extend(Oe(r) || je(r)) : this;
        return !u && !h ? (this._southWest = new qe(y.lat, y.lng), this._northEast = new qe(T.lat, T.lng)) : (u.lat = Math.min(y.lat, u.lat), u.lng = Math.min(y.lng, u.lng), h.lat = Math.max(T.lat, h.lat), h.lng = Math.max(T.lng, h.lng)), this;
      },
      // @method pad(bufferRatio: Number): LatLngBounds
      // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
      // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
      // Negative values will retract the bounds.
      pad: function(r) {
        var u = this._southWest, h = this._northEast, y = Math.abs(u.lat - h.lat) * r, T = Math.abs(u.lng - h.lng) * r;
        return new et(
          new qe(u.lat - y, u.lng - T),
          new qe(h.lat + y, h.lng + T)
        );
      },
      // @method getCenter(): LatLng
      // Returns the center point of the bounds.
      getCenter: function() {
        return new qe(
          (this._southWest.lat + this._northEast.lat) / 2,
          (this._southWest.lng + this._northEast.lng) / 2
        );
      },
      // @method getSouthWest(): LatLng
      // Returns the south-west point of the bounds.
      getSouthWest: function() {
        return this._southWest;
      },
      // @method getNorthEast(): LatLng
      // Returns the north-east point of the bounds.
      getNorthEast: function() {
        return this._northEast;
      },
      // @method getNorthWest(): LatLng
      // Returns the north-west point of the bounds.
      getNorthWest: function() {
        return new qe(this.getNorth(), this.getWest());
      },
      // @method getSouthEast(): LatLng
      // Returns the south-east point of the bounds.
      getSouthEast: function() {
        return new qe(this.getSouth(), this.getEast());
      },
      // @method getWest(): Number
      // Returns the west longitude of the bounds
      getWest: function() {
        return this._southWest.lng;
      },
      // @method getSouth(): Number
      // Returns the south latitude of the bounds
      getSouth: function() {
        return this._southWest.lat;
      },
      // @method getEast(): Number
      // Returns the east longitude of the bounds
      getEast: function() {
        return this._northEast.lng;
      },
      // @method getNorth(): Number
      // Returns the north latitude of the bounds
      getNorth: function() {
        return this._northEast.lat;
      },
      // @method contains(otherBounds: LatLngBounds): Boolean
      // Returns `true` if the rectangle contains the given one.
      // @alternative
      // @method contains (latlng: LatLng): Boolean
      // Returns `true` if the rectangle contains the given point.
      contains: function(r) {
        typeof r[0] == "number" || r instanceof qe || "lat" in r ? r = Oe(r) : r = je(r);
        var u = this._southWest, h = this._northEast, y, T;
        return r instanceof et ? (y = r.getSouthWest(), T = r.getNorthEast()) : y = T = r, y.lat >= u.lat && T.lat <= h.lat && y.lng >= u.lng && T.lng <= h.lng;
      },
      // @method intersects(otherBounds: LatLngBounds): Boolean
      // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
      intersects: function(r) {
        r = je(r);
        var u = this._southWest, h = this._northEast, y = r.getSouthWest(), T = r.getNorthEast(), D = T.lat >= u.lat && y.lat <= h.lat, I = T.lng >= u.lng && y.lng <= h.lng;
        return D && I;
      },
      // @method overlaps(otherBounds: LatLngBounds): Boolean
      // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
      overlaps: function(r) {
        r = je(r);
        var u = this._southWest, h = this._northEast, y = r.getSouthWest(), T = r.getNorthEast(), D = T.lat > u.lat && y.lat < h.lat, I = T.lng > u.lng && y.lng < h.lng;
        return D && I;
      },
      // @method toBBoxString(): String
      // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
      toBBoxString: function() {
        return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
      },
      // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
      // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
      equals: function(r, u) {
        return r ? (r = je(r), this._southWest.equals(r.getSouthWest(), u) && this._northEast.equals(r.getNorthEast(), u)) : !1;
      },
      // @method isValid(): Boolean
      // Returns `true` if the bounds are properly initialized.
      isValid: function() {
        return !!(this._southWest && this._northEast);
      }
    };
    function je(r, u) {
      return r instanceof et ? r : new et(r, u);
    }
    function qe(r, u, h) {
      if (isNaN(r) || isNaN(u))
        throw new Error("Invalid LatLng object: (" + r + ", " + u + ")");
      this.lat = +r, this.lng = +u, h !== void 0 && (this.alt = +h);
    }
    qe.prototype = {
      // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
      // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
      equals: function(r, u) {
        if (!r)
          return !1;
        r = Oe(r);
        var h = Math.max(
          Math.abs(this.lat - r.lat),
          Math.abs(this.lng - r.lng)
        );
        return h <= (u === void 0 ? 1e-9 : u);
      },
      // @method toString(): String
      // Returns a string representation of the point (for debugging purposes).
      toString: function(r) {
        return "LatLng(" + $(this.lat, r) + ", " + $(this.lng, r) + ")";
      },
      // @method distanceTo(otherLatLng: LatLng): Number
      // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
      distanceTo: function(r) {
        return _t.distance(this, Oe(r));
      },
      // @method wrap(): LatLng
      // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
      wrap: function() {
        return _t.wrapLatLng(this);
      },
      // @method toBounds(sizeInMeters: Number): LatLngBounds
      // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
      toBounds: function(r) {
        var u = 180 * r / 40075017, h = u / Math.cos(Math.PI / 180 * this.lat);
        return je(
          [this.lat - u, this.lng - h],
          [this.lat + u, this.lng + h]
        );
      },
      clone: function() {
        return new qe(this.lat, this.lng, this.alt);
      }
    };
    function Oe(r, u, h) {
      return r instanceof qe ? r : ve(r) && typeof r[0] != "object" ? r.length === 3 ? new qe(r[0], r[1], r[2]) : r.length === 2 ? new qe(r[0], r[1]) : null : r == null ? r : typeof r == "object" && "lat" in r ? new qe(r.lat, "lng" in r ? r.lng : r.lon, r.alt) : u === void 0 ? null : new qe(r, u, h);
    }
    var Rt = {
      // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
      // Projects geographical coordinates into pixel coordinates for a given zoom.
      latLngToPoint: function(r, u) {
        var h = this.projection.project(r), y = this.scale(u);
        return this.transformation._transform(h, y);
      },
      // @method pointToLatLng(point: Point, zoom: Number): LatLng
      // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
      // zoom into geographical coordinates.
      pointToLatLng: function(r, u) {
        var h = this.scale(u), y = this.transformation.untransform(r, h);
        return this.projection.unproject(y);
      },
      // @method project(latlng: LatLng): Point
      // Projects geographical coordinates into coordinates in units accepted for
      // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
      project: function(r) {
        return this.projection.project(r);
      },
      // @method unproject(point: Point): LatLng
      // Given a projected coordinate returns the corresponding LatLng.
      // The inverse of `project`.
      unproject: function(r) {
        return this.projection.unproject(r);
      },
      // @method scale(zoom: Number): Number
      // Returns the scale used when transforming projected coordinates into
      // pixel coordinates for a particular zoom. For example, it returns
      // `256 * 2^zoom` for Mercator-based CRS.
      scale: function(r) {
        return 256 * Math.pow(2, r);
      },
      // @method zoom(scale: Number): Number
      // Inverse of `scale()`, returns the zoom level corresponding to a scale
      // factor of `scale`.
      zoom: function(r) {
        return Math.log(r / 256) / Math.LN2;
      },
      // @method getProjectedBounds(zoom: Number): Bounds
      // Returns the projection's bounds scaled and transformed for the provided `zoom`.
      getProjectedBounds: function(r) {
        if (this.infinite)
          return null;
        var u = this.projection.bounds, h = this.scale(r), y = this.transformation.transform(u.min, h), T = this.transformation.transform(u.max, h);
        return new se(y, T);
      },
      // @method distance(latlng1: LatLng, latlng2: LatLng): Number
      // Returns the distance between two geographical coordinates.
      // @property code: String
      // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
      //
      // @property wrapLng: Number[]
      // An array of two numbers defining whether the longitude (horizontal) coordinate
      // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
      // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
      //
      // @property wrapLat: Number[]
      // Like `wrapLng`, but for the latitude (vertical) axis.
      // wrapLng: [min, max],
      // wrapLat: [min, max],
      // @property infinite: Boolean
      // If true, the coordinate space will be unbounded (infinite in both axes)
      infinite: !1,
      // @method wrapLatLng(latlng: LatLng): LatLng
      // Returns a `LatLng` where lat and lng has been wrapped according to the
      // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
      wrapLatLng: function(r) {
        var u = this.wrapLng ? Z(r.lng, this.wrapLng, !0) : r.lng, h = this.wrapLat ? Z(r.lat, this.wrapLat, !0) : r.lat, y = r.alt;
        return new qe(h, u, y);
      },
      // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
      // Returns a `LatLngBounds` with the same size as the given one, ensuring
      // that its center is within the CRS's bounds.
      // Only accepts actual `L.LatLngBounds` instances, not arrays.
      wrapLatLngBounds: function(r) {
        var u = r.getCenter(), h = this.wrapLatLng(u), y = u.lat - h.lat, T = u.lng - h.lng;
        if (y === 0 && T === 0)
          return r;
        var D = r.getSouthWest(), I = r.getNorthEast(), Q = new qe(D.lat - y, D.lng - T), ie = new qe(I.lat - y, I.lng - T);
        return new et(Q, ie);
      }
    }, _t = w({}, Rt, {
      wrapLng: [-180, 180],
      // Mean Earth Radius, as recommended for use by
      // the International Union of Geodesy and Geophysics,
      // see https://rosettacode.org/wiki/Haversine_formula
      R: 6371e3,
      // distance between two geographical points using spherical law of cosines approximation
      distance: function(r, u) {
        var h = Math.PI / 180, y = r.lat * h, T = u.lat * h, D = Math.sin((u.lat - r.lat) * h / 2), I = Math.sin((u.lng - r.lng) * h / 2), Q = D * D + Math.cos(y) * Math.cos(T) * I * I, ie = 2 * Math.atan2(Math.sqrt(Q), Math.sqrt(1 - Q));
        return this.R * ie;
      }
    }), on = 6378137, Sr = {
      R: on,
      MAX_LATITUDE: 85.0511287798,
      project: function(r) {
        var u = Math.PI / 180, h = this.MAX_LATITUDE, y = Math.max(Math.min(h, r.lat), -h), T = Math.sin(y * u);
        return new le(
          this.R * r.lng * u,
          this.R * Math.log((1 + T) / (1 - T)) / 2
        );
      },
      unproject: function(r) {
        var u = 180 / Math.PI;
        return new qe(
          (2 * Math.atan(Math.exp(r.y / this.R)) - Math.PI / 2) * u,
          r.x * u / this.R
        );
      },
      bounds: function() {
        var r = on * Math.PI;
        return new se([-r, -r], [r, r]);
      }()
    };
    function ur(r, u, h, y) {
      if (ve(r)) {
        this._a = r[0], this._b = r[1], this._c = r[2], this._d = r[3];
        return;
      }
      this._a = r, this._b = u, this._c = h, this._d = y;
    }
    ur.prototype = {
      // @method transform(point: Point, scale?: Number): Point
      // Returns a transformed point, optionally multiplied by the given scale.
      // Only accepts actual `L.Point` instances, not arrays.
      transform: function(r, u) {
        return this._transform(r.clone(), u);
      },
      // destructive transform (faster)
      _transform: function(r, u) {
        return u = u || 1, r.x = u * (this._a * r.x + this._b), r.y = u * (this._c * r.y + this._d), r;
      },
      // @method untransform(point: Point, scale?: Number): Point
      // Returns the reverse transformation of the given point, optionally divided
      // by the given scale. Only accepts actual `L.Point` instances, not arrays.
      untransform: function(r, u) {
        return u = u || 1, new le(
          (r.x / u - this._b) / this._a,
          (r.y / u - this._d) / this._c
        );
      }
    };
    function Ue(r, u, h, y) {
      return new ur(r, u, h, y);
    }
    var yn = w({}, _t, {
      code: "EPSG:3857",
      projection: Sr,
      transformation: function() {
        var r = 0.5 / (Math.PI * Sr.R);
        return Ue(r, 0.5, -r, 0.5);
      }()
    }), Ie = w({}, yn, {
      code: "EPSG:900913"
    });
    function zn(r) {
      return document.createElementNS("http://www.w3.org/2000/svg", r);
    }
    function Xn(r, u) {
      var h = "", y, T, D, I, Q, ie;
      for (y = 0, D = r.length; y < D; y++) {
        for (Q = r[y], T = 0, I = Q.length; T < I; T++)
          ie = Q[T], h += (T ? "L" : "M") + ie.x + " " + ie.y;
        h += u ? We.svg ? "z" : "x" : "";
      }
      return h || "M0 0";
    }
    var Bn = document.documentElement.style, Hr = "ActiveXObject" in window, ki = Hr && !document.addEventListener, Dr = "msLaunchUri" in navigator && !("documentMode" in document), zr = tr("webkit"), fi = tr("android"), Br = tr("android 2") || tr("android 3"), Yi = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), Yr = fi && tr("Google") && Yi < 537 && !("AudioNode" in window), Xr = !!window.opera, er = !Dr && tr("chrome"), Jr = tr("gecko") && !zr && !Xr && !Hr, Qa = !er && tr("safari"), Oi = tr("phantom"), De = "OTransition" in Bn, ft = navigator.platform.indexOf("Win") === 0, Yt = Hr && "transition" in Bn, dn = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !Br, gn = "MozPerspective" in Bn, dr = !window.L_DISABLE_3D && (Yt || dn || gn) && !De && !Oi, Un = typeof orientation < "u" || tr("mobile"), ei = Un && zr, bn = Un && dn, ti = !window.PointerEvent && window.MSPointerEvent, _n = !!(window.PointerEvent || ti), Sn = "ontouchstart" in window || !!window.TouchEvent, Ma = !window.L_NO_TOUCH && (Sn || _n), ia = Un && Xr, ns = Un && Jr, Ls = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1, hu = function() {
      var r = !1;
      try {
        var u = Object.defineProperty({}, "passive", {
          get: function() {
            r = !0;
          }
        });
        window.addEventListener("testPassiveEventSupport", H, u), window.removeEventListener("testPassiveEventSupport", H, u);
      } catch {
      }
      return r;
    }(), Lo = function() {
      return !!document.createElement("canvas").getContext;
    }(), qa = !!(document.createElementNS && zn("svg").createSVGRect), Vi = !!qa && function() {
      var r = document.createElement("div");
      return r.innerHTML = "<svg/>", (r.firstChild && r.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
    }(), Ka = !qa && function() {
      try {
        var r = document.createElement("div");
        r.innerHTML = '<v:shape adj="1"/>';
        var u = r.firstChild;
        return u.style.behavior = "url(#default#VML)", u && typeof u.adj == "object";
      } catch {
        return !1;
      }
    }(), Wi = navigator.platform.indexOf("Mac") === 0, Xa = navigator.platform.indexOf("Linux") === 0;
    function tr(r) {
      return navigator.userAgent.toLowerCase().indexOf(r) >= 0;
    }
    var We = {
      ie: Hr,
      ielt9: ki,
      edge: Dr,
      webkit: zr,
      android: fi,
      android23: Br,
      androidStock: Yr,
      opera: Xr,
      chrome: er,
      gecko: Jr,
      safari: Qa,
      phantom: Oi,
      opera12: De,
      win: ft,
      ie3d: Yt,
      webkit3d: dn,
      gecko3d: gn,
      any3d: dr,
      mobile: Un,
      mobileWebkit: ei,
      mobileWebkit3d: bn,
      msPointer: ti,
      pointer: _n,
      touch: Ma,
      touchNative: Sn,
      mobileOpera: ia,
      mobileGecko: ns,
      retina: Ls,
      passiveEvents: hu,
      canvas: Lo,
      svg: qa,
      vml: Ka,
      inlineSvg: Vi,
      mac: Wi,
      linux: Xa
    }, Ra = We.msPointer ? "MSPointerDown" : "pointerdown", U = We.msPointer ? "MSPointerMove" : "pointermove", _e = We.msPointer ? "MSPointerUp" : "pointerup", ke = We.msPointer ? "MSPointerCancel" : "pointercancel", Be = {
      touchstart: Ra,
      touchmove: U,
      touchend: _e,
      touchcancel: ke
    }, Ut = {
      touchstart: cn,
      touchmove: No,
      touchend: No,
      touchcancel: No
    }, $t = {}, jt = !1;
    function mt(r, u, h) {
      return u === "touchstart" && Ja(), Ut[u] ? (h = Ut[u].bind(this, h), r.addEventListener(Be[u], h, !1), h) : (console.warn("wrong event specified:", u), H);
    }
    function wr(r, u, h) {
      if (!Be[u]) {
        console.warn("wrong event specified:", u);
        return;
      }
      r.removeEventListener(Be[u], h, !1);
    }
    function Yn(r) {
      $t[r.pointerId] = r;
    }
    function Vn(r) {
      $t[r.pointerId] && ($t[r.pointerId] = r);
    }
    function Ur(r) {
      delete $t[r.pointerId];
    }
    function Ja() {
      jt || (document.addEventListener(Ra, Yn, !0), document.addEventListener(U, Vn, !0), document.addEventListener(_e, Ur, !0), document.addEventListener(ke, Ur, !0), jt = !0);
    }
    function No(r, u) {
      if (u.pointerType !== (u.MSPOINTER_TYPE_MOUSE || "mouse")) {
        u.touches = [];
        for (var h in $t)
          u.touches.push($t[h]);
        u.changedTouches = [u], r(u);
      }
    }
    function cn(r, u) {
      u.MSPOINTER_TYPE_TOUCH && u.pointerType === u.MSPOINTER_TYPE_TOUCH && Dn(u), No(r, u);
    }
    function yf(r) {
      var u = {}, h, y;
      for (y in r)
        h = r[y], u[y] = h && h.bind ? h.bind(r) : h;
      return r = u, u.type = "dblclick", u.detail = 2, u.isTrusted = !1, u._simulated = !0, u;
    }
    var Da = 200;
    function Gt(r, u) {
      r.addEventListener("dblclick", u);
      var h = 0, y;
      function T(D) {
        if (D.detail !== 1) {
          y = D.detail;
          return;
        }
        if (!(D.pointerType === "mouse" || D.sourceCapabilities && !D.sourceCapabilities.firesTouchEvents)) {
          var I = Ho(D);
          if (!(I.some(function(ie) {
            return ie instanceof HTMLLabelElement && ie.attributes.for;
          }) && !I.some(function(ie) {
            return ie instanceof HTMLInputElement || ie instanceof HTMLSelectElement;
          }))) {
            var Q = Date.now();
            Q - h <= Da ? (y++, y === 2 && u(yf(D))) : y = 1, h = Q;
          }
        }
      }
      return r.addEventListener("click", T), {
        dblclick: u,
        simDblclick: T
      };
    }
    function eo(r, u) {
      r.removeEventListener("dblclick", u.dblclick), r.removeEventListener("click", u.simDblclick);
    }
    var to = Uo(
      ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
    ), no = Uo(
      ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
    ), Po = no === "webkitTransition" || no === "OTransition" ? no + "End" : "transitionend";
    function di(r) {
      return typeof r == "string" ? document.getElementById(r) : r;
    }
    function Ao(r, u) {
      var h = r.style[u] || r.currentStyle && r.currentStyle[u];
      if ((!h || h === "auto") && document.defaultView) {
        var y = document.defaultView.getComputedStyle(r, null);
        h = y ? y[u] : null;
      }
      return h === "auto" ? null : h;
    }
    function Pt(r, u, h) {
      var y = document.createElement(r);
      return y.className = u || "", h && h.appendChild(y), y;
    }
    function In(r) {
      var u = r.parentNode;
      u && u.removeChild(r);
    }
    function rs(r) {
      for (; r.firstChild; )
        r.removeChild(r.firstChild);
    }
    function zo(r) {
      var u = r.parentNode;
      u && u.lastChild !== r && u.appendChild(r);
    }
    function ka(r) {
      var u = r.parentNode;
      u && u.firstChild !== r && u.insertBefore(r, u.firstChild);
    }
    function ro(r, u) {
      if (r.classList !== void 0)
        return r.classList.contains(u);
      var h = Oa(r);
      return h.length > 0 && new RegExp("(^|\\s)" + u + "(\\s|$)").test(h);
    }
    function xt(r, u) {
      if (r.classList !== void 0)
        for (var h = oe(u), y = 0, T = h.length; y < T; y++)
          r.classList.add(h[y]);
      else if (!ro(r, u)) {
        var D = Oa(r);
        io(r, (D ? D + " " : "") + u);
      }
    }
    function sn(r, u) {
      r.classList !== void 0 ? r.classList.remove(u) : io(r, J((" " + Oa(r) + " ").replace(" " + u + " ", " ")));
    }
    function io(r, u) {
      r.className.baseVal === void 0 ? r.className = u : r.className.baseVal = u;
    }
    function Oa(r) {
      return r.correspondingElement && (r = r.correspondingElement), r.className.baseVal === void 0 ? r.className : r.className.baseVal;
    }
    function kr(r, u) {
      "opacity" in r.style ? r.style.opacity = u : "filter" in r.style && pu(r, u);
    }
    function pu(r, u) {
      var h = !1, y = "DXImageTransform.Microsoft.Alpha";
      try {
        h = r.filters.item(y);
      } catch {
        if (u === 1)
          return;
      }
      u = Math.round(u * 100), h ? (h.Enabled = u !== 100, h.Opacity = u) : r.style.filter += " progid:" + y + "(opacity=" + u + ")";
    }
    function Uo(r) {
      for (var u = document.documentElement.style, h = 0; h < r.length; h++)
        if (r[h] in u)
          return r[h];
      return !1;
    }
    function hi(r, u, h) {
      var y = u || new le(0, 0);
      r.style[to] = (We.ie3d ? "translate(" + y.x + "px," + y.y + "px)" : "translate3d(" + y.x + "px," + y.y + "px,0)") + (h ? " scale(" + h + ")" : "");
    }
    function lr(r, u) {
      r._leaflet_pos = u, We.any3d ? hi(r, u) : (r.style.left = u.x + "px", r.style.top = u.y + "px");
    }
    function ni(r) {
      return r._leaflet_pos || new le(0, 0);
    }
    var nn, ao, Io;
    if ("onselectstart" in document)
      nn = function() {
        nt(window, "selectstart", Dn);
      }, ao = function() {
        Mn(window, "selectstart", Dn);
      };
    else {
      var oo = Uo(
        ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
      );
      nn = function() {
        if (oo) {
          var r = document.documentElement.style;
          Io = r[oo], r[oo] = "none";
        }
      }, ao = function() {
        oo && (document.documentElement.style[oo] = Io, Io = void 0);
      };
    }
    function rn() {
      nt(window, "dragstart", Dn);
    }
    function is() {
      Mn(window, "dragstart", Dn);
    }
    var jo, Ot;
    function Fo(r) {
      for (; r.tabIndex === -1; )
        r = r.parentNode;
      r.style && (Wn(), jo = r, Ot = r.style.outlineStyle, r.style.outlineStyle = "none", nt(window, "keydown", Wn));
    }
    function Wn() {
      jo && (jo.style.outlineStyle = Ot, jo = void 0, Ot = void 0, Mn(window, "keydown", Wn));
    }
    function pi(r) {
      do
        r = r.parentNode;
      while ((!r.offsetWidth || !r.offsetHeight) && r !== document.body);
      return r;
    }
    function Vr(r) {
      var u = r.getBoundingClientRect();
      return {
        x: u.width / r.offsetWidth || 1,
        y: u.height / r.offsetHeight || 1,
        boundingClientRect: u
      };
    }
    var as = {
      __proto__: null,
      TRANSFORM: to,
      TRANSITION: no,
      TRANSITION_END: Po,
      get: di,
      getStyle: Ao,
      create: Pt,
      remove: In,
      empty: rs,
      toFront: zo,
      toBack: ka,
      hasClass: ro,
      addClass: xt,
      removeClass: sn,
      setClass: io,
      getClass: Oa,
      setOpacity: kr,
      testProp: Uo,
      setTransform: hi,
      setPosition: lr,
      getPosition: ni,
      get disableTextSelection() {
        return nn;
      },
      get enableTextSelection() {
        return ao;
      },
      disableImageDrag: rn,
      enableImageDrag: is,
      preventOutline: Fo,
      restoreOutline: Wn,
      getSizedParentNode: pi,
      getScale: Vr
    };
    function nt(r, u, h, y) {
      if (u && typeof u == "object")
        for (var T in u)
          aa(r, T, u[T], h);
      else {
        u = oe(u);
        for (var D = 0, I = u.length; D < I; D++)
          aa(r, u[D], h, y);
      }
      return this;
    }
    var Qt = "_leaflet_events";
    function Mn(r, u, h, y) {
      if (arguments.length === 1)
        vi(r), delete r[Qt];
      else if (u && typeof u == "object")
        for (var T in u)
          vu(r, T, u[T], h);
      else if (u = oe(u), arguments.length === 2)
        vi(r, function(Q) {
          return ye(u, Q) !== -1;
        });
      else
        for (var D = 0, I = u.length; D < I; D++)
          vu(r, u[D], h, y);
      return this;
    }
    function vi(r, u) {
      for (var h in r[Qt]) {
        var y = h.split(/\d/)[0];
        (!u || u(y)) && vu(r, y, null, null, h);
      }
    }
    var Er = {
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      wheel: !("onwheel" in window) && "mousewheel"
    };
    function aa(r, u, h, y) {
      var T = u + z(h) + (y ? "_" + z(y) : "");
      if (r[Qt] && r[Qt][T])
        return this;
      var D = function(Q) {
        return h.call(y || r, Q || window.event);
      }, I = D;
      !We.touchNative && We.pointer && u.indexOf("touch") === 0 ? D = mt(r, u, D) : We.touch && u === "dblclick" ? D = Gt(r, D) : "addEventListener" in r ? u === "touchstart" || u === "touchmove" || u === "wheel" || u === "mousewheel" ? r.addEventListener(Er[u] || u, D, We.passiveEvents ? { passive: !1 } : !1) : u === "mouseenter" || u === "mouseleave" ? (D = function(Q) {
        Q = Q || window.event, uo(r, Q) && I(Q);
      }, r.addEventListener(Er[u], D, !1)) : r.addEventListener(u, I, !1) : r.attachEvent("on" + u, D), r[Qt] = r[Qt] || {}, r[Qt][T] = D;
    }
    function vu(r, u, h, y, T) {
      T = T || u + z(h) + (y ? "_" + z(y) : "");
      var D = r[Qt] && r[Qt][T];
      if (!D)
        return this;
      !We.touchNative && We.pointer && u.indexOf("touch") === 0 ? wr(r, u, D) : We.touch && u === "dblclick" ? eo(r, D) : "removeEventListener" in r ? r.removeEventListener(Er[u] || u, D, !1) : r.detachEvent("on" + u, D), r[Qt][T] = null;
    }
    function mi(r) {
      return r.stopPropagation ? r.stopPropagation() : r.originalEvent ? r.originalEvent._stopped = !0 : r.cancelBubble = !0, this;
    }
    function so(r) {
      return aa(r, "wheel", mi), this;
    }
    function os(r) {
      return nt(r, "mousedown touchstart dblclick contextmenu", mi), r._leaflet_disable_click = !0, this;
    }
    function Dn(r) {
      return r.preventDefault ? r.preventDefault() : r.returnValue = !1, this;
    }
    function Li(r) {
      return Dn(r), mi(r), this;
    }
    function Ho(r) {
      if (r.composedPath)
        return r.composedPath();
      for (var u = [], h = r.target; h; )
        u.push(h), h = h.parentNode;
      return u;
    }
    function Zi(r, u) {
      if (!u)
        return new le(r.clientX, r.clientY);
      var h = Vr(u), y = h.boundingClientRect;
      return new le(
        // offset.left/top values are in page scale (like clientX/Y),
        // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
        (r.clientX - y.left) / h.x - u.clientLeft,
        (r.clientY - y.top) / h.y - u.clientTop
      );
    }
    var mu = We.linux && We.chrome ? window.devicePixelRatio : We.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
    function Bo(r) {
      return We.edge ? r.wheelDeltaY / 2 : (
        // Don't trust window-geometry-based delta
        r.deltaY && r.deltaMode === 0 ? -r.deltaY / mu : (
          // Pixels
          r.deltaY && r.deltaMode === 1 ? -r.deltaY * 20 : (
            // Lines
            r.deltaY && r.deltaMode === 2 ? -r.deltaY * 60 : (
              // Pages
              r.deltaX || r.deltaZ ? 0 : (
                // Skip horizontal/depth wheel events
                r.wheelDelta ? (r.wheelDeltaY || r.wheelDelta) / 2 : (
                  // Legacy IE pixels
                  r.detail && Math.abs(r.detail) < 32765 ? -r.detail * 20 : (
                    // Legacy Moz lines
                    r.detail ? r.detail / -32765 * 60 : (
                      // Legacy Moz pages
                      0
                    )
                  )
                )
              )
            )
          )
        )
      );
    }
    function uo(r, u) {
      var h = u.relatedTarget;
      if (!h)
        return !0;
      try {
        for (; h && h !== r; )
          h = h.parentNode;
      } catch {
        return !1;
      }
      return h !== r;
    }
    var Ns = {
      __proto__: null,
      on: nt,
      off: Mn,
      stopPropagation: mi,
      disableScrollPropagation: so,
      disableClickPropagation: os,
      preventDefault: Dn,
      stop: Li,
      getPropagationPath: Ho,
      getMousePosition: Zi,
      getWheelDelta: Bo,
      isExternalTarget: uo,
      addListener: nt,
      removeListener: Mn
    }, Ps = Ne.extend({
      // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
      // Run an animation of a given element to a new position, optionally setting
      // duration in seconds (`0.25` by default) and easing linearity factor (3rd
      // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
      // `0.5` by default).
      run: function(r, u, h, y) {
        this.stop(), this._el = r, this._inProgress = !0, this._duration = h || 0.25, this._easeOutPower = 1 / Math.max(y || 0.5, 0.2), this._startPos = ni(r), this._offset = u.subtract(this._startPos), this._startTime = +/* @__PURE__ */ new Date(), this.fire("start"), this._animate();
      },
      // @method stop()
      // Stops the animation (if currently running).
      stop: function() {
        this._inProgress && (this._step(!0), this._complete());
      },
      _animate: function() {
        this._animId = Xe(this._animate, this), this._step();
      },
      _step: function(r) {
        var u = +/* @__PURE__ */ new Date() - this._startTime, h = this._duration * 1e3;
        u < h ? this._runFrame(this._easeOut(u / h), r) : (this._runFrame(1), this._complete());
      },
      _runFrame: function(r, u) {
        var h = this._startPos.add(this._offset.multiplyBy(r));
        u && h._round(), lr(this._el, h), this.fire("step");
      },
      _complete: function() {
        Mt(this._animId), this._inProgress = !1, this.fire("end");
      },
      _easeOut: function(r) {
        return 1 - Math.pow(1 - r, this._easeOutPower);
      }
    }), Kt = Ne.extend({
      options: {
        // @section Map State Options
        // @option crs: CRS = L.CRS.EPSG3857
        // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
        // sure what it means.
        crs: yn,
        // @option center: LatLng = undefined
        // Initial geographic center of the map
        center: void 0,
        // @option zoom: Number = undefined
        // Initial map zoom level
        zoom: void 0,
        // @option minZoom: Number = *
        // Minimum zoom level of the map.
        // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
        // the lowest of their `minZoom` options will be used instead.
        minZoom: void 0,
        // @option maxZoom: Number = *
        // Maximum zoom level of the map.
        // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
        // the highest of their `maxZoom` options will be used instead.
        maxZoom: void 0,
        // @option layers: Layer[] = []
        // Array of layers that will be added to the map initially
        layers: [],
        // @option maxBounds: LatLngBounds = null
        // When this option is set, the map restricts the view to the given
        // geographical bounds, bouncing the user back if the user tries to pan
        // outside the view. To set the restriction dynamically, use
        // [`setMaxBounds`](#map-setmaxbounds) method.
        maxBounds: void 0,
        // @option renderer: Renderer = *
        // The default method for drawing vector layers on the map. `L.SVG`
        // or `L.Canvas` by default depending on browser support.
        renderer: void 0,
        // @section Animation Options
        // @option zoomAnimation: Boolean = true
        // Whether the map zoom animation is enabled. By default it's enabled
        // in all browsers that support CSS3 Transitions except Android.
        zoomAnimation: !0,
        // @option zoomAnimationThreshold: Number = 4
        // Won't animate zoom if the zoom difference exceeds this value.
        zoomAnimationThreshold: 4,
        // @option fadeAnimation: Boolean = true
        // Whether the tile fade animation is enabled. By default it's enabled
        // in all browsers that support CSS3 Transitions except Android.
        fadeAnimation: !0,
        // @option markerZoomAnimation: Boolean = true
        // Whether markers animate their zoom with the zoom animation, if disabled
        // they will disappear for the length of the animation. By default it's
        // enabled in all browsers that support CSS3 Transitions except Android.
        markerZoomAnimation: !0,
        // @option transform3DLimit: Number = 2^23
        // Defines the maximum size of a CSS translation transform. The default
        // value should not be changed unless a web browser positions layers in
        // the wrong place after doing a large `panBy`.
        transform3DLimit: 8388608,
        // Precision limit of a 32-bit float
        // @section Interaction Options
        // @option zoomSnap: Number = 1
        // Forces the map's zoom level to always be a multiple of this, particularly
        // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
        // By default, the zoom level snaps to the nearest integer; lower values
        // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
        // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
        zoomSnap: 1,
        // @option zoomDelta: Number = 1
        // Controls how much the map's zoom level will change after a
        // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
        // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
        // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
        zoomDelta: 1,
        // @option trackResize: Boolean = true
        // Whether the map automatically handles browser window resize to update itself.
        trackResize: !0
      },
      initialize: function(r, u) {
        u = ce(this, u), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this._initContainer(r), this._initLayout(), this._onResize = C(this._onResize, this), this._initEvents(), u.maxBounds && this.setMaxBounds(u.maxBounds), u.zoom !== void 0 && (this._zoom = this._limitZoom(u.zoom)), u.center && u.zoom !== void 0 && this.setView(Oe(u.center), u.zoom, { reset: !0 }), this.callInitHooks(), this._zoomAnimated = no && We.any3d && !We.mobileOpera && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), nt(this._proxy, Po, this._catchTransitionEnd, this)), this._addLayers(this.options.layers);
      },
      // @section Methods for modifying map state
      // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
      // Sets the view of the map (geographical center and zoom) with the given
      // animation options.
      setView: function(r, u, h) {
        if (u = u === void 0 ? this._zoom : this._limitZoom(u), r = this._limitCenter(Oe(r), u, this.options.maxBounds), h = h || {}, this._stop(), this._loaded && !h.reset && h !== !0) {
          h.animate !== void 0 && (h.zoom = w({ animate: h.animate }, h.zoom), h.pan = w({ animate: h.animate, duration: h.duration }, h.pan));
          var y = this._zoom !== u ? this._tryAnimatedZoom && this._tryAnimatedZoom(r, u, h.zoom) : this._tryAnimatedPan(r, h.pan);
          if (y)
            return clearTimeout(this._sizeTimer), this;
        }
        return this._resetView(r, u, h.pan && h.pan.noMoveStart), this;
      },
      // @method setZoom(zoom: Number, options?: Zoom/pan options): this
      // Sets the zoom of the map.
      setZoom: function(r, u) {
        return this._loaded ? this.setView(this.getCenter(), r, { zoom: u }) : (this._zoom = r, this);
      },
      // @method zoomIn(delta?: Number, options?: Zoom options): this
      // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
      zoomIn: function(r, u) {
        return r = r || (We.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom + r, u);
      },
      // @method zoomOut(delta?: Number, options?: Zoom options): this
      // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
      zoomOut: function(r, u) {
        return r = r || (We.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom - r, u);
      },
      // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
      // Zooms the map while keeping a specified geographical point on the map
      // stationary (e.g. used internally for scroll zoom and double-click zoom).
      // @alternative
      // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
      // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
      setZoomAround: function(r, u, h) {
        var y = this.getZoomScale(u), T = this.getSize().divideBy(2), D = r instanceof le ? r : this.latLngToContainerPoint(r), I = D.subtract(T).multiplyBy(1 - 1 / y), Q = this.containerPointToLatLng(T.add(I));
        return this.setView(Q, u, { zoom: h });
      },
      _getBoundsCenterZoom: function(r, u) {
        u = u || {}, r = r.getBounds ? r.getBounds() : je(r);
        var h = N(u.paddingTopLeft || u.padding || [0, 0]), y = N(u.paddingBottomRight || u.padding || [0, 0]), T = this.getBoundsZoom(r, !1, h.add(y));
        if (T = typeof u.maxZoom == "number" ? Math.min(u.maxZoom, T) : T, T === 1 / 0)
          return {
            center: r.getCenter(),
            zoom: T
          };
        var D = y.subtract(h).divideBy(2), I = this.project(r.getSouthWest(), T), Q = this.project(r.getNorthEast(), T), ie = this.unproject(I.add(Q).divideBy(2).add(D), T);
        return {
          center: ie,
          zoom: T
        };
      },
      // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
      // Sets a map view that contains the given geographical bounds with the
      // maximum zoom level possible.
      fitBounds: function(r, u) {
        if (r = je(r), !r.isValid())
          throw new Error("Bounds are not valid.");
        var h = this._getBoundsCenterZoom(r, u);
        return this.setView(h.center, h.zoom, u);
      },
      // @method fitWorld(options?: fitBounds options): this
      // Sets a map view that mostly contains the whole world with the maximum
      // zoom level possible.
      fitWorld: function(r) {
        return this.fitBounds([[-90, -180], [90, 180]], r);
      },
      // @method panTo(latlng: LatLng, options?: Pan options): this
      // Pans the map to a given center.
      panTo: function(r, u) {
        return this.setView(r, this._zoom, { pan: u });
      },
      // @method panBy(offset: Point, options?: Pan options): this
      // Pans the map by a given number of pixels (animated).
      panBy: function(r, u) {
        if (r = N(r).round(), u = u || {}, !r.x && !r.y)
          return this.fire("moveend");
        if (u.animate !== !0 && !this.getSize().contains(r))
          return this._resetView(this.unproject(this.project(this.getCenter()).add(r)), this.getZoom()), this;
        if (this._panAnim || (this._panAnim = new Ps(), this._panAnim.on({
          step: this._onPanTransitionStep,
          end: this._onPanTransitionEnd
        }, this)), u.noMoveStart || this.fire("movestart"), u.animate !== !1) {
          xt(this._mapPane, "leaflet-pan-anim");
          var h = this._getMapPanePos().subtract(r).round();
          this._panAnim.run(this._mapPane, h, u.duration || 0.25, u.easeLinearity);
        } else
          this._rawPanBy(r), this.fire("move").fire("moveend");
        return this;
      },
      // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
      // Sets the view of the map (geographical center and zoom) performing a smooth
      // pan-zoom animation.
      flyTo: function(r, u, h) {
        if (h = h || {}, h.animate === !1 || !We.any3d)
          return this.setView(r, u, h);
        this._stop();
        var y = this.project(this.getCenter()), T = this.project(r), D = this.getSize(), I = this._zoom;
        r = Oe(r), u = u === void 0 ? I : u;
        var Q = Math.max(D.x, D.y), ie = Q * this.getZoomScale(I, u), ge = T.distanceTo(y) || 1, Fe = 1.42, ht = Fe * Fe;
        function Vt(On) {
          var bu = On ? -1 : 1, Sp = On ? ie : Q, Mf = ie * ie - Q * Q + bu * ht * ht * ge * ge, ca = 2 * Sp * ht * ge, Hs = Mf / ca, Bs = Math.sqrt(Hs * Hs + 1) - Hs, pt = Bs < 1e-9 ? -18 : Math.log(Bs);
          return pt;
        }
        function hr(On) {
          return (Math.exp(On) - Math.exp(-On)) / 2;
        }
        function Lr(On) {
          return (Math.exp(On) + Math.exp(-On)) / 2;
        }
        function Pi(On) {
          return hr(On) / Lr(On);
        }
        var ii = Vt(0);
        function xu(On) {
          return Q * (Lr(ii) / Lr(ii + Fe * On));
        }
        function ps(On) {
          return Q * (Lr(ii) * Pi(ii + Fe * On) - hr(ii)) / ht;
        }
        function Ua(On) {
          return 1 - Math.pow(1 - On, 1.5);
        }
        var yl = Date.now(), $o = (Vt(1) - ii) / Fe, ho = h.duration ? 1e3 * h.duration : 1e3 * $o * 0.8;
        function vs() {
          var On = (Date.now() - yl) / ho, bu = Ua(On) * $o;
          On <= 1 ? (this._flyToFrame = Xe(vs, this), this._move(
            this.unproject(y.add(T.subtract(y).multiplyBy(ps(bu) / ge)), I),
            this.getScaleZoom(Q / xu(bu), I),
            { flyTo: !0 }
          )) : this._move(r, u)._moveEnd(!0);
        }
        return this._moveStart(!0, h.noMoveStart), vs.call(this), this;
      },
      // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
      // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
      // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
      flyToBounds: function(r, u) {
        var h = this._getBoundsCenterZoom(r, u);
        return this.flyTo(h.center, h.zoom, u);
      },
      // @method setMaxBounds(bounds: LatLngBounds): this
      // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
      setMaxBounds: function(r) {
        return r = je(r), this.listens("moveend", this._panInsideMaxBounds) && this.off("moveend", this._panInsideMaxBounds), r.isValid() ? (this.options.maxBounds = r, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this);
      },
      // @method setMinZoom(zoom: Number): this
      // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
      setMinZoom: function(r) {
        var u = this.options.minZoom;
        return this.options.minZoom = r, this._loaded && u !== r && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(r) : this;
      },
      // @method setMaxZoom(zoom: Number): this
      // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
      setMaxZoom: function(r) {
        var u = this.options.maxZoom;
        return this.options.maxZoom = r, this._loaded && u !== r && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(r) : this;
      },
      // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
      // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
      panInsideBounds: function(r, u) {
        this._enforcingBounds = !0;
        var h = this.getCenter(), y = this._limitCenter(h, this._zoom, je(r));
        return h.equals(y) || this.panTo(y, u), this._enforcingBounds = !1, this;
      },
      // @method panInside(latlng: LatLng, options?: padding options): this
      // Pans the map the minimum amount to make the `latlng` visible. Use
      // padding options to fit the display to more restricted bounds.
      // If `latlng` is already within the (optionally padded) display bounds,
      // the map will not be panned.
      panInside: function(r, u) {
        u = u || {};
        var h = N(u.paddingTopLeft || u.padding || [0, 0]), y = N(u.paddingBottomRight || u.padding || [0, 0]), T = this.project(this.getCenter()), D = this.project(r), I = this.getPixelBounds(), Q = xe([I.min.add(h), I.max.subtract(y)]), ie = Q.getSize();
        if (!Q.contains(D)) {
          this._enforcingBounds = !0;
          var ge = D.subtract(Q.getCenter()), Fe = Q.extend(D).getSize().subtract(ie);
          T.x += ge.x < 0 ? -Fe.x : Fe.x, T.y += ge.y < 0 ? -Fe.y : Fe.y, this.panTo(this.unproject(T), u), this._enforcingBounds = !1;
        }
        return this;
      },
      // @method invalidateSize(options: Zoom/pan options): this
      // Checks if the map container size changed and updates the map if so 
      // call it after you've changed the map size dynamically, also animating
      // pan by default. If `options.pan` is `false`, panning will not occur.
      // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
      // that it doesn't happen often even if the method is called many
      // times in a row.
      // @alternative
      // @method invalidateSize(animate: Boolean): this
      // Checks if the map container size changed and updates the map if so 
      // call it after you've changed the map size dynamically, also animating
      // pan by default.
      invalidateSize: function(r) {
        if (!this._loaded)
          return this;
        r = w({
          animate: !1,
          pan: !0
        }, r === !0 ? { animate: !0 } : r);
        var u = this.getSize();
        this._sizeChanged = !0, this._lastCenter = null;
        var h = this.getSize(), y = u.divideBy(2).round(), T = h.divideBy(2).round(), D = y.subtract(T);
        return !D.x && !D.y ? this : (r.animate && r.pan ? this.panBy(D) : (r.pan && this._rawPanBy(D), this.fire("move"), r.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(C(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {
          oldSize: u,
          newSize: h
        }));
      },
      // @section Methods for modifying map state
      // @method stop(): this
      // Stops the currently running `panTo` or `flyTo` animation, if any.
      stop: function() {
        return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), this._stop();
      },
      // @section Geolocation methods
      // @method locate(options?: Locate options): this
      // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
      // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
      // and optionally sets the map view to the user's location with respect to
      // detection accuracy (or to the world view if geolocation failed).
      // Note that, if your page doesn't use HTTPS, this method will fail in
      // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
      // See `Locate options` for more details.
      locate: function(r) {
        if (r = this._locateOptions = w({
          timeout: 1e4,
          watch: !1
          // setView: false
          // maxZoom: <Number>
          // maximumAge: 0
          // enableHighAccuracy: false
        }, r), !("geolocation" in navigator))
          return this._handleGeolocationError({
            code: 0,
            message: "Geolocation not supported."
          }), this;
        var u = C(this._handleGeolocationResponse, this), h = C(this._handleGeolocationError, this);
        return r.watch ? this._locationWatchId = navigator.geolocation.watchPosition(u, h, r) : navigator.geolocation.getCurrentPosition(u, h, r), this;
      },
      // @method stopLocate(): this
      // Stops watching location previously initiated by `map.locate({watch: true})`
      // and aborts resetting the map view if map.locate was called with
      // `{setView: true}`.
      stopLocate: function() {
        return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this;
      },
      _handleGeolocationError: function(r) {
        if (this._container._leaflet_id) {
          var u = r.code, h = r.message || (u === 1 ? "permission denied" : u === 2 ? "position unavailable" : "timeout");
          this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {
            code: u,
            message: "Geolocation error: " + h + "."
          });
        }
      },
      _handleGeolocationResponse: function(r) {
        if (this._container._leaflet_id) {
          var u = r.coords.latitude, h = r.coords.longitude, y = new qe(u, h), T = y.toBounds(r.coords.accuracy * 2), D = this._locateOptions;
          if (D.setView) {
            var I = this.getBoundsZoom(T);
            this.setView(y, D.maxZoom ? Math.min(I, D.maxZoom) : I);
          }
          var Q = {
            latlng: y,
            bounds: T,
            timestamp: r.timestamp
          };
          for (var ie in r.coords)
            typeof r.coords[ie] == "number" && (Q[ie] = r.coords[ie]);
          this.fire("locationfound", Q);
        }
      },
      // TODO Appropriate docs section?
      // @section Other Methods
      // @method addHandler(name: String, HandlerClass: Function): this
      // Adds a new `Handler` to the map, given its name and constructor function.
      addHandler: function(r, u) {
        if (!u)
          return this;
        var h = this[r] = new u(this);
        return this._handlers.push(h), this.options[r] && h.enable(), this;
      },
      // @method remove(): this
      // Destroys the map and clears all related event listeners.
      remove: function() {
        if (this._initEvents(!0), this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this._containerId !== this._container._leaflet_id)
          throw new Error("Map container is being reused by another instance");
        try {
          delete this._container._leaflet_id, delete this._containerId;
        } catch {
          this._container._leaflet_id = void 0, this._containerId = void 0;
        }
        this._locationWatchId !== void 0 && this.stopLocate(), this._stop(), In(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (Mt(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload");
        var r;
        for (r in this._layers)
          this._layers[r].remove();
        for (r in this._panes)
          In(this._panes[r]);
        return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this;
      },
      // @section Other Methods
      // @method createPane(name: String, container?: HTMLElement): HTMLElement
      // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
      // then returns it. The pane is created as a child of `container`, or
      // as a child of the main map pane if not set.
      createPane: function(r, u) {
        var h = "leaflet-pane" + (r ? " leaflet-" + r.replace("Pane", "") + "-pane" : ""), y = Pt("div", h, u || this._mapPane);
        return r && (this._panes[r] = y), y;
      },
      // @section Methods for Getting Map State
      // @method getCenter(): LatLng
      // Returns the geographical center of the map view
      getCenter: function() {
        return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter.clone() : this.layerPointToLatLng(this._getCenterLayerPoint());
      },
      // @method getZoom(): Number
      // Returns the current zoom level of the map view
      getZoom: function() {
        return this._zoom;
      },
      // @method getBounds(): LatLngBounds
      // Returns the geographical bounds visible in the current map view
      getBounds: function() {
        var r = this.getPixelBounds(), u = this.unproject(r.getBottomLeft()), h = this.unproject(r.getTopRight());
        return new et(u, h);
      },
      // @method getMinZoom(): Number
      // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
      getMinZoom: function() {
        return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
      },
      // @method getMaxZoom(): Number
      // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
      getMaxZoom: function() {
        return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom;
      },
      // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
      // Returns the maximum zoom level on which the given bounds fit to the map
      // view in its entirety. If `inside` (optional) is set to `true`, the method
      // instead returns the minimum zoom level on which the map view fits into
      // the given bounds in its entirety.
      getBoundsZoom: function(r, u, h) {
        r = je(r), h = N(h || [0, 0]);
        var y = this.getZoom() || 0, T = this.getMinZoom(), D = this.getMaxZoom(), I = r.getNorthWest(), Q = r.getSouthEast(), ie = this.getSize().subtract(h), ge = xe(this.project(Q, y), this.project(I, y)).getSize(), Fe = We.any3d ? this.options.zoomSnap : 1, ht = ie.x / ge.x, Vt = ie.y / ge.y, hr = u ? Math.max(ht, Vt) : Math.min(ht, Vt);
        return y = this.getScaleZoom(hr, y), Fe && (y = Math.round(y / (Fe / 100)) * (Fe / 100), y = u ? Math.ceil(y / Fe) * Fe : Math.floor(y / Fe) * Fe), Math.max(T, Math.min(D, y));
      },
      // @method getSize(): Point
      // Returns the current size of the map container (in pixels).
      getSize: function() {
        return (!this._size || this._sizeChanged) && (this._size = new le(
          this._container.clientWidth || 0,
          this._container.clientHeight || 0
        ), this._sizeChanged = !1), this._size.clone();
      },
      // @method getPixelBounds(): Bounds
      // Returns the bounds of the current map view in projected pixel
      // coordinates (sometimes useful in layer and overlay implementations).
      getPixelBounds: function(r, u) {
        var h = this._getTopLeftPoint(r, u);
        return new se(h, h.add(this.getSize()));
      },
      // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
      // the map pane? "left point of the map layer" can be confusing, specially
      // since there can be negative offsets.
      // @method getPixelOrigin(): Point
      // Returns the projected pixel coordinates of the top left point of
      // the map layer (useful in custom layer and overlay implementations).
      getPixelOrigin: function() {
        return this._checkIfLoaded(), this._pixelOrigin;
      },
      // @method getPixelWorldBounds(zoom?: Number): Bounds
      // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
      // If `zoom` is omitted, the map's current zoom level is used.
      getPixelWorldBounds: function(r) {
        return this.options.crs.getProjectedBounds(r === void 0 ? this.getZoom() : r);
      },
      // @section Other Methods
      // @method getPane(pane: String|HTMLElement): HTMLElement
      // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
      getPane: function(r) {
        return typeof r == "string" ? this._panes[r] : r;
      },
      // @method getPanes(): Object
      // Returns a plain object containing the names of all [panes](#map-pane) as keys and
      // the panes as values.
      getPanes: function() {
        return this._panes;
      },
      // @method getContainer: HTMLElement
      // Returns the HTML element that contains the map.
      getContainer: function() {
        return this._container;
      },
      // @section Conversion Methods
      // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
      // Returns the scale factor to be applied to a map transition from zoom level
      // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
      getZoomScale: function(r, u) {
        var h = this.options.crs;
        return u = u === void 0 ? this._zoom : u, h.scale(r) / h.scale(u);
      },
      // @method getScaleZoom(scale: Number, fromZoom: Number): Number
      // Returns the zoom level that the map would end up at, if it is at `fromZoom`
      // level and everything is scaled by a factor of `scale`. Inverse of
      // [`getZoomScale`](#map-getZoomScale).
      getScaleZoom: function(r, u) {
        var h = this.options.crs;
        u = u === void 0 ? this._zoom : u;
        var y = h.zoom(r * h.scale(u));
        return isNaN(y) ? 1 / 0 : y;
      },
      // @method project(latlng: LatLng, zoom: Number): Point
      // Projects a geographical coordinate `LatLng` according to the projection
      // of the map's CRS, then scales it according to `zoom` and the CRS's
      // `Transformation`. The result is pixel coordinate relative to
      // the CRS origin.
      project: function(r, u) {
        return u = u === void 0 ? this._zoom : u, this.options.crs.latLngToPoint(Oe(r), u);
      },
      // @method unproject(point: Point, zoom: Number): LatLng
      // Inverse of [`project`](#map-project).
      unproject: function(r, u) {
        return u = u === void 0 ? this._zoom : u, this.options.crs.pointToLatLng(N(r), u);
      },
      // @method layerPointToLatLng(point: Point): LatLng
      // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
      // returns the corresponding geographical coordinate (for the current zoom level).
      layerPointToLatLng: function(r) {
        var u = N(r).add(this.getPixelOrigin());
        return this.unproject(u);
      },
      // @method latLngToLayerPoint(latlng: LatLng): Point
      // Given a geographical coordinate, returns the corresponding pixel coordinate
      // relative to the [origin pixel](#map-getpixelorigin).
      latLngToLayerPoint: function(r) {
        var u = this.project(Oe(r))._round();
        return u._subtract(this.getPixelOrigin());
      },
      // @method wrapLatLng(latlng: LatLng): LatLng
      // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
      // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
      // CRS's bounds.
      // By default this means longitude is wrapped around the dateline so its
      // value is between -180 and +180 degrees.
      wrapLatLng: function(r) {
        return this.options.crs.wrapLatLng(Oe(r));
      },
      // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
      // Returns a `LatLngBounds` with the same size as the given one, ensuring that
      // its center is within the CRS's bounds.
      // By default this means the center longitude is wrapped around the dateline so its
      // value is between -180 and +180 degrees, and the majority of the bounds
      // overlaps the CRS's bounds.
      wrapLatLngBounds: function(r) {
        return this.options.crs.wrapLatLngBounds(je(r));
      },
      // @method distance(latlng1: LatLng, latlng2: LatLng): Number
      // Returns the distance between two geographical coordinates according to
      // the map's CRS. By default this measures distance in meters.
      distance: function(r, u) {
        return this.options.crs.distance(Oe(r), Oe(u));
      },
      // @method containerPointToLayerPoint(point: Point): Point
      // Given a pixel coordinate relative to the map container, returns the corresponding
      // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
      containerPointToLayerPoint: function(r) {
        return N(r).subtract(this._getMapPanePos());
      },
      // @method layerPointToContainerPoint(point: Point): Point
      // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
      // returns the corresponding pixel coordinate relative to the map container.
      layerPointToContainerPoint: function(r) {
        return N(r).add(this._getMapPanePos());
      },
      // @method containerPointToLatLng(point: Point): LatLng
      // Given a pixel coordinate relative to the map container, returns
      // the corresponding geographical coordinate (for the current zoom level).
      containerPointToLatLng: function(r) {
        var u = this.containerPointToLayerPoint(N(r));
        return this.layerPointToLatLng(u);
      },
      // @method latLngToContainerPoint(latlng: LatLng): Point
      // Given a geographical coordinate, returns the corresponding pixel coordinate
      // relative to the map container.
      latLngToContainerPoint: function(r) {
        return this.layerPointToContainerPoint(this.latLngToLayerPoint(Oe(r)));
      },
      // @method mouseEventToContainerPoint(ev: MouseEvent): Point
      // Given a MouseEvent object, returns the pixel coordinate relative to the
      // map container where the event took place.
      mouseEventToContainerPoint: function(r) {
        return Zi(r, this._container);
      },
      // @method mouseEventToLayerPoint(ev: MouseEvent): Point
      // Given a MouseEvent object, returns the pixel coordinate relative to
      // the [origin pixel](#map-getpixelorigin) where the event took place.
      mouseEventToLayerPoint: function(r) {
        return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(r));
      },
      // @method mouseEventToLatLng(ev: MouseEvent): LatLng
      // Given a MouseEvent object, returns geographical coordinate where the
      // event took place.
      mouseEventToLatLng: function(r) {
        return this.layerPointToLatLng(this.mouseEventToLayerPoint(r));
      },
      // map initialization methods
      _initContainer: function(r) {
        var u = this._container = di(r);
        if (u) {
          if (u._leaflet_id)
            throw new Error("Map container is already initialized.");
        } else
          throw new Error("Map container not found.");
        nt(u, "scroll", this._onScroll, this), this._containerId = z(u);
      },
      _initLayout: function() {
        var r = this._container;
        this._fadeAnimated = this.options.fadeAnimation && We.any3d, xt(r, "leaflet-container" + (We.touch ? " leaflet-touch" : "") + (We.retina ? " leaflet-retina" : "") + (We.ielt9 ? " leaflet-oldie" : "") + (We.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
        var u = Ao(r, "position");
        u !== "absolute" && u !== "relative" && u !== "fixed" && u !== "sticky" && (r.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos();
      },
      _initPanes: function() {
        var r = this._panes = {};
        this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), lr(this._mapPane, new le(0, 0)), this.createPane("tilePane"), this.createPane("overlayPane"), this.createPane("shadowPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (xt(r.markerPane, "leaflet-zoom-hide"), xt(r.shadowPane, "leaflet-zoom-hide"));
      },
      // private methods that modify map state
      // @section Map state change events
      _resetView: function(r, u, h) {
        lr(this._mapPane, new le(0, 0));
        var y = !this._loaded;
        this._loaded = !0, u = this._limitZoom(u), this.fire("viewprereset");
        var T = this._zoom !== u;
        this._moveStart(T, h)._move(r, u)._moveEnd(T), this.fire("viewreset"), y && this.fire("load");
      },
      _moveStart: function(r, u) {
        return r && this.fire("zoomstart"), u || this.fire("movestart"), this;
      },
      _move: function(r, u, h, y) {
        u === void 0 && (u = this._zoom);
        var T = this._zoom !== u;
        return this._zoom = u, this._lastCenter = r, this._pixelOrigin = this._getNewPixelOrigin(r), y ? h && h.pinch && this.fire("zoom", h) : ((T || h && h.pinch) && this.fire("zoom", h), this.fire("move", h)), this;
      },
      _moveEnd: function(r) {
        return r && this.fire("zoomend"), this.fire("moveend");
      },
      _stop: function() {
        return Mt(this._flyToFrame), this._panAnim && this._panAnim.stop(), this;
      },
      _rawPanBy: function(r) {
        lr(this._mapPane, this._getMapPanePos().subtract(r));
      },
      _getZoomSpan: function() {
        return this.getMaxZoom() - this.getMinZoom();
      },
      _panInsideMaxBounds: function() {
        this._enforcingBounds || this.panInsideBounds(this.options.maxBounds);
      },
      _checkIfLoaded: function() {
        if (!this._loaded)
          throw new Error("Set map center and zoom first.");
      },
      // DOM event handling
      // @section Interaction events
      _initEvents: function(r) {
        this._targets = {}, this._targets[z(this._container)] = this;
        var u = r ? Mn : nt;
        u(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this), this.options.trackResize && u(window, "resize", this._onResize, this), We.any3d && this.options.transform3DLimit && (r ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
      },
      _onResize: function() {
        Mt(this._resizeRequest), this._resizeRequest = Xe(
          function() {
            this.invalidateSize({ debounceMoveend: !0 });
          },
          this
        );
      },
      _onScroll: function() {
        this._container.scrollTop = 0, this._container.scrollLeft = 0;
      },
      _onMoveEnd: function() {
        var r = this._getMapPanePos();
        Math.max(Math.abs(r.x), Math.abs(r.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom());
      },
      _findEventTargets: function(r, u) {
        for (var h = [], y, T = u === "mouseout" || u === "mouseover", D = r.target || r.srcElement, I = !1; D; ) {
          if (y = this._targets[z(D)], y && (u === "click" || u === "preclick") && this._draggableMoved(y)) {
            I = !0;
            break;
          }
          if (y && y.listens(u, !0) && (T && !uo(D, r) || (h.push(y), T)) || D === this._container)
            break;
          D = D.parentNode;
        }
        return !h.length && !I && !T && this.listens(u, !0) && (h = [this]), h;
      },
      _isClickDisabled: function(r) {
        for (; r && r !== this._container; ) {
          if (r._leaflet_disable_click)
            return !0;
          r = r.parentNode;
        }
      },
      _handleDOMEvent: function(r) {
        var u = r.target || r.srcElement;
        if (!(!this._loaded || u._leaflet_disable_events || r.type === "click" && this._isClickDisabled(u))) {
          var h = r.type;
          h === "mousedown" && Fo(u), this._fireDOMEvent(r, h);
        }
      },
      _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
      _fireDOMEvent: function(r, u, h) {
        if (r.type === "click") {
          var y = w({}, r);
          y.type = "preclick", this._fireDOMEvent(y, y.type, h);
        }
        var T = this._findEventTargets(r, u);
        if (h) {
          for (var D = [], I = 0; I < h.length; I++)
            h[I].listens(u, !0) && D.push(h[I]);
          T = D.concat(T);
        }
        if (T.length) {
          u === "contextmenu" && Dn(r);
          var Q = T[0], ie = {
            originalEvent: r
          };
          if (r.type !== "keypress" && r.type !== "keydown" && r.type !== "keyup") {
            var ge = Q.getLatLng && (!Q._radius || Q._radius <= 10);
            ie.containerPoint = ge ? this.latLngToContainerPoint(Q.getLatLng()) : this.mouseEventToContainerPoint(r), ie.layerPoint = this.containerPointToLayerPoint(ie.containerPoint), ie.latlng = ge ? Q.getLatLng() : this.layerPointToLatLng(ie.layerPoint);
          }
          for (I = 0; I < T.length; I++)
            if (T[I].fire(u, ie, !0), ie.originalEvent._stopped || T[I].options.bubblingMouseEvents === !1 && ye(this._mouseEvents, u) !== -1)
              return;
        }
      },
      _draggableMoved: function(r) {
        return r = r.dragging && r.dragging.enabled() ? r : this, r.dragging && r.dragging.moved() || this.boxZoom && this.boxZoom.moved();
      },
      _clearHandlers: function() {
        for (var r = 0, u = this._handlers.length; r < u; r++)
          this._handlers[r].disable();
      },
      // @section Other Methods
      // @method whenReady(fn: Function, context?: Object): this
      // Runs the given function `fn` when the map gets initialized with
      // a view (center and zoom) and at least one layer, or immediately
      // if it's already initialized, optionally passing a function context.
      whenReady: function(r, u) {
        return this._loaded ? r.call(u || this, { target: this }) : this.on("load", r, u), this;
      },
      // private methods for getting map state
      _getMapPanePos: function() {
        return ni(this._mapPane) || new le(0, 0);
      },
      _moved: function() {
        var r = this._getMapPanePos();
        return r && !r.equals([0, 0]);
      },
      _getTopLeftPoint: function(r, u) {
        var h = r && u !== void 0 ? this._getNewPixelOrigin(r, u) : this.getPixelOrigin();
        return h.subtract(this._getMapPanePos());
      },
      _getNewPixelOrigin: function(r, u) {
        var h = this.getSize()._divideBy(2);
        return this.project(r, u)._subtract(h)._add(this._getMapPanePos())._round();
      },
      _latLngToNewLayerPoint: function(r, u, h) {
        var y = this._getNewPixelOrigin(h, u);
        return this.project(r, u)._subtract(y);
      },
      _latLngBoundsToNewLayerBounds: function(r, u, h) {
        var y = this._getNewPixelOrigin(h, u);
        return xe([
          this.project(r.getSouthWest(), u)._subtract(y),
          this.project(r.getNorthWest(), u)._subtract(y),
          this.project(r.getSouthEast(), u)._subtract(y),
          this.project(r.getNorthEast(), u)._subtract(y)
        ]);
      },
      // layer point of the current center
      _getCenterLayerPoint: function() {
        return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
      },
      // offset of the specified place to the current center in pixels
      _getCenterOffset: function(r) {
        return this.latLngToLayerPoint(r).subtract(this._getCenterLayerPoint());
      },
      // adjust center for view to get inside bounds
      _limitCenter: function(r, u, h) {
        if (!h)
          return r;
        var y = this.project(r, u), T = this.getSize().divideBy(2), D = new se(y.subtract(T), y.add(T)), I = this._getBoundsOffset(D, h, u);
        return Math.abs(I.x) <= 1 && Math.abs(I.y) <= 1 ? r : this.unproject(y.add(I), u);
      },
      // adjust offset for view to get inside bounds
      _limitOffset: function(r, u) {
        if (!u)
          return r;
        var h = this.getPixelBounds(), y = new se(h.min.add(r), h.max.add(r));
        return r.add(this._getBoundsOffset(y, u));
      },
      // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
      _getBoundsOffset: function(r, u, h) {
        var y = xe(
          this.project(u.getNorthEast(), h),
          this.project(u.getSouthWest(), h)
        ), T = y.min.subtract(r.min), D = y.max.subtract(r.max), I = this._rebound(T.x, -D.x), Q = this._rebound(T.y, -D.y);
        return new le(I, Q);
      },
      _rebound: function(r, u) {
        return r + u > 0 ? Math.round(r - u) / 2 : Math.max(0, Math.ceil(r)) - Math.max(0, Math.floor(u));
      },
      _limitZoom: function(r) {
        var u = this.getMinZoom(), h = this.getMaxZoom(), y = We.any3d ? this.options.zoomSnap : 1;
        return y && (r = Math.round(r / y) * y), Math.max(u, Math.min(h, r));
      },
      _onPanTransitionStep: function() {
        this.fire("move");
      },
      _onPanTransitionEnd: function() {
        sn(this._mapPane, "leaflet-pan-anim"), this.fire("moveend");
      },
      _tryAnimatedPan: function(r, u) {
        var h = this._getCenterOffset(r)._trunc();
        return (u && u.animate) !== !0 && !this.getSize().contains(h) ? !1 : (this.panBy(h, u), !0);
      },
      _createAnimProxy: function() {
        var r = this._proxy = Pt("div", "leaflet-proxy leaflet-zoom-animated");
        this._panes.mapPane.appendChild(r), this.on("zoomanim", function(u) {
          var h = to, y = this._proxy.style[h];
          hi(this._proxy, this.project(u.center, u.zoom), this.getZoomScale(u.zoom, 1)), y === this._proxy.style[h] && this._animatingZoom && this._onZoomTransitionEnd();
        }, this), this.on("load moveend", this._animMoveEnd, this), this._on("unload", this._destroyAnimProxy, this);
      },
      _destroyAnimProxy: function() {
        In(this._proxy), this.off("load moveend", this._animMoveEnd, this), delete this._proxy;
      },
      _animMoveEnd: function() {
        var r = this.getCenter(), u = this.getZoom();
        hi(this._proxy, this.project(r, u), this.getZoomScale(u, 1));
      },
      _catchTransitionEnd: function(r) {
        this._animatingZoom && r.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd();
      },
      _nothingToAnimate: function() {
        return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
      },
      _tryAnimatedZoom: function(r, u, h) {
        if (this._animatingZoom)
          return !0;
        if (h = h || {}, !this._zoomAnimated || h.animate === !1 || this._nothingToAnimate() || Math.abs(u - this._zoom) > this.options.zoomAnimationThreshold)
          return !1;
        var y = this.getZoomScale(u), T = this._getCenterOffset(r)._divideBy(1 - 1 / y);
        return h.animate !== !0 && !this.getSize().contains(T) ? !1 : (Xe(function() {
          this._moveStart(!0, h.noMoveStart || !1)._animateZoom(r, u, !0);
        }, this), !0);
      },
      _animateZoom: function(r, u, h, y) {
        this._mapPane && (h && (this._animatingZoom = !0, this._animateToCenter = r, this._animateToZoom = u, xt(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", {
          center: r,
          zoom: u,
          noUpdate: y
        }), this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom), this._move(this._animateToCenter, this._animateToZoom, void 0, !0), setTimeout(C(this._onZoomTransitionEnd, this), 250));
      },
      _onZoomTransitionEnd: function() {
        this._animatingZoom && (this._mapPane && sn(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom, void 0, !0), this._tempFireZoomEvent && this.fire("zoom"), delete this._tempFireZoomEvent, this.fire("move"), this._moveEnd(!0));
      }
    });
    function La(r, u) {
      return new Kt(r, u);
    }
    var b = lt.extend({
      // @section
      // @aka Control Options
      options: {
        // @option position: String = 'topright'
        // The position of the control (one of the map corners). Possible values are `'topleft'`,
        // `'topright'`, `'bottomleft'` or `'bottomright'`
        position: "topright"
      },
      initialize: function(r) {
        ce(this, r);
      },
      /* @section
       * Classes extending L.Control will inherit the following methods:
       *
       * @method getPosition: string
       * Returns the position of the control.
       */
      getPosition: function() {
        return this.options.position;
      },
      // @method setPosition(position: string): this
      // Sets the position of the control.
      setPosition: function(r) {
        var u = this._map;
        return u && u.removeControl(this), this.options.position = r, u && u.addControl(this), this;
      },
      // @method getContainer: HTMLElement
      // Returns the HTMLElement that contains the control.
      getContainer: function() {
        return this._container;
      },
      // @method addTo(map: Map): this
      // Adds the control to the given map.
      addTo: function(r) {
        this.remove(), this._map = r;
        var u = this._container = this.onAdd(r), h = this.getPosition(), y = r._controlCorners[h];
        return xt(u, "leaflet-control"), h.indexOf("bottom") !== -1 ? y.insertBefore(u, y.firstChild) : y.appendChild(u), this._map.on("unload", this.remove, this), this;
      },
      // @method remove: this
      // Removes the control from the map it is currently active on.
      remove: function() {
        return this._map ? (In(this._container), this.onRemove && this.onRemove(this._map), this._map.off("unload", this.remove, this), this._map = null, this) : this;
      },
      _refocusOnMap: function(r) {
        this._map && r && r.screenX > 0 && r.screenY > 0 && this._map.getContainer().focus();
      }
    }), A = function(r) {
      return new b(r);
    };
    Kt.include({
      // @method addControl(control: Control): this
      // Adds the given control to the map
      addControl: function(r) {
        return r.addTo(this), this;
      },
      // @method removeControl(control: Control): this
      // Removes the given control from the map
      removeControl: function(r) {
        return r.remove(), this;
      },
      _initControlPos: function() {
        var r = this._controlCorners = {}, u = "leaflet-", h = this._controlContainer = Pt("div", u + "control-container", this._container);
        function y(T, D) {
          var I = u + T + " " + u + D;
          r[T + D] = Pt("div", I, h);
        }
        y("top", "left"), y("top", "right"), y("bottom", "left"), y("bottom", "right");
      },
      _clearControlPos: function() {
        for (var r in this._controlCorners)
          In(this._controlCorners[r]);
        In(this._controlContainer), delete this._controlCorners, delete this._controlContainer;
      }
    });
    var te = b.extend({
      // @section
      // @aka Control.Layers options
      options: {
        // @option collapsed: Boolean = true
        // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
        collapsed: !0,
        position: "topright",
        // @option autoZIndex: Boolean = true
        // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
        autoZIndex: !0,
        // @option hideSingleBase: Boolean = false
        // If `true`, the base layers in the control will be hidden when there is only one.
        hideSingleBase: !1,
        // @option sortLayers: Boolean = false
        // Whether to sort the layers. When `false`, layers will keep the order
        // in which they were added to the control.
        sortLayers: !1,
        // @option sortFunction: Function = *
        // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
        // that will be used for sorting the layers, when `sortLayers` is `true`.
        // The function receives both the `L.Layer` instances and their names, as in
        // `sortFunction(layerA, layerB, nameA, nameB)`.
        // By default, it sorts layers alphabetically by their name.
        sortFunction: function(r, u, h, y) {
          return h < y ? -1 : y < h ? 1 : 0;
        }
      },
      initialize: function(r, u, h) {
        ce(this, h), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1, this._preventClick = !1;
        for (var y in r)
          this._addLayer(r[y], y);
        for (y in u)
          this._addLayer(u[y], y, !0);
      },
      onAdd: function(r) {
        this._initLayout(), this._update(), this._map = r, r.on("zoomend", this._checkDisabledLayers, this);
        for (var u = 0; u < this._layers.length; u++)
          this._layers[u].layer.on("add remove", this._onLayerChange, this);
        return this._container;
      },
      addTo: function(r) {
        return b.prototype.addTo.call(this, r), this._expandIfNotCollapsed();
      },
      onRemove: function() {
        this._map.off("zoomend", this._checkDisabledLayers, this);
        for (var r = 0; r < this._layers.length; r++)
          this._layers[r].layer.off("add remove", this._onLayerChange, this);
      },
      // @method addBaseLayer(layer: Layer, name: String): this
      // Adds a base layer (radio button entry) with the given name to the control.
      addBaseLayer: function(r, u) {
        return this._addLayer(r, u), this._map ? this._update() : this;
      },
      // @method addOverlay(layer: Layer, name: String): this
      // Adds an overlay (checkbox entry) with the given name to the control.
      addOverlay: function(r, u) {
        return this._addLayer(r, u, !0), this._map ? this._update() : this;
      },
      // @method removeLayer(layer: Layer): this
      // Remove the given layer from the control.
      removeLayer: function(r) {
        r.off("add remove", this._onLayerChange, this);
        var u = this._getLayer(z(r));
        return u && this._layers.splice(this._layers.indexOf(u), 1), this._map ? this._update() : this;
      },
      // @method expand(): this
      // Expand the control container if collapsed.
      expand: function() {
        xt(this._container, "leaflet-control-layers-expanded"), this._section.style.height = null;
        var r = this._map.getSize().y - (this._container.offsetTop + 50);
        return r < this._section.clientHeight ? (xt(this._section, "leaflet-control-layers-scrollbar"), this._section.style.height = r + "px") : sn(this._section, "leaflet-control-layers-scrollbar"), this._checkDisabledLayers(), this;
      },
      // @method collapse(): this
      // Collapse the control container if expanded.
      collapse: function() {
        return sn(this._container, "leaflet-control-layers-expanded"), this;
      },
      _initLayout: function() {
        var r = "leaflet-control-layers", u = this._container = Pt("div", r), h = this.options.collapsed;
        u.setAttribute("aria-haspopup", !0), os(u), so(u);
        var y = this._section = Pt("section", r + "-list");
        h && (this._map.on("click", this.collapse, this), nt(u, {
          mouseenter: this._expandSafely,
          mouseleave: this.collapse
        }, this));
        var T = this._layersLink = Pt("a", r + "-toggle", u);
        T.href = "#", T.title = "Layers", T.setAttribute("role", "button"), nt(T, {
          keydown: function(D) {
            D.keyCode === 13 && this._expandSafely();
          },
          // Certain screen readers intercept the key event and instead send a click event
          click: function(D) {
            Dn(D), this._expandSafely();
          }
        }, this), h || this.expand(), this._baseLayersList = Pt("div", r + "-base", y), this._separator = Pt("div", r + "-separator", y), this._overlaysList = Pt("div", r + "-overlays", y), u.appendChild(y);
      },
      _getLayer: function(r) {
        for (var u = 0; u < this._layers.length; u++)
          if (this._layers[u] && z(this._layers[u].layer) === r)
            return this._layers[u];
      },
      _addLayer: function(r, u, h) {
        this._map && r.on("add remove", this._onLayerChange, this), this._layers.push({
          layer: r,
          name: u,
          overlay: h
        }), this.options.sortLayers && this._layers.sort(C(function(y, T) {
          return this.options.sortFunction(y.layer, T.layer, y.name, T.name);
        }, this)), this.options.autoZIndex && r.setZIndex && (this._lastZIndex++, r.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed();
      },
      _update: function() {
        if (!this._container)
          return this;
        rs(this._baseLayersList), rs(this._overlaysList), this._layerControlInputs = [];
        var r, u, h, y, T = 0;
        for (h = 0; h < this._layers.length; h++)
          y = this._layers[h], this._addItem(y), u = u || y.overlay, r = r || !y.overlay, T += y.overlay ? 0 : 1;
        return this.options.hideSingleBase && (r = r && T > 1, this._baseLayersList.style.display = r ? "" : "none"), this._separator.style.display = u && r ? "" : "none", this;
      },
      _onLayerChange: function(r) {
        this._handlingClick || this._update();
        var u = this._getLayer(z(r.target)), h = u.overlay ? r.type === "add" ? "overlayadd" : "overlayremove" : r.type === "add" ? "baselayerchange" : null;
        h && this._map.fire(h, u);
      },
      // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
      _createRadioElement: function(r, u) {
        var h = '<input type="radio" class="leaflet-control-layers-selector" name="' + r + '"' + (u ? ' checked="checked"' : "") + "/>", y = document.createElement("div");
        return y.innerHTML = h, y.firstChild;
      },
      _addItem: function(r) {
        var u = document.createElement("label"), h = this._map.hasLayer(r.layer), y;
        r.overlay ? (y = document.createElement("input"), y.type = "checkbox", y.className = "leaflet-control-layers-selector", y.defaultChecked = h) : y = this._createRadioElement("leaflet-base-layers_" + z(this), h), this._layerControlInputs.push(y), y.layerId = z(r.layer), nt(y, "click", this._onInputClick, this);
        var T = document.createElement("span");
        T.innerHTML = " " + r.name;
        var D = document.createElement("span");
        u.appendChild(D), D.appendChild(y), D.appendChild(T);
        var I = r.overlay ? this._overlaysList : this._baseLayersList;
        return I.appendChild(u), this._checkDisabledLayers(), u;
      },
      _onInputClick: function() {
        if (!this._preventClick) {
          var r = this._layerControlInputs, u, h, y = [], T = [];
          this._handlingClick = !0;
          for (var D = r.length - 1; D >= 0; D--)
            u = r[D], h = this._getLayer(u.layerId).layer, u.checked ? y.push(h) : u.checked || T.push(h);
          for (D = 0; D < T.length; D++)
            this._map.hasLayer(T[D]) && this._map.removeLayer(T[D]);
          for (D = 0; D < y.length; D++)
            this._map.hasLayer(y[D]) || this._map.addLayer(y[D]);
          this._handlingClick = !1, this._refocusOnMap();
        }
      },
      _checkDisabledLayers: function() {
        for (var r = this._layerControlInputs, u, h, y = this._map.getZoom(), T = r.length - 1; T >= 0; T--)
          u = r[T], h = this._getLayer(u.layerId).layer, u.disabled = h.options.minZoom !== void 0 && y < h.options.minZoom || h.options.maxZoom !== void 0 && y > h.options.maxZoom;
      },
      _expandIfNotCollapsed: function() {
        return this._map && !this.options.collapsed && this.expand(), this;
      },
      _expandSafely: function() {
        var r = this._section;
        this._preventClick = !0, nt(r, "click", Dn), this.expand();
        var u = this;
        setTimeout(function() {
          Mn(r, "click", Dn), u._preventClick = !1;
        });
      }
    }), fe = function(r, u, h) {
      return new te(r, u, h);
    }, Ce = b.extend({
      // @section
      // @aka Control.Zoom options
      options: {
        position: "topleft",
        // @option zoomInText: String = '<span aria-hidden="true">+</span>'
        // The text set on the 'zoom in' button.
        zoomInText: '<span aria-hidden="true">+</span>',
        // @option zoomInTitle: String = 'Zoom in'
        // The title set on the 'zoom in' button.
        zoomInTitle: "Zoom in",
        // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
        // The text set on the 'zoom out' button.
        zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
        // @option zoomOutTitle: String = 'Zoom out'
        // The title set on the 'zoom out' button.
        zoomOutTitle: "Zoom out"
      },
      onAdd: function(r) {
        var u = "leaflet-control-zoom", h = Pt("div", u + " leaflet-bar"), y = this.options;
        return this._zoomInButton = this._createButton(
          y.zoomInText,
          y.zoomInTitle,
          u + "-in",
          h,
          this._zoomIn
        ), this._zoomOutButton = this._createButton(
          y.zoomOutText,
          y.zoomOutTitle,
          u + "-out",
          h,
          this._zoomOut
        ), this._updateDisabled(), r.on("zoomend zoomlevelschange", this._updateDisabled, this), h;
      },
      onRemove: function(r) {
        r.off("zoomend zoomlevelschange", this._updateDisabled, this);
      },
      disable: function() {
        return this._disabled = !0, this._updateDisabled(), this;
      },
      enable: function() {
        return this._disabled = !1, this._updateDisabled(), this;
      },
      _zoomIn: function(r) {
        !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (r.shiftKey ? 3 : 1));
      },
      _zoomOut: function(r) {
        !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (r.shiftKey ? 3 : 1));
      },
      _createButton: function(r, u, h, y, T) {
        var D = Pt("a", h, y);
        return D.innerHTML = r, D.href = "#", D.title = u, D.setAttribute("role", "button"), D.setAttribute("aria-label", u), os(D), nt(D, "click", Li), nt(D, "click", T, this), nt(D, "click", this._refocusOnMap, this), D;
      },
      _updateDisabled: function() {
        var r = this._map, u = "leaflet-disabled";
        sn(this._zoomInButton, u), sn(this._zoomOutButton, u), this._zoomInButton.setAttribute("aria-disabled", "false"), this._zoomOutButton.setAttribute("aria-disabled", "false"), (this._disabled || r._zoom === r.getMinZoom()) && (xt(this._zoomOutButton, u), this._zoomOutButton.setAttribute("aria-disabled", "true")), (this._disabled || r._zoom === r.getMaxZoom()) && (xt(this._zoomInButton, u), this._zoomInButton.setAttribute("aria-disabled", "true"));
      }
    });
    Kt.mergeOptions({
      zoomControl: !0
    }), Kt.addInitHook(function() {
      this.options.zoomControl && (this.zoomControl = new Ce(), this.addControl(this.zoomControl));
    });
    var St = function(r) {
      return new Ce(r);
    }, Le = b.extend({
      // @section
      // @aka Control.Scale options
      options: {
        position: "bottomleft",
        // @option maxWidth: Number = 100
        // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
        maxWidth: 100,
        // @option metric: Boolean = True
        // Whether to show the metric scale line (m/km).
        metric: !0,
        // @option imperial: Boolean = True
        // Whether to show the imperial scale line (mi/ft).
        imperial: !0
        // @option updateWhenIdle: Boolean = false
        // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
      },
      onAdd: function(r) {
        var u = "leaflet-control-scale", h = Pt("div", u), y = this.options;
        return this._addScales(y, u + "-line", h), r.on(y.updateWhenIdle ? "moveend" : "move", this._update, this), r.whenReady(this._update, this), h;
      },
      onRemove: function(r) {
        r.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
      },
      _addScales: function(r, u, h) {
        r.metric && (this._mScale = Pt("div", u, h)), r.imperial && (this._iScale = Pt("div", u, h));
      },
      _update: function() {
        var r = this._map, u = r.getSize().y / 2, h = r.distance(
          r.containerPointToLatLng([0, u]),
          r.containerPointToLatLng([this.options.maxWidth, u])
        );
        this._updateScales(h);
      },
      _updateScales: function(r) {
        this.options.metric && r && this._updateMetric(r), this.options.imperial && r && this._updateImperial(r);
      },
      _updateMetric: function(r) {
        var u = this._getRoundNum(r), h = u < 1e3 ? u + " m" : u / 1e3 + " km";
        this._updateScale(this._mScale, h, u / r);
      },
      _updateImperial: function(r) {
        var u = r * 3.2808399, h, y, T;
        u > 5280 ? (h = u / 5280, y = this._getRoundNum(h), this._updateScale(this._iScale, y + " mi", y / h)) : (T = this._getRoundNum(u), this._updateScale(this._iScale, T + " ft", T / u));
      },
      _updateScale: function(r, u, h) {
        r.style.width = Math.round(this.options.maxWidth * h) + "px", r.innerHTML = u;
      },
      _getRoundNum: function(r) {
        var u = Math.pow(10, (Math.floor(r) + "").length - 1), h = r / u;
        return h = h >= 10 ? 10 : h >= 5 ? 5 : h >= 3 ? 3 : h >= 2 ? 2 : 1, u * h;
      }
    }), gt = function(r) {
      return new Le(r);
    }, qt = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>', an = b.extend({
      // @section
      // @aka Control.Attribution options
      options: {
        position: "bottomright",
        // @option prefix: String|false = 'Leaflet'
        // The HTML text shown before the attributions. Pass `false` to disable.
        prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (We.inlineSvg ? qt + " " : "") + "Leaflet</a>"
      },
      initialize: function(r) {
        ce(this, r), this._attributions = {};
      },
      onAdd: function(r) {
        r.attributionControl = this, this._container = Pt("div", "leaflet-control-attribution"), os(this._container);
        for (var u in r._layers)
          r._layers[u].getAttribution && this.addAttribution(r._layers[u].getAttribution());
        return this._update(), r.on("layeradd", this._addAttribution, this), this._container;
      },
      onRemove: function(r) {
        r.off("layeradd", this._addAttribution, this);
      },
      _addAttribution: function(r) {
        r.layer.getAttribution && (this.addAttribution(r.layer.getAttribution()), r.layer.once("remove", function() {
          this.removeAttribution(r.layer.getAttribution());
        }, this));
      },
      // @method setPrefix(prefix: String|false): this
      // The HTML text shown before the attributions. Pass `false` to disable.
      setPrefix: function(r) {
        return this.options.prefix = r, this._update(), this;
      },
      // @method addAttribution(text: String): this
      // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
      addAttribution: function(r) {
        return r ? (this._attributions[r] || (this._attributions[r] = 0), this._attributions[r]++, this._update(), this) : this;
      },
      // @method removeAttribution(text: String): this
      // Removes an attribution text.
      removeAttribution: function(r) {
        return r ? (this._attributions[r] && (this._attributions[r]--, this._update()), this) : this;
      },
      _update: function() {
        if (this._map) {
          var r = [];
          for (var u in this._attributions)
            this._attributions[u] && r.push(u);
          var h = [];
          this.options.prefix && h.push(this.options.prefix), r.length && h.push(r.join(", ")), this._container.innerHTML = h.join(' <span aria-hidden="true">|</span> ');
        }
      }
    });
    Kt.mergeOptions({
      attributionControl: !0
    }), Kt.addInitHook(function() {
      this.options.attributionControl && new an().addTo(this);
    });
    var jn = function(r) {
      return new an(r);
    };
    b.Layers = te, b.Zoom = Ce, b.Scale = Le, b.Attribution = an, A.layers = fe, A.zoom = St, A.scale = gt, A.attribution = jn;
    var Xt = lt.extend({
      initialize: function(r) {
        this._map = r;
      },
      // @method enable(): this
      // Enables the handler
      enable: function() {
        return this._enabled ? this : (this._enabled = !0, this.addHooks(), this);
      },
      // @method disable(): this
      // Disables the handler
      disable: function() {
        return this._enabled ? (this._enabled = !1, this.removeHooks(), this) : this;
      },
      // @method enabled(): Boolean
      // Returns `true` if the handler is enabled
      enabled: function() {
        return !!this._enabled;
      }
      // @section Extension methods
      // Classes inheriting from `Handler` must implement the two following methods:
      // @method addHooks()
      // Called when the handler is enabled, should add event hooks.
      // @method removeHooks()
      // Called when the handler is disabled, should remove the event hooks added previously.
    });
    Xt.addTo = function(r, u) {
      return r.addHandler(u, this), this;
    };
    var Fn = { Events: vt }, Hn = We.touch ? "touchstart mousedown" : "mousedown", Ht = Ne.extend({
      options: {
        // @section
        // @aka Draggable options
        // @option clickTolerance: Number = 3
        // The max number of pixels a user can shift the mouse pointer during a click
        // for it to be considered a valid click (as opposed to a mouse drag).
        clickTolerance: 3
      },
      // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
      // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
      initialize: function(r, u, h, y) {
        ce(this, y), this._element = r, this._dragStartTarget = u || r, this._preventOutline = h;
      },
      // @method enable()
      // Enables the dragging ability
      enable: function() {
        this._enabled || (nt(this._dragStartTarget, Hn, this._onDown, this), this._enabled = !0);
      },
      // @method disable()
      // Disables the dragging ability
      disable: function() {
        this._enabled && (Ht._dragging === this && this.finishDrag(!0), Mn(this._dragStartTarget, Hn, this._onDown, this), this._enabled = !1, this._moved = !1);
      },
      _onDown: function(r) {
        if (this._enabled && (this._moved = !1, !ro(this._element, "leaflet-zoom-anim"))) {
          if (r.touches && r.touches.length !== 1) {
            Ht._dragging === this && this.finishDrag();
            return;
          }
          if (!(Ht._dragging || r.shiftKey || r.which !== 1 && r.button !== 1 && !r.touches) && (Ht._dragging = this, this._preventOutline && Fo(this._element), rn(), nn(), !this._moving)) {
            this.fire("down");
            var u = r.touches ? r.touches[0] : r, h = pi(this._element);
            this._startPoint = new le(u.clientX, u.clientY), this._startPos = ni(this._element), this._parentScale = Vr(h);
            var y = r.type === "mousedown";
            nt(document, y ? "mousemove" : "touchmove", this._onMove, this), nt(document, y ? "mouseup" : "touchend touchcancel", this._onUp, this);
          }
        }
      },
      _onMove: function(r) {
        if (this._enabled) {
          if (r.touches && r.touches.length > 1) {
            this._moved = !0;
            return;
          }
          var u = r.touches && r.touches.length === 1 ? r.touches[0] : r, h = new le(u.clientX, u.clientY)._subtract(this._startPoint);
          !h.x && !h.y || Math.abs(h.x) + Math.abs(h.y) < this.options.clickTolerance || (h.x /= this._parentScale.x, h.y /= this._parentScale.y, Dn(r), this._moved || (this.fire("dragstart"), this._moved = !0, xt(document.body, "leaflet-dragging"), this._lastTarget = r.target || r.srcElement, window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), xt(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(h), this._moving = !0, this._lastEvent = r, this._updatePosition());
        }
      },
      _updatePosition: function() {
        var r = { originalEvent: this._lastEvent };
        this.fire("predrag", r), lr(this._element, this._newPos), this.fire("drag", r);
      },
      _onUp: function() {
        this._enabled && this.finishDrag();
      },
      finishDrag: function(r) {
        sn(document.body, "leaflet-dragging"), this._lastTarget && (sn(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null), Mn(document, "mousemove touchmove", this._onMove, this), Mn(document, "mouseup touchend touchcancel", this._onUp, this), is(), ao();
        var u = this._moved && this._moving;
        this._moving = !1, Ht._dragging = !1, u && this.fire("dragend", {
          noInertia: r,
          distance: this._newPos.distanceTo(this._startPos)
        });
      }
    });
    function lo(r, u, h) {
      var y, T = [1, 4, 2, 8], D, I, Q, ie, ge, Fe, ht, Vt;
      for (D = 0, Fe = r.length; D < Fe; D++)
        r[D]._code = ss(r[D], u);
      for (Q = 0; Q < 4; Q++) {
        for (ht = T[Q], y = [], D = 0, Fe = r.length, I = Fe - 1; D < Fe; I = D++)
          ie = r[D], ge = r[I], ie._code & ht ? ge._code & ht || (Vt = ol(ge, ie, ht, u, h), Vt._code = ss(Vt, u), y.push(Vt)) : (ge._code & ht && (Vt = ol(ge, ie, ht, u, h), Vt._code = ss(Vt, u), y.push(Vt)), y.push(ie));
        r = y;
      }
      return r;
    }
    function As(r, u) {
      var h, y, T, D, I, Q, ie, ge, Fe;
      if (!r || r.length === 0)
        throw new Error("latlngs not passed");
      Tr(r) || (console.warn("latlngs are not flat! Only the first ring will be used"), r = r[0]);
      var ht = Oe([0, 0]), Vt = je(r), hr = Vt.getNorthWest().distanceTo(Vt.getSouthWest()) * Vt.getNorthEast().distanceTo(Vt.getNorthWest());
      hr < 1700 && (ht = zs(r));
      var Lr = r.length, Pi = [];
      for (h = 0; h < Lr; h++) {
        var ii = Oe(r[h]);
        Pi.push(u.project(Oe([ii.lat - ht.lat, ii.lng - ht.lng])));
      }
      for (Q = ie = ge = 0, h = 0, y = Lr - 1; h < Lr; y = h++)
        T = Pi[h], D = Pi[y], I = T.y * D.x - D.y * T.x, ie += (T.x + D.x) * I, ge += (T.y + D.y) * I, Q += I * 3;
      Q === 0 ? Fe = Pi[0] : Fe = [ie / Q, ge / Q];
      var xu = u.unproject(N(Fe));
      return Oe([xu.lat + ht.lat, xu.lng + ht.lng]);
    }
    function zs(r) {
      for (var u = 0, h = 0, y = 0, T = 0; T < r.length; T++) {
        var D = Oe(r[T]);
        u += D.lat, h += D.lng, y++;
      }
      return Oe([u / y, h / y]);
    }
    var gf = {
      __proto__: null,
      clipPolygon: lo,
      polygonCenter: As,
      centroid: zs
    };
    function oa(r, u) {
      if (!u || !r.length)
        return r.slice();
      var h = u * u;
      return r = gp(r, h), r = _f(r, h), r;
    }
    function yu(r, u, h) {
      return Math.sqrt(Us(r, u, h, !0));
    }
    function al(r, u, h) {
      return Us(r, u, h);
    }
    function _f(r, u) {
      var h = r.length, y = typeof Uint8Array != void 0 + "" ? Uint8Array : Array, T = new y(h);
      T[0] = T[h - 1] = 1, Sf(r, T, u, 0, h - 1);
      var D, I = [];
      for (D = 0; D < h; D++)
        T[D] && I.push(r[D]);
      return I;
    }
    function Sf(r, u, h, y, T) {
      var D = 0, I, Q, ie;
      for (Q = y + 1; Q <= T - 1; Q++)
        ie = Us(r[Q], r[y], r[T], !0), ie > D && (I = Q, D = ie);
      D > h && (u[I] = 1, Sf(r, u, h, y, I), Sf(r, u, h, I, T));
    }
    function gp(r, u) {
      for (var h = [r[0]], y = 1, T = 0, D = r.length; y < D; y++)
        Sd(r[y], r[T]) > u && (h.push(r[y]), T = y);
      return T < D - 1 && h.push(r[D - 1]), h;
    }
    var sc;
    function uc(r, u, h, y, T) {
      var D = y ? sc : ss(r, h), I = ss(u, h), Q, ie, ge;
      for (sc = I; ; ) {
        if (!(D | I))
          return [r, u];
        if (D & I)
          return !1;
        Q = D || I, ie = ol(r, u, Q, h, T), ge = ss(ie, h), Q === D ? (r = ie, D = ge) : (u = ie, I = ge);
      }
    }
    function ol(r, u, h, y, T) {
      var D = u.x - r.x, I = u.y - r.y, Q = y.min, ie = y.max, ge, Fe;
      return h & 8 ? (ge = r.x + D * (ie.y - r.y) / I, Fe = ie.y) : h & 4 ? (ge = r.x + D * (Q.y - r.y) / I, Fe = Q.y) : h & 2 ? (ge = ie.x, Fe = r.y + I * (ie.x - r.x) / D) : h & 1 && (ge = Q.x, Fe = r.y + I * (Q.x - r.x) / D), new le(ge, Fe, T);
    }
    function ss(r, u) {
      var h = 0;
      return r.x < u.min.x ? h |= 1 : r.x > u.max.x && (h |= 2), r.y < u.min.y ? h |= 4 : r.y > u.max.y && (h |= 8), h;
    }
    function Sd(r, u) {
      var h = u.x - r.x, y = u.y - r.y;
      return h * h + y * y;
    }
    function Us(r, u, h, y) {
      var T = u.x, D = u.y, I = h.x - T, Q = h.y - D, ie = I * I + Q * Q, ge;
      return ie > 0 && (ge = ((r.x - T) * I + (r.y - D) * Q) / ie, ge > 1 ? (T = h.x, D = h.y) : ge > 0 && (T += I * ge, D += Q * ge)), I = r.x - T, Q = r.y - D, y ? I * I + Q * Q : new le(T, D);
    }
    function Tr(r) {
      return !ve(r[0]) || typeof r[0][0] != "object" && typeof r[0][0] < "u";
    }
    function wd(r) {
      return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), Tr(r);
    }
    function lc(r, u) {
      var h, y, T, D, I, Q, ie, ge;
      if (!r || r.length === 0)
        throw new Error("latlngs not passed");
      Tr(r) || (console.warn("latlngs are not flat! Only the first ring will be used"), r = r[0]);
      var Fe = Oe([0, 0]), ht = je(r), Vt = ht.getNorthWest().distanceTo(ht.getSouthWest()) * ht.getNorthEast().distanceTo(ht.getNorthWest());
      Vt < 1700 && (Fe = zs(r));
      var hr = r.length, Lr = [];
      for (h = 0; h < hr; h++) {
        var Pi = Oe(r[h]);
        Lr.push(u.project(Oe([Pi.lat - Fe.lat, Pi.lng - Fe.lng])));
      }
      for (h = 0, y = 0; h < hr - 1; h++)
        y += Lr[h].distanceTo(Lr[h + 1]) / 2;
      if (y === 0)
        ge = Lr[0];
      else
        for (h = 0, D = 0; h < hr - 1; h++)
          if (I = Lr[h], Q = Lr[h + 1], T = I.distanceTo(Q), D += T, D > y) {
            ie = (D - y) / T, ge = [
              Q.x - ie * (Q.x - I.x),
              Q.y - ie * (Q.y - I.y)
            ];
            break;
          }
      var ii = u.unproject(N(ge));
      return Oe([ii.lat + Fe.lat, ii.lng + Fe.lng]);
    }
    var cc = {
      __proto__: null,
      simplify: oa,
      pointToSegmentDistance: yu,
      closestPointOnSegment: al,
      clipSegment: uc,
      _getEdgeIntersection: ol,
      _getBitCode: ss,
      _sqClosestPointOnSegment: Us,
      isFlat: Tr,
      _flat: wd,
      polylineCenter: lc
    }, sl = {
      project: function(r) {
        return new le(r.lng, r.lat);
      },
      unproject: function(r) {
        return new qe(r.y, r.x);
      },
      bounds: new se([-180, -90], [180, 90])
    }, wf = {
      R: 6378137,
      R_MINOR: 6356752314245179e-9,
      bounds: new se([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
      project: function(r) {
        var u = Math.PI / 180, h = this.R, y = r.lat * u, T = this.R_MINOR / h, D = Math.sqrt(1 - T * T), I = D * Math.sin(y), Q = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - I) / (1 + I), D / 2);
        return y = -h * Math.log(Math.max(Q, 1e-10)), new le(r.lng * u * h, y);
      },
      unproject: function(r) {
        for (var u = 180 / Math.PI, h = this.R, y = this.R_MINOR / h, T = Math.sqrt(1 - y * y), D = Math.exp(-r.y / h), I = Math.PI / 2 - 2 * Math.atan(D), Q = 0, ie = 0.1, ge; Q < 15 && Math.abs(ie) > 1e-7; Q++)
          ge = T * Math.sin(I), ge = Math.pow((1 - ge) / (1 + ge), T / 2), ie = Math.PI / 2 - 2 * Math.atan(D * ge) - I, I += ie;
        return new qe(I * u, r.x * u / h);
      }
    }, fc = {
      __proto__: null,
      LonLat: sl,
      Mercator: wf,
      SphericalMercator: Sr
    }, Ed = w({}, _t, {
      code: "EPSG:3395",
      projection: wf,
      transformation: function() {
        var r = 0.5 / (Math.PI * wf.R);
        return Ue(r, 0.5, -r, 0.5);
      }()
    }), yi = w({}, _t, {
      code: "EPSG:4326",
      projection: sl,
      transformation: Ue(1 / 180, 1, -1 / 180, 0.5)
    }), Yo = w({}, Rt, {
      projection: sl,
      transformation: Ue(1, 0, -1, 0),
      scale: function(r) {
        return Math.pow(2, r);
      },
      zoom: function(r) {
        return Math.log(r) / Math.LN2;
      },
      distance: function(r, u) {
        var h = u.lng - r.lng, y = u.lat - r.lat;
        return Math.sqrt(h * h + y * y);
      },
      infinite: !0
    });
    Rt.Earth = _t, Rt.EPSG3395 = Ed, Rt.EPSG3857 = yn, Rt.EPSG900913 = Ie, Rt.EPSG4326 = yi, Rt.Simple = Yo;
    var En = Ne.extend({
      // Classes extending `L.Layer` will inherit the following options:
      options: {
        // @option pane: String = 'overlayPane'
        // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
        pane: "overlayPane",
        // @option attribution: String = null
        // String to be shown in the attribution control, e.g. " OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
        attribution: null,
        bubblingMouseEvents: !0
      },
      /* @section
       * Classes extending `L.Layer` will inherit the following methods:
       *
       * @method addTo(map: Map|LayerGroup): this
       * Adds the layer to the given map or layer group.
       */
      addTo: function(r) {
        return r.addLayer(this), this;
      },
      // @method remove: this
      // Removes the layer from the map it is currently active on.
      remove: function() {
        return this.removeFrom(this._map || this._mapToAdd);
      },
      // @method removeFrom(map: Map): this
      // Removes the layer from the given map
      //
      // @alternative
      // @method removeFrom(group: LayerGroup): this
      // Removes the layer from the given `LayerGroup`
      removeFrom: function(r) {
        return r && r.removeLayer(this), this;
      },
      // @method getPane(name? : String): HTMLElement
      // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
      getPane: function(r) {
        return this._map.getPane(r ? this.options[r] || r : this.options.pane);
      },
      addInteractiveTarget: function(r) {
        return this._map._targets[z(r)] = this, this;
      },
      removeInteractiveTarget: function(r) {
        return delete this._map._targets[z(r)], this;
      },
      // @method getAttribution: String
      // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
      getAttribution: function() {
        return this.options.attribution;
      },
      _layerAdd: function(r) {
        var u = r.target;
        if (u.hasLayer(this)) {
          if (this._map = u, this._zoomAnimated = u._zoomAnimated, this.getEvents) {
            var h = this.getEvents();
            u.on(h, this), this.once("remove", function() {
              u.off(h, this);
            }, this);
          }
          this.onAdd(u), this.fire("add"), u.fire("layeradd", { layer: this });
        }
      }
    });
    Kt.include({
      // @method addLayer(layer: Layer): this
      // Adds the given layer to the map
      addLayer: function(r) {
        if (!r._layerAdd)
          throw new Error("The provided object is not a Layer.");
        var u = z(r);
        return this._layers[u] ? this : (this._layers[u] = r, r._mapToAdd = this, r.beforeAdd && r.beforeAdd(this), this.whenReady(r._layerAdd, r), this);
      },
      // @method removeLayer(layer: Layer): this
      // Removes the given layer from the map.
      removeLayer: function(r) {
        var u = z(r);
        return this._layers[u] ? (this._loaded && r.onRemove(this), delete this._layers[u], this._loaded && (this.fire("layerremove", { layer: r }), r.fire("remove")), r._map = r._mapToAdd = null, this) : this;
      },
      // @method hasLayer(layer: Layer): Boolean
      // Returns `true` if the given layer is currently added to the map
      hasLayer: function(r) {
        return z(r) in this._layers;
      },
      /* @method eachLayer(fn: Function, context?: Object): this
       * Iterates over the layers of the map, optionally specifying context of the iterator function.
       * ```
       * map.eachLayer(function(layer){
       *     layer.bindPopup('Hello');
       * });
       * ```
       */
      eachLayer: function(r, u) {
        for (var h in this._layers)
          r.call(u, this._layers[h]);
        return this;
      },
      _addLayers: function(r) {
        r = r ? ve(r) ? r : [r] : [];
        for (var u = 0, h = r.length; u < h; u++)
          this.addLayer(r[u]);
      },
      _addZoomLimit: function(r) {
        (!isNaN(r.options.maxZoom) || !isNaN(r.options.minZoom)) && (this._zoomBoundLayers[z(r)] = r, this._updateZoomLevels());
      },
      _removeZoomLimit: function(r) {
        var u = z(r);
        this._zoomBoundLayers[u] && (delete this._zoomBoundLayers[u], this._updateZoomLevels());
      },
      _updateZoomLevels: function() {
        var r = 1 / 0, u = -1 / 0, h = this._getZoomSpan();
        for (var y in this._zoomBoundLayers) {
          var T = this._zoomBoundLayers[y].options;
          r = T.minZoom === void 0 ? r : Math.min(r, T.minZoom), u = T.maxZoom === void 0 ? u : Math.max(u, T.maxZoom);
        }
        this._layersMaxZoom = u === -1 / 0 ? void 0 : u, this._layersMinZoom = r === 1 / 0 ? void 0 : r, h !== this._getZoomSpan() && this.fire("zoomlevelschange"), this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom);
      }
    });
    var ri = En.extend({
      initialize: function(r, u) {
        ce(this, u), this._layers = {};
        var h, y;
        if (r)
          for (h = 0, y = r.length; h < y; h++)
            this.addLayer(r[h]);
      },
      // @method addLayer(layer: Layer): this
      // Adds the given layer to the group.
      addLayer: function(r) {
        var u = this.getLayerId(r);
        return this._layers[u] = r, this._map && this._map.addLayer(r), this;
      },
      // @method removeLayer(layer: Layer): this
      // Removes the given layer from the group.
      // @alternative
      // @method removeLayer(id: Number): this
      // Removes the layer with the given internal ID from the group.
      removeLayer: function(r) {
        var u = r in this._layers ? r : this.getLayerId(r);
        return this._map && this._layers[u] && this._map.removeLayer(this._layers[u]), delete this._layers[u], this;
      },
      // @method hasLayer(layer: Layer): Boolean
      // Returns `true` if the given layer is currently added to the group.
      // @alternative
      // @method hasLayer(id: Number): Boolean
      // Returns `true` if the given internal ID is currently added to the group.
      hasLayer: function(r) {
        var u = typeof r == "number" ? r : this.getLayerId(r);
        return u in this._layers;
      },
      // @method clearLayers(): this
      // Removes all the layers from the group.
      clearLayers: function() {
        return this.eachLayer(this.removeLayer, this);
      },
      // @method invoke(methodName: String, ): this
      // Calls `methodName` on every layer contained in this group, passing any
      // additional parameters. Has no effect if the layers contained do not
      // implement `methodName`.
      invoke: function(r) {
        var u = Array.prototype.slice.call(arguments, 1), h, y;
        for (h in this._layers)
          y = this._layers[h], y[r] && y[r].apply(y, u);
        return this;
      },
      onAdd: function(r) {
        this.eachLayer(r.addLayer, r);
      },
      onRemove: function(r) {
        this.eachLayer(r.removeLayer, r);
      },
      // @method eachLayer(fn: Function, context?: Object): this
      // Iterates over the layers of the group, optionally specifying context of the iterator function.
      // ```js
      // group.eachLayer(function (layer) {
      // 	layer.bindPopup('Hello');
      // });
      // ```
      eachLayer: function(r, u) {
        for (var h in this._layers)
          r.call(u, this._layers[h]);
        return this;
      },
      // @method getLayer(id: Number): Layer
      // Returns the layer with the given internal ID.
      getLayer: function(r) {
        return this._layers[r];
      },
      // @method getLayers(): Layer[]
      // Returns an array of all the layers added to the group.
      getLayers: function() {
        var r = [];
        return this.eachLayer(r.push, r), r;
      },
      // @method setZIndex(zIndex: Number): this
      // Calls `setZIndex` on every layer contained in this group, passing the z-index.
      setZIndex: function(r) {
        return this.invoke("setZIndex", r);
      },
      // @method getLayerId(layer: Layer): Number
      // Returns the internal ID for a layer
      getLayerId: function(r) {
        return z(r);
      }
    }), Is = function(r, u) {
      return new ri(r, u);
    }, sa = ri.extend({
      addLayer: function(r) {
        return this.hasLayer(r) ? this : (r.addEventParent(this), ri.prototype.addLayer.call(this, r), this.fire("layeradd", { layer: r }));
      },
      removeLayer: function(r) {
        return this.hasLayer(r) ? (r in this._layers && (r = this._layers[r]), r.removeEventParent(this), ri.prototype.removeLayer.call(this, r), this.fire("layerremove", { layer: r })) : this;
      },
      // @method setStyle(style: Path options): this
      // Sets the given path options to each layer of the group that has a `setStyle` method.
      setStyle: function(r) {
        return this.invoke("setStyle", r);
      },
      // @method bringToFront(): this
      // Brings the layer group to the top of all other layers
      bringToFront: function() {
        return this.invoke("bringToFront");
      },
      // @method bringToBack(): this
      // Brings the layer group to the back of all other layers
      bringToBack: function() {
        return this.invoke("bringToBack");
      },
      // @method getBounds(): LatLngBounds
      // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
      getBounds: function() {
        var r = new et();
        for (var u in this._layers) {
          var h = this._layers[u];
          r.extend(h.getBounds ? h.getBounds() : h.getLatLng());
        }
        return r;
      }
    }), Td = function(r, u) {
      return new sa(r, u);
    }, Na = lt.extend({
      /* @section
       * @aka Icon options
       *
       * @option iconUrl: String = null
       * **(required)** The URL to the icon image (absolute or relative to your script path).
       *
       * @option iconRetinaUrl: String = null
       * The URL to a retina sized version of the icon image (absolute or relative to your
       * script path). Used for Retina screen devices.
       *
       * @option iconSize: Point = null
       * Size of the icon image in pixels.
       *
       * @option iconAnchor: Point = null
       * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
       * will be aligned so that this point is at the marker's geographical location. Centered
       * by default if size is specified, also can be set in CSS with negative margins.
       *
       * @option popupAnchor: Point = [0, 0]
       * The coordinates of the point from which popups will "open", relative to the icon anchor.
       *
       * @option tooltipAnchor: Point = [0, 0]
       * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
       *
       * @option shadowUrl: String = null
       * The URL to the icon shadow image. If not specified, no shadow image will be created.
       *
       * @option shadowRetinaUrl: String = null
       *
       * @option shadowSize: Point = null
       * Size of the shadow image in pixels.
       *
       * @option shadowAnchor: Point = null
       * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
       * as iconAnchor if not specified).
       *
       * @option className: String = ''
       * A custom class name to assign to both icon and shadow images. Empty by default.
       */
      options: {
        popupAnchor: [0, 0],
        tooltipAnchor: [0, 0],
        // @option crossOrigin: Boolean|String = false
        // Whether the crossOrigin attribute will be added to the tiles.
        // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
        // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
        crossOrigin: !1
      },
      initialize: function(r) {
        ce(this, r);
      },
      // @method createIcon(oldIcon?: HTMLElement): HTMLElement
      // Called internally when the icon has to be shown, returns a `<img>` HTML element
      // styled according to the options.
      createIcon: function(r) {
        return this._createIcon("icon", r);
      },
      // @method createShadow(oldIcon?: HTMLElement): HTMLElement
      // As `createIcon`, but for the shadow beneath it.
      createShadow: function(r) {
        return this._createIcon("shadow", r);
      },
      _createIcon: function(r, u) {
        var h = this._getIconUrl(r);
        if (!h) {
          if (r === "icon")
            throw new Error("iconUrl not set in Icon options (see the docs).");
          return null;
        }
        var y = this._createImg(h, u && u.tagName === "IMG" ? u : null);
        return this._setIconStyles(y, r), (this.options.crossOrigin || this.options.crossOrigin === "") && (y.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), y;
      },
      _setIconStyles: function(r, u) {
        var h = this.options, y = h[u + "Size"];
        typeof y == "number" && (y = [y, y]);
        var T = N(y), D = N(u === "shadow" && h.shadowAnchor || h.iconAnchor || T && T.divideBy(2, !0));
        r.className = "leaflet-marker-" + u + " " + (h.className || ""), D && (r.style.marginLeft = -D.x + "px", r.style.marginTop = -D.y + "px"), T && (r.style.width = T.x + "px", r.style.height = T.y + "px");
      },
      _createImg: function(r, u) {
        return u = u || document.createElement("img"), u.src = r, u;
      },
      _getIconUrl: function(r) {
        return We.retina && this.options[r + "RetinaUrl"] || this.options[r + "Url"];
      }
    });
    function Cd(r) {
      return new Na(r);
    }
    var gu = Na.extend({
      options: {
        iconUrl: "marker-icon.png",
        iconRetinaUrl: "marker-icon-2x.png",
        shadowUrl: "marker-shadow.png",
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        tooltipAnchor: [16, -28],
        shadowSize: [41, 41]
      },
      _getIconUrl: function(r) {
        return typeof gu.imagePath != "string" && (gu.imagePath = this._detectIconPath()), (this.options.imagePath || gu.imagePath) + Na.prototype._getIconUrl.call(this, r);
      },
      _stripUrl: function(r) {
        var u = function(h, y, T) {
          var D = y.exec(h);
          return D && D[T];
        };
        return r = u(r, /^url\((['"])?(.+)\1\)$/, 2), r && u(r, /^(.*)marker-icon\.png$/, 1);
      },
      _detectIconPath: function() {
        var r = Pt("div", "leaflet-default-icon-path", document.body), u = Ao(r, "background-image") || Ao(r, "backgroundImage");
        if (document.body.removeChild(r), u = this._stripUrl(u), u)
          return u;
        var h = document.querySelector('link[href$="leaflet.css"]');
        return h ? h.href.substring(0, h.href.length - 11 - 1) : "";
      }
    }), ul = Xt.extend({
      initialize: function(r) {
        this._marker = r;
      },
      addHooks: function() {
        var r = this._marker._icon;
        this._draggable || (this._draggable = new Ht(r, r, !0)), this._draggable.on({
          dragstart: this._onDragStart,
          predrag: this._onPreDrag,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).enable(), xt(r, "leaflet-marker-draggable");
      },
      removeHooks: function() {
        this._draggable.off({
          dragstart: this._onDragStart,
          predrag: this._onPreDrag,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).disable(), this._marker._icon && sn(this._marker._icon, "leaflet-marker-draggable");
      },
      moved: function() {
        return this._draggable && this._draggable._moved;
      },
      _adjustPan: function(r) {
        var u = this._marker, h = u._map, y = this._marker.options.autoPanSpeed, T = this._marker.options.autoPanPadding, D = ni(u._icon), I = h.getPixelBounds(), Q = h.getPixelOrigin(), ie = xe(
          I.min._subtract(Q).add(T),
          I.max._subtract(Q).subtract(T)
        );
        if (!ie.contains(D)) {
          var ge = N(
            (Math.max(ie.max.x, D.x) - ie.max.x) / (I.max.x - ie.max.x) - (Math.min(ie.min.x, D.x) - ie.min.x) / (I.min.x - ie.min.x),
            (Math.max(ie.max.y, D.y) - ie.max.y) / (I.max.y - ie.max.y) - (Math.min(ie.min.y, D.y) - ie.min.y) / (I.min.y - ie.min.y)
          ).multiplyBy(y);
          h.panBy(ge, { animate: !1 }), this._draggable._newPos._add(ge), this._draggable._startPos._add(ge), lr(u._icon, this._draggable._newPos), this._onDrag(r), this._panRequest = Xe(this._adjustPan.bind(this, r));
        }
      },
      _onDragStart: function() {
        this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup && this._marker.closePopup(), this._marker.fire("movestart").fire("dragstart");
      },
      _onPreDrag: function(r) {
        this._marker.options.autoPan && (Mt(this._panRequest), this._panRequest = Xe(this._adjustPan.bind(this, r)));
      },
      _onDrag: function(r) {
        var u = this._marker, h = u._shadow, y = ni(u._icon), T = u._map.layerPointToLatLng(y);
        h && lr(h, y), u._latlng = T, r.latlng = T, r.oldLatLng = this._oldLatLng, u.fire("move", r).fire("drag", r);
      },
      _onDragEnd: function(r) {
        Mt(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", r);
      }
    }), Vo = En.extend({
      // @section
      // @aka Marker options
      options: {
        // @option icon: Icon = *
        // Icon instance to use for rendering the marker.
        // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
        // If not specified, a common instance of `L.Icon.Default` is used.
        icon: new gu(),
        // Option inherited from "Interactive layer" abstract class
        interactive: !0,
        // @option keyboard: Boolean = true
        // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
        keyboard: !0,
        // @option title: String = ''
        // Text for the browser tooltip that appear on marker hover (no tooltip by default).
        // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
        title: "",
        // @option alt: String = 'Marker'
        // Text for the `alt` attribute of the icon image.
        // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
        alt: "Marker",
        // @option zIndexOffset: Number = 0
        // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
        zIndexOffset: 0,
        // @option opacity: Number = 1.0
        // The opacity of the marker.
        opacity: 1,
        // @option riseOnHover: Boolean = false
        // If `true`, the marker will get on top of others when you hover the mouse over it.
        riseOnHover: !1,
        // @option riseOffset: Number = 250
        // The z-index offset used for the `riseOnHover` feature.
        riseOffset: 250,
        // @option pane: String = 'markerPane'
        // `Map pane` where the markers icon will be added.
        pane: "markerPane",
        // @option shadowPane: String = 'shadowPane'
        // `Map pane` where the markers shadow will be added.
        shadowPane: "shadowPane",
        // @option bubblingMouseEvents: Boolean = false
        // When `true`, a mouse event on this marker will trigger the same event on the map
        // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
        bubblingMouseEvents: !1,
        // @option autoPanOnFocus: Boolean = true
        // When `true`, the map will pan whenever the marker is focused (via
        // e.g. pressing `tab` on the keyboard) to ensure the marker is
        // visible within the map's bounds
        autoPanOnFocus: !0,
        // @section Draggable marker options
        // @option draggable: Boolean = false
        // Whether the marker is draggable with mouse/touch or not.
        draggable: !1,
        // @option autoPan: Boolean = false
        // Whether to pan the map when dragging this marker near its edge or not.
        autoPan: !1,
        // @option autoPanPadding: Point = Point(50, 50)
        // Distance (in pixels to the left/right and to the top/bottom) of the
        // map edge to start panning the map.
        autoPanPadding: [50, 50],
        // @option autoPanSpeed: Number = 10
        // Number of pixels the map should pan by.
        autoPanSpeed: 10
      },
      /* @section
       *
       * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
       */
      initialize: function(r, u) {
        ce(this, u), this._latlng = Oe(r);
      },
      onAdd: function(r) {
        this._zoomAnimated = this._zoomAnimated && r.options.markerZoomAnimation, this._zoomAnimated && r.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update();
      },
      onRemove: function(r) {
        this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && r.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow();
      },
      getEvents: function() {
        return {
          zoom: this.update,
          viewreset: this.update
        };
      },
      // @method getLatLng: LatLng
      // Returns the current geographical position of the marker.
      getLatLng: function() {
        return this._latlng;
      },
      // @method setLatLng(latlng: LatLng): this
      // Changes the marker position to the given point.
      setLatLng: function(r) {
        var u = this._latlng;
        return this._latlng = Oe(r), this.update(), this.fire("move", { oldLatLng: u, latlng: this._latlng });
      },
      // @method setZIndexOffset(offset: Number): this
      // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
      setZIndexOffset: function(r) {
        return this.options.zIndexOffset = r, this.update();
      },
      // @method getIcon: Icon
      // Returns the current icon used by the marker
      getIcon: function() {
        return this.options.icon;
      },
      // @method setIcon(icon: Icon): this
      // Changes the marker icon.
      setIcon: function(r) {
        return this.options.icon = r, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this;
      },
      getElement: function() {
        return this._icon;
      },
      update: function() {
        if (this._icon && this._map) {
          var r = this._map.latLngToLayerPoint(this._latlng).round();
          this._setPos(r);
        }
        return this;
      },
      _initIcon: function() {
        var r = this.options, u = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), h = r.icon.createIcon(this._icon), y = !1;
        h !== this._icon && (this._icon && this._removeIcon(), y = !0, r.title && (h.title = r.title), h.tagName === "IMG" && (h.alt = r.alt || "")), xt(h, u), r.keyboard && (h.tabIndex = "0", h.setAttribute("role", "button")), this._icon = h, r.riseOnHover && this.on({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        }), this.options.autoPanOnFocus && nt(h, "focus", this._panOnFocus, this);
        var T = r.icon.createShadow(this._shadow), D = !1;
        T !== this._shadow && (this._removeShadow(), D = !0), T && (xt(T, u), T.alt = ""), this._shadow = T, r.opacity < 1 && this._updateOpacity(), y && this.getPane().appendChild(this._icon), this._initInteraction(), T && D && this.getPane(r.shadowPane).appendChild(this._shadow);
      },
      _removeIcon: function() {
        this.options.riseOnHover && this.off({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        }), this.options.autoPanOnFocus && Mn(this._icon, "focus", this._panOnFocus, this), In(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null;
      },
      _removeShadow: function() {
        this._shadow && In(this._shadow), this._shadow = null;
      },
      _setPos: function(r) {
        this._icon && lr(this._icon, r), this._shadow && lr(this._shadow, r), this._zIndex = r.y + this.options.zIndexOffset, this._resetZIndex();
      },
      _updateZIndex: function(r) {
        this._icon && (this._icon.style.zIndex = this._zIndex + r);
      },
      _animateZoom: function(r) {
        var u = this._map._latLngToNewLayerPoint(this._latlng, r.zoom, r.center).round();
        this._setPos(u);
      },
      _initInteraction: function() {
        if (this.options.interactive && (xt(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), ul)) {
          var r = this.options.draggable;
          this.dragging && (r = this.dragging.enabled(), this.dragging.disable()), this.dragging = new ul(this), r && this.dragging.enable();
        }
      },
      // @method setOpacity(opacity: Number): this
      // Changes the opacity of the marker.
      setOpacity: function(r) {
        return this.options.opacity = r, this._map && this._updateOpacity(), this;
      },
      _updateOpacity: function() {
        var r = this.options.opacity;
        this._icon && kr(this._icon, r), this._shadow && kr(this._shadow, r);
      },
      _bringToFront: function() {
        this._updateZIndex(this.options.riseOffset);
      },
      _resetZIndex: function() {
        this._updateZIndex(0);
      },
      _panOnFocus: function() {
        var r = this._map;
        if (r) {
          var u = this.options.icon.options, h = u.iconSize ? N(u.iconSize) : N(0, 0), y = u.iconAnchor ? N(u.iconAnchor) : N(0, 0);
          r.panInside(this._latlng, {
            paddingTopLeft: y,
            paddingBottomRight: h.subtract(y)
          });
        }
      },
      _getPopupAnchor: function() {
        return this.options.icon.options.popupAnchor;
      },
      _getTooltipAnchor: function() {
        return this.options.icon.options.tooltipAnchor;
      }
    });
    function _p(r, u) {
      return new Vo(r, u);
    }
    var us = En.extend({
      // @section
      // @aka Path options
      options: {
        // @option stroke: Boolean = true
        // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
        stroke: !0,
        // @option color: String = '#3388ff'
        // Stroke color
        color: "#3388ff",
        // @option weight: Number = 3
        // Stroke width in pixels
        weight: 3,
        // @option opacity: Number = 1.0
        // Stroke opacity
        opacity: 1,
        // @option lineCap: String= 'round'
        // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
        lineCap: "round",
        // @option lineJoin: String = 'round'
        // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
        lineJoin: "round",
        // @option dashArray: String = null
        // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
        dashArray: null,
        // @option dashOffset: String = null
        // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
        dashOffset: null,
        // @option fill: Boolean = depends
        // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
        fill: !1,
        // @option fillColor: String = *
        // Fill color. Defaults to the value of the [`color`](#path-color) option
        fillColor: null,
        // @option fillOpacity: Number = 0.2
        // Fill opacity.
        fillOpacity: 0.2,
        // @option fillRule: String = 'evenodd'
        // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
        fillRule: "evenodd",
        // className: '',
        // Option inherited from "Interactive layer" abstract class
        interactive: !0,
        // @option bubblingMouseEvents: Boolean = true
        // When `true`, a mouse event on this path will trigger the same event on the map
        // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
        bubblingMouseEvents: !0
      },
      beforeAdd: function(r) {
        this._renderer = r.getRenderer(this);
      },
      onAdd: function() {
        this._renderer._initPath(this), this._reset(), this._renderer._addPath(this);
      },
      onRemove: function() {
        this._renderer._removePath(this);
      },
      // @method redraw(): this
      // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
      redraw: function() {
        return this._map && this._renderer._updatePath(this), this;
      },
      // @method setStyle(style: Path options): this
      // Changes the appearance of a Path based on the options in the `Path options` object.
      setStyle: function(r) {
        return ce(this, r), this._renderer && (this._renderer._updateStyle(this), this.options.stroke && r && Object.prototype.hasOwnProperty.call(r, "weight") && this._updateBounds()), this;
      },
      // @method bringToFront(): this
      // Brings the layer to the top of all path layers.
      bringToFront: function() {
        return this._renderer && this._renderer._bringToFront(this), this;
      },
      // @method bringToBack(): this
      // Brings the layer to the bottom of all path layers.
      bringToBack: function() {
        return this._renderer && this._renderer._bringToBack(this), this;
      },
      getElement: function() {
        return this._path;
      },
      _reset: function() {
        this._project(), this._update();
      },
      _clickTolerance: function() {
        return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
      }
    }), ll = us.extend({
      // @section
      // @aka CircleMarker options
      options: {
        fill: !0,
        // @option radius: Number = 10
        // Radius of the circle marker, in pixels
        radius: 10
      },
      initialize: function(r, u) {
        ce(this, u), this._latlng = Oe(r), this._radius = this.options.radius;
      },
      // @method setLatLng(latLng: LatLng): this
      // Sets the position of a circle marker to a new location.
      setLatLng: function(r) {
        var u = this._latlng;
        return this._latlng = Oe(r), this.redraw(), this.fire("move", { oldLatLng: u, latlng: this._latlng });
      },
      // @method getLatLng(): LatLng
      // Returns the current geographical position of the circle marker
      getLatLng: function() {
        return this._latlng;
      },
      // @method setRadius(radius: Number): this
      // Sets the radius of a circle marker. Units are in pixels.
      setRadius: function(r) {
        return this.options.radius = this._radius = r, this.redraw();
      },
      // @method getRadius(): Number
      // Returns the current radius of the circle
      getRadius: function() {
        return this._radius;
      },
      setStyle: function(r) {
        var u = r && r.radius || this._radius;
        return us.prototype.setStyle.call(this, r), this.setRadius(u), this;
      },
      _project: function() {
        this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds();
      },
      _updateBounds: function() {
        var r = this._radius, u = this._radiusY || r, h = this._clickTolerance(), y = [r + h, u + h];
        this._pxBounds = new se(this._point.subtract(y), this._point.add(y));
      },
      _update: function() {
        this._map && this._updatePath();
      },
      _updatePath: function() {
        this._renderer._updateCircle(this);
      },
      _empty: function() {
        return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
      },
      // Needed by the `Canvas` renderer for interactivity
      _containsPoint: function(r) {
        return r.distanceTo(this._point) <= this._radius + this._clickTolerance();
      }
    });
    function xd(r, u) {
      return new ll(r, u);
    }
    var dc = ll.extend({
      initialize: function(r, u, h) {
        if (typeof u == "number" && (u = w({}, h, { radius: u })), ce(this, u), this._latlng = Oe(r), isNaN(this.options.radius))
          throw new Error("Circle radius cannot be NaN");
        this._mRadius = this.options.radius;
      },
      // @method setRadius(radius: Number): this
      // Sets the radius of a circle. Units are in meters.
      setRadius: function(r) {
        return this._mRadius = r, this.redraw();
      },
      // @method getRadius(): Number
      // Returns the current radius of a circle. Units are in meters.
      getRadius: function() {
        return this._mRadius;
      },
      // @method getBounds(): LatLngBounds
      // Returns the `LatLngBounds` of the path.
      getBounds: function() {
        var r = [this._radius, this._radiusY || this._radius];
        return new et(
          this._map.layerPointToLatLng(this._point.subtract(r)),
          this._map.layerPointToLatLng(this._point.add(r))
        );
      },
      setStyle: us.prototype.setStyle,
      _project: function() {
        var r = this._latlng.lng, u = this._latlng.lat, h = this._map, y = h.options.crs;
        if (y.distance === _t.distance) {
          var T = Math.PI / 180, D = this._mRadius / _t.R / T, I = h.project([u + D, r]), Q = h.project([u - D, r]), ie = I.add(Q).divideBy(2), ge = h.unproject(ie).lat, Fe = Math.acos((Math.cos(D * T) - Math.sin(u * T) * Math.sin(ge * T)) / (Math.cos(u * T) * Math.cos(ge * T))) / T;
          (isNaN(Fe) || Fe === 0) && (Fe = D / Math.cos(Math.PI / 180 * u)), this._point = ie.subtract(h.getPixelOrigin()), this._radius = isNaN(Fe) ? 0 : ie.x - h.project([ge, r - Fe]).x, this._radiusY = ie.y - I.y;
        } else {
          var ht = y.unproject(y.project(this._latlng).subtract([this._mRadius, 0]));
          this._point = h.latLngToLayerPoint(this._latlng), this._radius = this._point.x - h.latLngToLayerPoint(ht).x;
        }
        this._updateBounds();
      }
    });
    function cl(r, u, h) {
      return new dc(r, u, h);
    }
    var Ni = us.extend({
      // @section
      // @aka Polyline options
      options: {
        // @option smoothFactor: Number = 1.0
        // How much to simplify the polyline on each zoom level. More means
        // better performance and smoother look, and less means more accurate representation.
        smoothFactor: 1,
        // @option noClip: Boolean = false
        // Disable polyline clipping.
        noClip: !1
      },
      initialize: function(r, u) {
        ce(this, u), this._setLatLngs(r);
      },
      // @method getLatLngs(): LatLng[]
      // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
      getLatLngs: function() {
        return this._latlngs;
      },
      // @method setLatLngs(latlngs: LatLng[]): this
      // Replaces all the points in the polyline with the given array of geographical points.
      setLatLngs: function(r) {
        return this._setLatLngs(r), this.redraw();
      },
      // @method isEmpty(): Boolean
      // Returns `true` if the Polyline has no LatLngs.
      isEmpty: function() {
        return !this._latlngs.length;
      },
      // @method closestLayerPoint(p: Point): Point
      // Returns the point closest to `p` on the Polyline.
      closestLayerPoint: function(r) {
        for (var u = 1 / 0, h = null, y = Us, T, D, I = 0, Q = this._parts.length; I < Q; I++)
          for (var ie = this._parts[I], ge = 1, Fe = ie.length; ge < Fe; ge++) {
            T = ie[ge - 1], D = ie[ge];
            var ht = y(r, T, D, !0);
            ht < u && (u = ht, h = y(r, T, D));
          }
        return h && (h.distance = Math.sqrt(u)), h;
      },
      // @method getCenter(): LatLng
      // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
      getCenter: function() {
        if (!this._map)
          throw new Error("Must add layer to map before using getCenter()");
        return lc(this._defaultShape(), this._map.options.crs);
      },
      // @method getBounds(): LatLngBounds
      // Returns the `LatLngBounds` of the path.
      getBounds: function() {
        return this._bounds;
      },
      // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
      // Adds a given point to the polyline. By default, adds to the first ring of
      // the polyline in case of a multi-polyline, but can be overridden by passing
      // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
      addLatLng: function(r, u) {
        return u = u || this._defaultShape(), r = Oe(r), u.push(r), this._bounds.extend(r), this.redraw();
      },
      _setLatLngs: function(r) {
        this._bounds = new et(), this._latlngs = this._convertLatLngs(r);
      },
      _defaultShape: function() {
        return Tr(this._latlngs) ? this._latlngs : this._latlngs[0];
      },
      // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
      _convertLatLngs: function(r) {
        for (var u = [], h = Tr(r), y = 0, T = r.length; y < T; y++)
          h ? (u[y] = Oe(r[y]), this._bounds.extend(u[y])) : u[y] = this._convertLatLngs(r[y]);
        return u;
      },
      _project: function() {
        var r = new se();
        this._rings = [], this._projectLatlngs(this._latlngs, this._rings, r), this._bounds.isValid() && r.isValid() && (this._rawPxBounds = r, this._updateBounds());
      },
      _updateBounds: function() {
        var r = this._clickTolerance(), u = new le(r, r);
        this._rawPxBounds && (this._pxBounds = new se([
          this._rawPxBounds.min.subtract(u),
          this._rawPxBounds.max.add(u)
        ]));
      },
      // recursively turns latlngs into a set of rings with projected coordinates
      _projectLatlngs: function(r, u, h) {
        var y = r[0] instanceof qe, T = r.length, D, I;
        if (y) {
          for (I = [], D = 0; D < T; D++)
            I[D] = this._map.latLngToLayerPoint(r[D]), h.extend(I[D]);
          u.push(I);
        } else
          for (D = 0; D < T; D++)
            this._projectLatlngs(r[D], u, h);
      },
      // clip polyline by renderer bounds so that we have less to render for performance
      _clipPoints: function() {
        var r = this._renderer._bounds;
        if (this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(r))) {
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          var u = this._parts, h, y, T, D, I, Q, ie;
          for (h = 0, T = 0, D = this._rings.length; h < D; h++)
            for (ie = this._rings[h], y = 0, I = ie.length; y < I - 1; y++)
              Q = uc(ie[y], ie[y + 1], r, y, !0), Q && (u[T] = u[T] || [], u[T].push(Q[0]), (Q[1] !== ie[y + 1] || y === I - 2) && (u[T].push(Q[1]), T++));
        }
      },
      // simplify each clipped part of the polyline for performance
      _simplifyPoints: function() {
        for (var r = this._parts, u = this.options.smoothFactor, h = 0, y = r.length; h < y; h++)
          r[h] = oa(r[h], u);
      },
      _update: function() {
        this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath());
      },
      _updatePath: function() {
        this._renderer._updatePoly(this);
      },
      // Needed by the `Canvas` renderer for interactivity
      _containsPoint: function(r, u) {
        var h, y, T, D, I, Q, ie = this._clickTolerance();
        if (!this._pxBounds || !this._pxBounds.contains(r))
          return !1;
        for (h = 0, D = this._parts.length; h < D; h++)
          for (Q = this._parts[h], y = 0, I = Q.length, T = I - 1; y < I; T = y++)
            if (!(!u && y === 0) && yu(r, Q[T], Q[y]) <= ie)
              return !0;
        return !1;
      }
    });
    function _u(r, u) {
      return new Ni(r, u);
    }
    Ni._flat = wd;
    var Pa = Ni.extend({
      options: {
        fill: !0
      },
      isEmpty: function() {
        return !this._latlngs.length || !this._latlngs[0].length;
      },
      // @method getCenter(): LatLng
      // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
      getCenter: function() {
        if (!this._map)
          throw new Error("Must add layer to map before using getCenter()");
        return As(this._defaultShape(), this._map.options.crs);
      },
      _convertLatLngs: function(r) {
        var u = Ni.prototype._convertLatLngs.call(this, r), h = u.length;
        return h >= 2 && u[0] instanceof qe && u[0].equals(u[h - 1]) && u.pop(), u;
      },
      _setLatLngs: function(r) {
        Ni.prototype._setLatLngs.call(this, r), Tr(this._latlngs) && (this._latlngs = [this._latlngs]);
      },
      _defaultShape: function() {
        return Tr(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
      },
      _clipPoints: function() {
        var r = this._renderer._bounds, u = this.options.weight, h = new le(u, u);
        if (r = new se(r.min.subtract(h), r.max.add(h)), this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(r))) {
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          for (var y = 0, T = this._rings.length, D; y < T; y++)
            D = lo(this._rings[y], r, !0), D.length && this._parts.push(D);
        }
      },
      _updatePath: function() {
        this._renderer._updatePoly(this, !0);
      },
      // Needed by the `Canvas` renderer for interactivity
      _containsPoint: function(r) {
        var u = !1, h, y, T, D, I, Q, ie, ge;
        if (!this._pxBounds || !this._pxBounds.contains(r))
          return !1;
        for (D = 0, ie = this._parts.length; D < ie; D++)
          for (h = this._parts[D], I = 0, ge = h.length, Q = ge - 1; I < ge; Q = I++)
            y = h[I], T = h[Q], y.y > r.y != T.y > r.y && r.x < (T.x - y.x) * (r.y - y.y) / (T.y - y.y) + y.x && (u = !u);
        return u || Ni.prototype._containsPoint.call(this, r, !0);
      }
    });
    function bd(r, u) {
      return new Pa(r, u);
    }
    var Aa = sa.extend({
      /* @section
       * @aka GeoJSON options
       *
       * @option pointToLayer: Function = *
       * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
       * called when data is added, passing the GeoJSON point feature and its `LatLng`.
       * The default is to spawn a default `Marker`:
       * ```js
       * function(geoJsonPoint, latlng) {
       * 	return L.marker(latlng);
       * }
       * ```
       *
       * @option style: Function = *
       * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
       * called internally when data is added.
       * The default value is to not override any defaults:
       * ```js
       * function (geoJsonFeature) {
       * 	return {}
       * }
       * ```
       *
       * @option onEachFeature: Function = *
       * A `Function` that will be called once for each created `Feature`, after it has
       * been created and styled. Useful for attaching events and popups to features.
       * The default is to do nothing with the newly created layers:
       * ```js
       * function (feature, layer) {}
       * ```
       *
       * @option filter: Function = *
       * A `Function` that will be used to decide whether to include a feature or not.
       * The default is to include all features:
       * ```js
       * function (geoJsonFeature) {
       * 	return true;
       * }
       * ```
       * Note: dynamically changing the `filter` option will have effect only on newly
       * added data. It will _not_ re-evaluate already included features.
       *
       * @option coordsToLatLng: Function = *
       * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
       * The default is the `coordsToLatLng` static method.
       *
       * @option markersInheritOptions: Boolean = false
       * Whether default Markers for "Point" type Features inherit from group options.
       */
      initialize: function(r, u) {
        ce(this, u), this._layers = {}, r && this.addData(r);
      },
      // @method addData( <GeoJSON> data ): this
      // Adds a GeoJSON object to the layer.
      addData: function(r) {
        var u = ve(r) ? r : r.features, h, y, T;
        if (u) {
          for (h = 0, y = u.length; h < y; h++)
            T = u[h], (T.geometries || T.geometry || T.features || T.coordinates) && this.addData(T);
          return this;
        }
        var D = this.options;
        if (D.filter && !D.filter(r))
          return this;
        var I = Su(r, D);
        return I ? (I.feature = yc(r), I.defaultOptions = I.options, this.resetStyle(I), D.onEachFeature && D.onEachFeature(r, I), this.addLayer(I)) : this;
      },
      // @method resetStyle( <Path> layer? ): this
      // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
      // If `layer` is omitted, the style of all features in the current layer is reset.
      resetStyle: function(r) {
        return r === void 0 ? this.eachLayer(this.resetStyle, this) : (r.options = w({}, r.defaultOptions), this._setLayerStyle(r, this.options.style), this);
      },
      // @method setStyle( <Function> style ): this
      // Changes styles of GeoJSON vector layers with the given style function.
      setStyle: function(r) {
        return this.eachLayer(function(u) {
          this._setLayerStyle(u, r);
        }, this);
      },
      _setLayerStyle: function(r, u) {
        r.setStyle && (typeof u == "function" && (u = u(r.feature)), r.setStyle(u));
      }
    });
    function Su(r, u) {
      var h = r.type === "Feature" ? r.geometry : r, y = h ? h.coordinates : null, T = [], D = u && u.pointToLayer, I = u && u.coordsToLatLng || pc, Q, ie, ge, Fe;
      if (!y && !h)
        return null;
      switch (h.type) {
        case "Point":
          return Q = I(y), hc(D, r, Q, u);
        case "MultiPoint":
          for (ge = 0, Fe = y.length; ge < Fe; ge++)
            Q = I(y[ge]), T.push(hc(D, r, Q, u));
          return new sa(T);
        case "LineString":
        case "MultiLineString":
          return ie = fl(y, h.type === "LineString" ? 0 : 1, I), new Ni(ie, u);
        case "Polygon":
        case "MultiPolygon":
          return ie = fl(y, h.type === "Polygon" ? 1 : 2, I), new Pa(ie, u);
        case "GeometryCollection":
          for (ge = 0, Fe = h.geometries.length; ge < Fe; ge++) {
            var ht = Su({
              geometry: h.geometries[ge],
              type: "Feature",
              properties: r.properties
            }, u);
            ht && T.push(ht);
          }
          return new sa(T);
        case "FeatureCollection":
          for (ge = 0, Fe = h.features.length; ge < Fe; ge++) {
            var Vt = Su(h.features[ge], u);
            Vt && T.push(Vt);
          }
          return new sa(T);
        default:
          throw new Error("Invalid GeoJSON object.");
      }
    }
    function hc(r, u, h, y) {
      return r ? r(u, h) : new Vo(h, y && y.markersInheritOptions && y);
    }
    function pc(r) {
      return new qe(r[1], r[0], r[2]);
    }
    function fl(r, u, h) {
      for (var y = [], T = 0, D = r.length, I; T < D; T++)
        I = u ? fl(r[T], u - 1, h) : (h || pc)(r[T]), y.push(I);
      return y;
    }
    function vc(r, u) {
      return r = Oe(r), r.alt !== void 0 ? [$(r.lng, u), $(r.lat, u), $(r.alt, u)] : [$(r.lng, u), $(r.lat, u)];
    }
    function mc(r, u, h, y) {
      for (var T = [], D = 0, I = r.length; D < I; D++)
        T.push(u ? mc(r[D], Tr(r[D]) ? 0 : u - 1, h, y) : vc(r[D], y));
      return !u && h && T.length > 0 && T.push(T[0].slice()), T;
    }
    function wu(r, u) {
      return r.feature ? w({}, r.feature, { geometry: u }) : yc(u);
    }
    function yc(r) {
      return r.type === "Feature" || r.type === "FeatureCollection" ? r : {
        type: "Feature",
        properties: {},
        geometry: r
      };
    }
    var gc = {
      toGeoJSON: function(r) {
        return wu(this, {
          type: "Point",
          coordinates: vc(this.getLatLng(), r)
        });
      }
    };
    Vo.include(gc), dc.include(gc), ll.include(gc), Ni.include({
      toGeoJSON: function(r) {
        var u = !Tr(this._latlngs), h = mc(this._latlngs, u ? 1 : 0, !1, r);
        return wu(this, {
          type: (u ? "Multi" : "") + "LineString",
          coordinates: h
        });
      }
    }), Pa.include({
      toGeoJSON: function(r) {
        var u = !Tr(this._latlngs), h = u && !Tr(this._latlngs[0]), y = mc(this._latlngs, h ? 2 : u ? 1 : 0, !0, r);
        return u || (y = [y]), wu(this, {
          type: (h ? "Multi" : "") + "Polygon",
          coordinates: y
        });
      }
    }), ri.include({
      toMultiPoint: function(r) {
        var u = [];
        return this.eachLayer(function(h) {
          u.push(h.toGeoJSON(r).geometry.coordinates);
        }), wu(this, {
          type: "MultiPoint",
          coordinates: u
        });
      },
      // @method toGeoJSON(precision?: Number|false): Object
      // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
      // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
      toGeoJSON: function(r) {
        var u = this.feature && this.feature.geometry && this.feature.geometry.type;
        if (u === "MultiPoint")
          return this.toMultiPoint(r);
        var h = u === "GeometryCollection", y = [];
        return this.eachLayer(function(T) {
          if (T.toGeoJSON) {
            var D = T.toGeoJSON(r);
            if (h)
              y.push(D.geometry);
            else {
              var I = yc(D);
              I.type === "FeatureCollection" ? y.push.apply(y, I.features) : y.push(I);
            }
          }
        }), h ? wu(this, {
          geometries: y,
          type: "GeometryCollection"
        }) : {
          type: "FeatureCollection",
          features: y
        };
      }
    });
    function Md(r, u) {
      return new Aa(r, u);
    }
    var ua = Md, ls = En.extend({
      // @section
      // @aka ImageOverlay options
      options: {
        // @option opacity: Number = 1.0
        // The opacity of the image overlay.
        opacity: 1,
        // @option alt: String = ''
        // Text for the `alt` attribute of the image (useful for accessibility).
        alt: "",
        // @option interactive: Boolean = false
        // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
        interactive: !1,
        // @option crossOrigin: Boolean|String = false
        // Whether the crossOrigin attribute will be added to the image.
        // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
        // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
        crossOrigin: !1,
        // @option errorOverlayUrl: String = ''
        // URL to the overlay image to show in place of the overlay that failed to load.
        errorOverlayUrl: "",
        // @option zIndex: Number = 1
        // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
        zIndex: 1,
        // @option className: String = ''
        // A custom class name to assign to the image. Empty by default.
        className: ""
      },
      initialize: function(r, u, h) {
        this._url = r, this._bounds = je(u), ce(this, h);
      },
      onAdd: function() {
        this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (xt(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset();
      },
      onRemove: function() {
        In(this._image), this.options.interactive && this.removeInteractiveTarget(this._image);
      },
      // @method setOpacity(opacity: Number): this
      // Sets the opacity of the overlay.
      setOpacity: function(r) {
        return this.options.opacity = r, this._image && this._updateOpacity(), this;
      },
      setStyle: function(r) {
        return r.opacity && this.setOpacity(r.opacity), this;
      },
      // @method bringToFront(): this
      // Brings the layer to the top of all overlays.
      bringToFront: function() {
        return this._map && zo(this._image), this;
      },
      // @method bringToBack(): this
      // Brings the layer to the bottom of all overlays.
      bringToBack: function() {
        return this._map && ka(this._image), this;
      },
      // @method setUrl(url: String): this
      // Changes the URL of the image.
      setUrl: function(r) {
        return this._url = r, this._image && (this._image.src = r), this;
      },
      // @method setBounds(bounds: LatLngBounds): this
      // Update the bounds that this ImageOverlay covers
      setBounds: function(r) {
        return this._bounds = je(r), this._map && this._reset(), this;
      },
      getEvents: function() {
        var r = {
          zoom: this._reset,
          viewreset: this._reset
        };
        return this._zoomAnimated && (r.zoomanim = this._animateZoom), r;
      },
      // @method setZIndex(value: Number): this
      // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
      setZIndex: function(r) {
        return this.options.zIndex = r, this._updateZIndex(), this;
      },
      // @method getBounds(): LatLngBounds
      // Get the bounds that this ImageOverlay covers
      getBounds: function() {
        return this._bounds;
      },
      // @method getElement(): HTMLElement
      // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
      // used by this overlay.
      getElement: function() {
        return this._image;
      },
      _initImage: function() {
        var r = this._url.tagName === "IMG", u = this._image = r ? this._url : Pt("img");
        if (xt(u, "leaflet-image-layer"), this._zoomAnimated && xt(u, "leaflet-zoom-animated"), this.options.className && xt(u, this.options.className), u.onselectstart = H, u.onmousemove = H, u.onload = C(this.fire, this, "load"), u.onerror = C(this._overlayOnError, this, "error"), (this.options.crossOrigin || this.options.crossOrigin === "") && (u.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), r) {
          this._url = u.src;
          return;
        }
        u.src = this._url, u.alt = this.options.alt;
      },
      _animateZoom: function(r) {
        var u = this._map.getZoomScale(r.zoom), h = this._map._latLngBoundsToNewLayerBounds(this._bounds, r.zoom, r.center).min;
        hi(this._image, h, u);
      },
      _reset: function() {
        var r = this._image, u = new se(
          this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
          this._map.latLngToLayerPoint(this._bounds.getSouthEast())
        ), h = u.getSize();
        lr(r, u.min), r.style.width = h.x + "px", r.style.height = h.y + "px";
      },
      _updateOpacity: function() {
        kr(this._image, this.options.opacity);
      },
      _updateZIndex: function() {
        this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._image.style.zIndex = this.options.zIndex);
      },
      _overlayOnError: function() {
        this.fire("error");
        var r = this.options.errorOverlayUrl;
        r && this._url !== r && (this._url = r, this._image.src = r);
      },
      // @method getCenter(): LatLng
      // Returns the center of the ImageOverlay.
      getCenter: function() {
        return this._bounds.getCenter();
      }
    }), Rd = function(r, u, h) {
      return new ls(r, u, h);
    }, Ef = ls.extend({
      // @section
      // @aka VideoOverlay options
      options: {
        // @option autoplay: Boolean = true
        // Whether the video starts playing automatically when loaded.
        // On some browsers autoplay will only work with `muted: true`
        autoplay: !0,
        // @option loop: Boolean = true
        // Whether the video will loop back to the beginning when played.
        loop: !0,
        // @option keepAspectRatio: Boolean = true
        // Whether the video will save aspect ratio after the projection.
        // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
        keepAspectRatio: !0,
        // @option muted: Boolean = false
        // Whether the video starts on mute when loaded.
        muted: !1,
        // @option playsInline: Boolean = true
        // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
        playsInline: !0
      },
      _initImage: function() {
        var r = this._url.tagName === "VIDEO", u = this._image = r ? this._url : Pt("video");
        if (xt(u, "leaflet-image-layer"), this._zoomAnimated && xt(u, "leaflet-zoom-animated"), this.options.className && xt(u, this.options.className), u.onselectstart = H, u.onmousemove = H, u.onloadeddata = C(this.fire, this, "load"), r) {
          for (var h = u.getElementsByTagName("source"), y = [], T = 0; T < h.length; T++)
            y.push(h[T].src);
          this._url = h.length > 0 ? y : [u.src];
          return;
        }
        ve(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(u.style, "objectFit") && (u.style.objectFit = "fill"), u.autoplay = !!this.options.autoplay, u.loop = !!this.options.loop, u.muted = !!this.options.muted, u.playsInline = !!this.options.playsInline;
        for (var D = 0; D < this._url.length; D++) {
          var I = Pt("source");
          I.src = this._url[D], u.appendChild(I);
        }
      }
      // @method getElement(): HTMLVideoElement
      // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
      // used by this overlay.
    });
    function Dd(r, u, h) {
      return new Ef(r, u, h);
    }
    var dl = ls.extend({
      _initImage: function() {
        var r = this._image = this._url;
        xt(r, "leaflet-image-layer"), this._zoomAnimated && xt(r, "leaflet-zoom-animated"), this.options.className && xt(r, this.options.className), r.onselectstart = H, r.onmousemove = H;
      }
      // @method getElement(): SVGElement
      // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
      // used by this overlay.
    });
    function Wo(r, u, h) {
      return new dl(r, u, h);
    }
    var $i = En.extend({
      // @section
      // @aka DivOverlay options
      options: {
        // @option interactive: Boolean = false
        // If true, the popup/tooltip will listen to the mouse events.
        interactive: !1,
        // @option offset: Point = Point(0, 0)
        // The offset of the overlay position.
        offset: [0, 0],
        // @option className: String = ''
        // A custom CSS class name to assign to the overlay.
        className: "",
        // @option pane: String = undefined
        // `Map pane` where the overlay will be added.
        pane: void 0,
        // @option content: String|HTMLElement|Function = ''
        // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
        // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
        content: ""
      },
      initialize: function(r, u) {
        r && (r instanceof qe || ve(r)) ? (this._latlng = Oe(r), ce(this, u)) : (ce(this, r), this._source = u), this.options.content && (this._content = this.options.content);
      },
      // @method openOn(map: Map): this
      // Adds the overlay to the map.
      // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
      openOn: function(r) {
        return r = arguments.length ? r : this._source._map, r.hasLayer(this) || r.addLayer(this), this;
      },
      // @method close(): this
      // Closes the overlay.
      // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
      // and `layer.closePopup()`/`.closeTooltip()`.
      close: function() {
        return this._map && this._map.removeLayer(this), this;
      },
      // @method toggle(layer?: Layer): this
      // Opens or closes the overlay bound to layer depending on its current state.
      // Argument may be omitted only for overlay bound to layer.
      // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
      toggle: function(r) {
        return this._map ? this.close() : (arguments.length ? this._source = r : r = this._source, this._prepareOpen(), this.openOn(r._map)), this;
      },
      onAdd: function(r) {
        this._zoomAnimated = r._zoomAnimated, this._container || this._initLayout(), r._fadeAnimated && kr(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), r._fadeAnimated && kr(this._container, 1), this.bringToFront(), this.options.interactive && (xt(this._container, "leaflet-interactive"), this.addInteractiveTarget(this._container));
      },
      onRemove: function(r) {
        r._fadeAnimated ? (kr(this._container, 0), this._removeTimeout = setTimeout(C(In, void 0, this._container), 200)) : In(this._container), this.options.interactive && (sn(this._container, "leaflet-interactive"), this.removeInteractiveTarget(this._container));
      },
      // @namespace DivOverlay
      // @method getLatLng: LatLng
      // Returns the geographical point of the overlay.
      getLatLng: function() {
        return this._latlng;
      },
      // @method setLatLng(latlng: LatLng): this
      // Sets the geographical point where the overlay will open.
      setLatLng: function(r) {
        return this._latlng = Oe(r), this._map && (this._updatePosition(), this._adjustPan()), this;
      },
      // @method getContent: String|HTMLElement
      // Returns the content of the overlay.
      getContent: function() {
        return this._content;
      },
      // @method setContent(htmlContent: String|HTMLElement|Function): this
      // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
      // The function should return a `String` or `HTMLElement` to be used in the overlay.
      setContent: function(r) {
        return this._content = r, this.update(), this;
      },
      // @method getElement: String|HTMLElement
      // Returns the HTML container of the overlay.
      getElement: function() {
        return this._container;
      },
      // @method update: null
      // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
      update: function() {
        this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan());
      },
      getEvents: function() {
        var r = {
          zoom: this._updatePosition,
          viewreset: this._updatePosition
        };
        return this._zoomAnimated && (r.zoomanim = this._animateZoom), r;
      },
      // @method isOpen: Boolean
      // Returns `true` when the overlay is visible on the map.
      isOpen: function() {
        return !!this._map && this._map.hasLayer(this);
      },
      // @method bringToFront: this
      // Brings this overlay in front of other overlays (in the same map pane).
      bringToFront: function() {
        return this._map && zo(this._container), this;
      },
      // @method bringToBack: this
      // Brings this overlay to the back of other overlays (in the same map pane).
      bringToBack: function() {
        return this._map && ka(this._container), this;
      },
      // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
      _prepareOpen: function(r) {
        var u = this._source;
        if (!u._map)
          return !1;
        if (u instanceof sa) {
          u = null;
          var h = this._source._layers;
          for (var y in h)
            if (h[y]._map) {
              u = h[y];
              break;
            }
          if (!u)
            return !1;
          this._source = u;
        }
        if (!r)
          if (u.getCenter)
            r = u.getCenter();
          else if (u.getLatLng)
            r = u.getLatLng();
          else if (u.getBounds)
            r = u.getBounds().getCenter();
          else
            throw new Error("Unable to get source layer LatLng.");
        return this.setLatLng(r), this._map && this.update(), !0;
      },
      _updateContent: function() {
        if (this._content) {
          var r = this._contentNode, u = typeof this._content == "function" ? this._content(this._source || this) : this._content;
          if (typeof u == "string")
            r.innerHTML = u;
          else {
            for (; r.hasChildNodes(); )
              r.removeChild(r.firstChild);
            r.appendChild(u);
          }
          this.fire("contentupdate");
        }
      },
      _updatePosition: function() {
        if (this._map) {
          var r = this._map.latLngToLayerPoint(this._latlng), u = N(this.options.offset), h = this._getAnchor();
          this._zoomAnimated ? lr(this._container, r.add(h)) : u = u.add(r).add(h);
          var y = this._containerBottom = -u.y, T = this._containerLeft = -Math.round(this._containerWidth / 2) + u.x;
          this._container.style.bottom = y + "px", this._container.style.left = T + "px";
        }
      },
      _getAnchor: function() {
        return [0, 0];
      }
    });
    Kt.include({
      _initOverlay: function(r, u, h, y) {
        var T = u;
        return T instanceof r || (T = new r(y).setContent(u)), h && T.setLatLng(h), T;
      }
    }), En.include({
      _initOverlay: function(r, u, h, y) {
        var T = h;
        return T instanceof r ? (ce(T, y), T._source = this) : (T = u && !y ? u : new r(y, this), T.setContent(h)), T;
      }
    });
    var hl = $i.extend({
      // @section
      // @aka Popup options
      options: {
        // @option pane: String = 'popupPane'
        // `Map pane` where the popup will be added.
        pane: "popupPane",
        // @option offset: Point = Point(0, 7)
        // The offset of the popup position.
        offset: [0, 7],
        // @option maxWidth: Number = 300
        // Max width of the popup, in pixels.
        maxWidth: 300,
        // @option minWidth: Number = 50
        // Min width of the popup, in pixels.
        minWidth: 50,
        // @option maxHeight: Number = null
        // If set, creates a scrollable container of the given height
        // inside a popup if its content exceeds it.
        // The scrollable container can be styled using the
        // `leaflet-popup-scrolled` CSS class selector.
        maxHeight: null,
        // @option autoPan: Boolean = true
        // Set it to `false` if you don't want the map to do panning animation
        // to fit the opened popup.
        autoPan: !0,
        // @option autoPanPaddingTopLeft: Point = null
        // The margin between the popup and the top left corner of the map
        // view after autopanning was performed.
        autoPanPaddingTopLeft: null,
        // @option autoPanPaddingBottomRight: Point = null
        // The margin between the popup and the bottom right corner of the map
        // view after autopanning was performed.
        autoPanPaddingBottomRight: null,
        // @option autoPanPadding: Point = Point(5, 5)
        // Equivalent of setting both top left and bottom right autopan padding to the same value.
        autoPanPadding: [5, 5],
        // @option keepInView: Boolean = false
        // Set it to `true` if you want to prevent users from panning the popup
        // off of the screen while it is open.
        keepInView: !1,
        // @option closeButton: Boolean = true
        // Controls the presence of a close button in the popup.
        closeButton: !0,
        // @option autoClose: Boolean = true
        // Set it to `false` if you want to override the default behavior of
        // the popup closing when another popup is opened.
        autoClose: !0,
        // @option closeOnEscapeKey: Boolean = true
        // Set it to `false` if you want to override the default behavior of
        // the ESC key for closing of the popup.
        closeOnEscapeKey: !0,
        // @option closeOnClick: Boolean = *
        // Set it if you want to override the default behavior of the popup closing when user clicks
        // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
        // @option className: String = ''
        // A custom CSS class name to assign to the popup.
        className: ""
      },
      // @namespace Popup
      // @method openOn(map: Map): this
      // Alternative to `map.openPopup(popup)`.
      // Adds the popup to the map and closes the previous one.
      openOn: function(r) {
        return r = arguments.length ? r : this._source._map, !r.hasLayer(this) && r._popup && r._popup.options.autoClose && r.removeLayer(r._popup), r._popup = this, $i.prototype.openOn.call(this, r);
      },
      onAdd: function(r) {
        $i.prototype.onAdd.call(this, r), r.fire("popupopen", { popup: this }), this._source && (this._source.fire("popupopen", { popup: this }, !0), this._source instanceof us || this._source.on("preclick", mi));
      },
      onRemove: function(r) {
        $i.prototype.onRemove.call(this, r), r.fire("popupclose", { popup: this }), this._source && (this._source.fire("popupclose", { popup: this }, !0), this._source instanceof us || this._source.off("preclick", mi));
      },
      getEvents: function() {
        var r = $i.prototype.getEvents.call(this);
        return (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (r.preclick = this.close), this.options.keepInView && (r.moveend = this._adjustPan), r;
      },
      _initLayout: function() {
        var r = "leaflet-popup", u = this._container = Pt(
          "div",
          r + " " + (this.options.className || "") + " leaflet-zoom-animated"
        ), h = this._wrapper = Pt("div", r + "-content-wrapper", u);
        if (this._contentNode = Pt("div", r + "-content", h), os(u), so(this._contentNode), nt(u, "contextmenu", mi), this._tipContainer = Pt("div", r + "-tip-container", u), this._tip = Pt("div", r + "-tip", this._tipContainer), this.options.closeButton) {
          var y = this._closeButton = Pt("a", r + "-close-button", u);
          y.setAttribute("role", "button"), y.setAttribute("aria-label", "Close popup"), y.href = "#close", y.innerHTML = '<span aria-hidden="true">&#215;</span>', nt(y, "click", function(T) {
            Dn(T), this.close();
          }, this);
        }
      },
      _updateLayout: function() {
        var r = this._contentNode, u = r.style;
        u.width = "", u.whiteSpace = "nowrap";
        var h = r.offsetWidth;
        h = Math.min(h, this.options.maxWidth), h = Math.max(h, this.options.minWidth), u.width = h + 1 + "px", u.whiteSpace = "", u.height = "";
        var y = r.offsetHeight, T = this.options.maxHeight, D = "leaflet-popup-scrolled";
        T && y > T ? (u.height = T + "px", xt(r, D)) : sn(r, D), this._containerWidth = this._container.offsetWidth;
      },
      _animateZoom: function(r) {
        var u = this._map._latLngToNewLayerPoint(this._latlng, r.zoom, r.center), h = this._getAnchor();
        lr(this._container, u.add(h));
      },
      _adjustPan: function() {
        if (this.options.autoPan) {
          if (this._map._panAnim && this._map._panAnim.stop(), this._autopanning) {
            this._autopanning = !1;
            return;
          }
          var r = this._map, u = parseInt(Ao(this._container, "marginBottom"), 10) || 0, h = this._container.offsetHeight + u, y = this._containerWidth, T = new le(this._containerLeft, -h - this._containerBottom);
          T._add(ni(this._container));
          var D = r.layerPointToContainerPoint(T), I = N(this.options.autoPanPadding), Q = N(this.options.autoPanPaddingTopLeft || I), ie = N(this.options.autoPanPaddingBottomRight || I), ge = r.getSize(), Fe = 0, ht = 0;
          D.x + y + ie.x > ge.x && (Fe = D.x + y - ge.x + ie.x), D.x - Fe - Q.x < 0 && (Fe = D.x - Q.x), D.y + h + ie.y > ge.y && (ht = D.y + h - ge.y + ie.y), D.y - ht - Q.y < 0 && (ht = D.y - Q.y), (Fe || ht) && (this.options.keepInView && (this._autopanning = !0), r.fire("autopanstart").panBy([Fe, ht]));
        }
      },
      _getAnchor: function() {
        return N(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
      }
    }), za = function(r, u) {
      return new hl(r, u);
    };
    Kt.mergeOptions({
      closePopupOnClick: !0
    }), Kt.include({
      // @method openPopup(popup: Popup): this
      // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
      // @alternative
      // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
      // Creates a popup with the specified content and options and opens it in the given point on a map.
      openPopup: function(r, u, h) {
        return this._initOverlay(hl, r, u, h).openOn(this), this;
      },
      // @method closePopup(popup?: Popup): this
      // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
      closePopup: function(r) {
        return r = arguments.length ? r : this._popup, r && r.close(), this;
      }
    }), En.include({
      // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
      // Binds a popup to the layer with the passed `content` and sets up the
      // necessary event listeners. If a `Function` is passed it will receive
      // the layer as the first argument and should return a `String` or `HTMLElement`.
      bindPopup: function(r, u) {
        return this._popup = this._initOverlay(hl, this._popup, r, u), this._popupHandlersAdded || (this.on({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup
        }), this._popupHandlersAdded = !0), this;
      },
      // @method unbindPopup(): this
      // Removes the popup previously bound with `bindPopup`.
      unbindPopup: function() {
        return this._popup && (this.off({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup
        }), this._popupHandlersAdded = !1, this._popup = null), this;
      },
      // @method openPopup(latlng?: LatLng): this
      // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
      openPopup: function(r) {
        return this._popup && (this instanceof sa || (this._popup._source = this), this._popup._prepareOpen(r || this._latlng) && this._popup.openOn(this._map)), this;
      },
      // @method closePopup(): this
      // Closes the popup bound to this layer if it is open.
      closePopup: function() {
        return this._popup && this._popup.close(), this;
      },
      // @method togglePopup(): this
      // Opens or closes the popup bound to this layer depending on its current state.
      togglePopup: function() {
        return this._popup && this._popup.toggle(this), this;
      },
      // @method isPopupOpen(): boolean
      // Returns `true` if the popup bound to this layer is currently open.
      isPopupOpen: function() {
        return this._popup ? this._popup.isOpen() : !1;
      },
      // @method setPopupContent(content: String|HTMLElement|Popup): this
      // Sets the content of the popup bound to this layer.
      setPopupContent: function(r) {
        return this._popup && this._popup.setContent(r), this;
      },
      // @method getPopup(): Popup
      // Returns the popup bound to this layer.
      getPopup: function() {
        return this._popup;
      },
      _openPopup: function(r) {
        if (!(!this._popup || !this._map)) {
          Li(r);
          var u = r.layer || r.target;
          if (this._popup._source === u && !(u instanceof us)) {
            this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(r.latlng);
            return;
          }
          this._popup._source = u, this.openPopup(r.latlng);
        }
      },
      _movePopup: function(r) {
        this._popup.setLatLng(r.latlng);
      },
      _onKeyPress: function(r) {
        r.originalEvent.keyCode === 13 && this._openPopup(r);
      }
    });
    var Eu = $i.extend({
      // @section
      // @aka Tooltip options
      options: {
        // @option pane: String = 'tooltipPane'
        // `Map pane` where the tooltip will be added.
        pane: "tooltipPane",
        // @option offset: Point = Point(0, 0)
        // Optional offset of the tooltip position.
        offset: [0, 0],
        // @option direction: String = 'auto'
        // Direction where to open the tooltip. Possible values are: `right`, `left`,
        // `top`, `bottom`, `center`, `auto`.
        // `auto` will dynamically switch between `right` and `left` according to the tooltip
        // position on the map.
        direction: "auto",
        // @option permanent: Boolean = false
        // Whether to open the tooltip permanently or only on mouseover.
        permanent: !1,
        // @option sticky: Boolean = false
        // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
        sticky: !1,
        // @option opacity: Number = 0.9
        // Tooltip container opacity.
        opacity: 0.9
      },
      onAdd: function(r) {
        $i.prototype.onAdd.call(this, r), this.setOpacity(this.options.opacity), r.fire("tooltipopen", { tooltip: this }), this._source && (this.addEventParent(this._source), this._source.fire("tooltipopen", { tooltip: this }, !0));
      },
      onRemove: function(r) {
        $i.prototype.onRemove.call(this, r), r.fire("tooltipclose", { tooltip: this }), this._source && (this.removeEventParent(this._source), this._source.fire("tooltipclose", { tooltip: this }, !0));
      },
      getEvents: function() {
        var r = $i.prototype.getEvents.call(this);
        return this.options.permanent || (r.preclick = this.close), r;
      },
      _initLayout: function() {
        var r = "leaflet-tooltip", u = r + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
        this._contentNode = this._container = Pt("div", u), this._container.setAttribute("role", "tooltip"), this._container.setAttribute("id", "leaflet-tooltip-" + z(this));
      },
      _updateLayout: function() {
      },
      _adjustPan: function() {
      },
      _setPosition: function(r) {
        var u, h, y = this._map, T = this._container, D = y.latLngToContainerPoint(y.getCenter()), I = y.layerPointToContainerPoint(r), Q = this.options.direction, ie = T.offsetWidth, ge = T.offsetHeight, Fe = N(this.options.offset), ht = this._getAnchor();
        Q === "top" ? (u = ie / 2, h = ge) : Q === "bottom" ? (u = ie / 2, h = 0) : Q === "center" ? (u = ie / 2, h = ge / 2) : Q === "right" ? (u = 0, h = ge / 2) : Q === "left" ? (u = ie, h = ge / 2) : I.x < D.x ? (Q = "right", u = 0, h = ge / 2) : (Q = "left", u = ie + (Fe.x + ht.x) * 2, h = ge / 2), r = r.subtract(N(u, h, !0)).add(Fe).add(ht), sn(T, "leaflet-tooltip-right"), sn(T, "leaflet-tooltip-left"), sn(T, "leaflet-tooltip-top"), sn(T, "leaflet-tooltip-bottom"), xt(T, "leaflet-tooltip-" + Q), lr(T, r);
      },
      _updatePosition: function() {
        var r = this._map.latLngToLayerPoint(this._latlng);
        this._setPosition(r);
      },
      setOpacity: function(r) {
        this.options.opacity = r, this._container && kr(this._container, r);
      },
      _animateZoom: function(r) {
        var u = this._map._latLngToNewLayerPoint(this._latlng, r.zoom, r.center);
        this._setPosition(u);
      },
      _getAnchor: function() {
        return N(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
      }
    }), pl = function(r, u) {
      return new Eu(r, u);
    };
    Kt.include({
      // @method openTooltip(tooltip: Tooltip): this
      // Opens the specified tooltip.
      // @alternative
      // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
      // Creates a tooltip with the specified content and options and open it.
      openTooltip: function(r, u, h) {
        return this._initOverlay(Eu, r, u, h).openOn(this), this;
      },
      // @method closeTooltip(tooltip: Tooltip): this
      // Closes the tooltip given as parameter.
      closeTooltip: function(r) {
        return r.close(), this;
      }
    }), En.include({
      // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
      // Binds a tooltip to the layer with the passed `content` and sets up the
      // necessary event listeners. If a `Function` is passed it will receive
      // the layer as the first argument and should return a `String` or `HTMLElement`.
      bindTooltip: function(r, u) {
        return this._tooltip && this.isTooltipOpen() && this.unbindTooltip(), this._tooltip = this._initOverlay(Eu, this._tooltip, r, u), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this;
      },
      // @method unbindTooltip(): this
      // Removes the tooltip previously bound with `bindTooltip`.
      unbindTooltip: function() {
        return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this;
      },
      _initTooltipInteractions: function(r) {
        if (!(!r && this._tooltipHandlersAdded)) {
          var u = r ? "off" : "on", h = {
            remove: this.closeTooltip,
            move: this._moveTooltip
          };
          this._tooltip.options.permanent ? h.add = this._openTooltip : (h.mouseover = this._openTooltip, h.mouseout = this.closeTooltip, h.click = this._openTooltip, this._map ? this._addFocusListeners() : h.add = this._addFocusListeners), this._tooltip.options.sticky && (h.mousemove = this._moveTooltip), this[u](h), this._tooltipHandlersAdded = !r;
        }
      },
      // @method openTooltip(latlng?: LatLng): this
      // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
      openTooltip: function(r) {
        return this._tooltip && (this instanceof sa || (this._tooltip._source = this), this._tooltip._prepareOpen(r) && (this._tooltip.openOn(this._map), this.getElement ? this._setAriaDescribedByOnLayer(this) : this.eachLayer && this.eachLayer(this._setAriaDescribedByOnLayer, this))), this;
      },
      // @method closeTooltip(): this
      // Closes the tooltip bound to this layer if it is open.
      closeTooltip: function() {
        if (this._tooltip)
          return this._tooltip.close();
      },
      // @method toggleTooltip(): this
      // Opens or closes the tooltip bound to this layer depending on its current state.
      toggleTooltip: function() {
        return this._tooltip && this._tooltip.toggle(this), this;
      },
      // @method isTooltipOpen(): boolean
      // Returns `true` if the tooltip bound to this layer is currently open.
      isTooltipOpen: function() {
        return this._tooltip.isOpen();
      },
      // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
      // Sets the content of the tooltip bound to this layer.
      setTooltipContent: function(r) {
        return this._tooltip && this._tooltip.setContent(r), this;
      },
      // @method getTooltip(): Tooltip
      // Returns the tooltip bound to this layer.
      getTooltip: function() {
        return this._tooltip;
      },
      _addFocusListeners: function() {
        this.getElement ? this._addFocusListenersOnLayer(this) : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this);
      },
      _addFocusListenersOnLayer: function(r) {
        var u = typeof r.getElement == "function" && r.getElement();
        u && (nt(u, "focus", function() {
          this._tooltip._source = r, this.openTooltip();
        }, this), nt(u, "blur", this.closeTooltip, this));
      },
      _setAriaDescribedByOnLayer: function(r) {
        var u = typeof r.getElement == "function" && r.getElement();
        u && u.setAttribute("aria-describedby", this._tooltip._container.id);
      },
      _openTooltip: function(r) {
        if (!(!this._tooltip || !this._map)) {
          if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
            this._openOnceFlag = !0;
            var u = this;
            this._map.once("moveend", function() {
              u._openOnceFlag = !1, u._openTooltip(r);
            });
            return;
          }
          this._tooltip._source = r.layer || r.target, this.openTooltip(this._tooltip.options.sticky ? r.latlng : void 0);
        }
      },
      _moveTooltip: function(r) {
        var u = r.latlng, h, y;
        this._tooltip.options.sticky && r.originalEvent && (h = this._map.mouseEventToContainerPoint(r.originalEvent), y = this._map.containerPointToLayerPoint(h), u = this._map.layerPointToLatLng(y)), this._tooltip.setLatLng(u);
      }
    });
    var _c = Na.extend({
      options: {
        // @section
        // @aka DivIcon options
        iconSize: [12, 12],
        // also can be set through CSS
        // iconAnchor: (Point),
        // popupAnchor: (Point),
        // @option html: String|HTMLElement = ''
        // Custom HTML code to put inside the div element, empty by default. Alternatively,
        // an instance of `HTMLElement`.
        html: !1,
        // @option bgPos: Point = [0, 0]
        // Optional relative position of the background, in pixels
        bgPos: null,
        className: "leaflet-div-icon"
      },
      createIcon: function(r) {
        var u = r && r.tagName === "DIV" ? r : document.createElement("div"), h = this.options;
        if (h.html instanceof Element ? (rs(u), u.appendChild(h.html)) : u.innerHTML = h.html !== !1 ? h.html : "", h.bgPos) {
          var y = N(h.bgPos);
          u.style.backgroundPosition = -y.x + "px " + -y.y + "px";
        }
        return this._setIconStyles(u, "icon"), u;
      },
      createShadow: function() {
        return null;
      }
    });
    function kd(r) {
      return new _c(r);
    }
    Na.Default = gu;
    var cs = En.extend({
      // @section
      // @aka GridLayer options
      options: {
        // @option tileSize: Number|Point = 256
        // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
        tileSize: 256,
        // @option opacity: Number = 1.0
        // Opacity of the tiles. Can be used in the `createTile()` function.
        opacity: 1,
        // @option updateWhenIdle: Boolean = (depends)
        // Load new tiles only when panning ends.
        // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
        // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
        // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
        updateWhenIdle: We.mobile,
        // @option updateWhenZooming: Boolean = true
        // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
        updateWhenZooming: !0,
        // @option updateInterval: Number = 200
        // Tiles will not update more than once every `updateInterval` milliseconds when panning.
        updateInterval: 200,
        // @option zIndex: Number = 1
        // The explicit zIndex of the tile layer.
        zIndex: 1,
        // @option bounds: LatLngBounds = undefined
        // If set, tiles will only be loaded inside the set `LatLngBounds`.
        bounds: null,
        // @option minZoom: Number = 0
        // The minimum zoom level down to which this layer will be displayed (inclusive).
        minZoom: 0,
        // @option maxZoom: Number = undefined
        // The maximum zoom level up to which this layer will be displayed (inclusive).
        maxZoom: void 0,
        // @option maxNativeZoom: Number = undefined
        // Maximum zoom number the tile source has available. If it is specified,
        // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
        // from `maxNativeZoom` level and auto-scaled.
        maxNativeZoom: void 0,
        // @option minNativeZoom: Number = undefined
        // Minimum zoom number the tile source has available. If it is specified,
        // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
        // from `minNativeZoom` level and auto-scaled.
        minNativeZoom: void 0,
        // @option noWrap: Boolean = false
        // Whether the layer is wrapped around the antimeridian. If `true`, the
        // GridLayer will only be displayed once at low zoom levels. Has no
        // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
        // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
        // tiles outside the CRS limits.
        noWrap: !1,
        // @option pane: String = 'tilePane'
        // `Map pane` where the grid layer will be added.
        pane: "tilePane",
        // @option className: String = ''
        // A custom class name to assign to the tile layer. Empty by default.
        className: "",
        // @option keepBuffer: Number = 2
        // When panning the map, keep this many rows and columns of tiles before unloading them.
        keepBuffer: 2
      },
      initialize: function(r) {
        ce(this, r);
      },
      onAdd: function() {
        this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView();
      },
      beforeAdd: function(r) {
        r._addZoomLimit(this);
      },
      onRemove: function(r) {
        this._removeAllTiles(), In(this._container), r._removeZoomLimit(this), this._container = null, this._tileZoom = void 0;
      },
      // @method bringToFront: this
      // Brings the tile layer to the top of all tile layers.
      bringToFront: function() {
        return this._map && (zo(this._container), this._setAutoZIndex(Math.max)), this;
      },
      // @method bringToBack: this
      // Brings the tile layer to the bottom of all tile layers.
      bringToBack: function() {
        return this._map && (ka(this._container), this._setAutoZIndex(Math.min)), this;
      },
      // @method getContainer: HTMLElement
      // Returns the HTML element that contains the tiles for this layer.
      getContainer: function() {
        return this._container;
      },
      // @method setOpacity(opacity: Number): this
      // Changes the [opacity](#gridlayer-opacity) of the grid layer.
      setOpacity: function(r) {
        return this.options.opacity = r, this._updateOpacity(), this;
      },
      // @method setZIndex(zIndex: Number): this
      // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
      setZIndex: function(r) {
        return this.options.zIndex = r, this._updateZIndex(), this;
      },
      // @method isLoading: Boolean
      // Returns `true` if any tile in the grid layer has not finished loading.
      isLoading: function() {
        return this._loading;
      },
      // @method redraw: this
      // Causes the layer to clear all the tiles and request them again.
      redraw: function() {
        if (this._map) {
          this._removeAllTiles();
          var r = this._clampZoom(this._map.getZoom());
          r !== this._tileZoom && (this._tileZoom = r, this._updateLevels()), this._update();
        }
        return this;
      },
      getEvents: function() {
        var r = {
          viewprereset: this._invalidateAll,
          viewreset: this._resetView,
          zoom: this._resetView,
          moveend: this._onMoveEnd
        };
        return this.options.updateWhenIdle || (this._onMove || (this._onMove = j(this._onMoveEnd, this.options.updateInterval, this)), r.move = this._onMove), this._zoomAnimated && (r.zoomanim = this._animateZoom), r;
      },
      // @section Extension methods
      // Layers extending `GridLayer` shall reimplement the following method.
      // @method createTile(coords: Object, done?: Function): HTMLElement
      // Called only internally, must be overridden by classes extending `GridLayer`.
      // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
      // is specified, it must be called when the tile has finished loading and drawing.
      createTile: function() {
        return document.createElement("div");
      },
      // @section
      // @method getTileSize: Point
      // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
      getTileSize: function() {
        var r = this.options.tileSize;
        return r instanceof le ? r : new le(r, r);
      },
      _updateZIndex: function() {
        this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._container.style.zIndex = this.options.zIndex);
      },
      _setAutoZIndex: function(r) {
        for (var u = this.getPane().children, h = -r(-1 / 0, 1 / 0), y = 0, T = u.length, D; y < T; y++)
          D = u[y].style.zIndex, u[y] !== this._container && D && (h = r(h, +D));
        isFinite(h) && (this.options.zIndex = h + r(-1, 1), this._updateZIndex());
      },
      _updateOpacity: function() {
        if (this._map && !We.ielt9) {
          kr(this._container, this.options.opacity);
          var r = +/* @__PURE__ */ new Date(), u = !1, h = !1;
          for (var y in this._tiles) {
            var T = this._tiles[y];
            if (!(!T.current || !T.loaded)) {
              var D = Math.min(1, (r - T.loaded) / 200);
              kr(T.el, D), D < 1 ? u = !0 : (T.active ? h = !0 : this._onOpaqueTile(T), T.active = !0);
            }
          }
          h && !this._noPrune && this._pruneTiles(), u && (Mt(this._fadeFrame), this._fadeFrame = Xe(this._updateOpacity, this));
        }
      },
      _onOpaqueTile: H,
      _initContainer: function() {
        this._container || (this._container = Pt("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container));
      },
      _updateLevels: function() {
        var r = this._tileZoom, u = this.options.maxZoom;
        if (r !== void 0) {
          for (var h in this._levels)
            h = Number(h), this._levels[h].el.children.length || h === r ? (this._levels[h].el.style.zIndex = u - Math.abs(r - h), this._onUpdateLevel(h)) : (In(this._levels[h].el), this._removeTilesAtZoom(h), this._onRemoveLevel(h), delete this._levels[h]);
          var y = this._levels[r], T = this._map;
          return y || (y = this._levels[r] = {}, y.el = Pt("div", "leaflet-tile-container leaflet-zoom-animated", this._container), y.el.style.zIndex = u, y.origin = T.project(T.unproject(T.getPixelOrigin()), r).round(), y.zoom = r, this._setZoomTransform(y, T.getCenter(), T.getZoom()), H(y.el.offsetWidth), this._onCreateLevel(y)), this._level = y, y;
        }
      },
      _onUpdateLevel: H,
      _onRemoveLevel: H,
      _onCreateLevel: H,
      _pruneTiles: function() {
        if (this._map) {
          var r, u, h = this._map.getZoom();
          if (h > this.options.maxZoom || h < this.options.minZoom) {
            this._removeAllTiles();
            return;
          }
          for (r in this._tiles)
            u = this._tiles[r], u.retain = u.current;
          for (r in this._tiles)
            if (u = this._tiles[r], u.current && !u.active) {
              var y = u.coords;
              this._retainParent(y.x, y.y, y.z, y.z - 5) || this._retainChildren(y.x, y.y, y.z, y.z + 2);
            }
          for (r in this._tiles)
            this._tiles[r].retain || this._removeTile(r);
        }
      },
      _removeTilesAtZoom: function(r) {
        for (var u in this._tiles)
          this._tiles[u].coords.z === r && this._removeTile(u);
      },
      _removeAllTiles: function() {
        for (var r in this._tiles)
          this._removeTile(r);
      },
      _invalidateAll: function() {
        for (var r in this._levels)
          In(this._levels[r].el), this._onRemoveLevel(Number(r)), delete this._levels[r];
        this._removeAllTiles(), this._tileZoom = void 0;
      },
      _retainParent: function(r, u, h, y) {
        var T = Math.floor(r / 2), D = Math.floor(u / 2), I = h - 1, Q = new le(+T, +D);
        Q.z = +I;
        var ie = this._tileCoordsToKey(Q), ge = this._tiles[ie];
        return ge && ge.active ? (ge.retain = !0, !0) : (ge && ge.loaded && (ge.retain = !0), I > y ? this._retainParent(T, D, I, y) : !1);
      },
      _retainChildren: function(r, u, h, y) {
        for (var T = 2 * r; T < 2 * r + 2; T++)
          for (var D = 2 * u; D < 2 * u + 2; D++) {
            var I = new le(T, D);
            I.z = h + 1;
            var Q = this._tileCoordsToKey(I), ie = this._tiles[Q];
            if (ie && ie.active) {
              ie.retain = !0;
              continue;
            } else
              ie && ie.loaded && (ie.retain = !0);
            h + 1 < y && this._retainChildren(T, D, h + 1, y);
          }
      },
      _resetView: function(r) {
        var u = r && (r.pinch || r.flyTo);
        this._setView(this._map.getCenter(), this._map.getZoom(), u, u);
      },
      _animateZoom: function(r) {
        this._setView(r.center, r.zoom, !0, r.noUpdate);
      },
      _clampZoom: function(r) {
        var u = this.options;
        return u.minNativeZoom !== void 0 && r < u.minNativeZoom ? u.minNativeZoom : u.maxNativeZoom !== void 0 && u.maxNativeZoom < r ? u.maxNativeZoom : r;
      },
      _setView: function(r, u, h, y) {
        var T = Math.round(u);
        this.options.maxZoom !== void 0 && T > this.options.maxZoom || this.options.minZoom !== void 0 && T < this.options.minZoom ? T = void 0 : T = this._clampZoom(T);
        var D = this.options.updateWhenZooming && T !== this._tileZoom;
        (!y || D) && (this._tileZoom = T, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), T !== void 0 && this._update(r), h || this._pruneTiles(), this._noPrune = !!h), this._setZoomTransforms(r, u);
      },
      _setZoomTransforms: function(r, u) {
        for (var h in this._levels)
          this._setZoomTransform(this._levels[h], r, u);
      },
      _setZoomTransform: function(r, u, h) {
        var y = this._map.getZoomScale(h, r.zoom), T = r.origin.multiplyBy(y).subtract(this._map._getNewPixelOrigin(u, h)).round();
        We.any3d ? hi(r.el, T, y) : lr(r.el, T);
      },
      _resetGrid: function() {
        var r = this._map, u = r.options.crs, h = this._tileSize = this.getTileSize(), y = this._tileZoom, T = this._map.getPixelWorldBounds(this._tileZoom);
        T && (this._globalTileRange = this._pxBoundsToTileRange(T)), this._wrapX = u.wrapLng && !this.options.noWrap && [
          Math.floor(r.project([0, u.wrapLng[0]], y).x / h.x),
          Math.ceil(r.project([0, u.wrapLng[1]], y).x / h.y)
        ], this._wrapY = u.wrapLat && !this.options.noWrap && [
          Math.floor(r.project([u.wrapLat[0], 0], y).y / h.x),
          Math.ceil(r.project([u.wrapLat[1], 0], y).y / h.y)
        ];
      },
      _onMoveEnd: function() {
        !this._map || this._map._animatingZoom || this._update();
      },
      _getTiledPixelBounds: function(r) {
        var u = this._map, h = u._animatingZoom ? Math.max(u._animateToZoom, u.getZoom()) : u.getZoom(), y = u.getZoomScale(h, this._tileZoom), T = u.project(r, this._tileZoom).floor(), D = u.getSize().divideBy(y * 2);
        return new se(T.subtract(D), T.add(D));
      },
      // Private method to load tiles in the grid's active zoom level according to map bounds
      _update: function(r) {
        var u = this._map;
        if (u) {
          var h = this._clampZoom(u.getZoom());
          if (r === void 0 && (r = u.getCenter()), this._tileZoom !== void 0) {
            var y = this._getTiledPixelBounds(r), T = this._pxBoundsToTileRange(y), D = T.getCenter(), I = [], Q = this.options.keepBuffer, ie = new se(
              T.getBottomLeft().subtract([Q, -Q]),
              T.getTopRight().add([Q, -Q])
            );
            if (!(isFinite(T.min.x) && isFinite(T.min.y) && isFinite(T.max.x) && isFinite(T.max.y)))
              throw new Error("Attempted to load an infinite number of tiles");
            for (var ge in this._tiles) {
              var Fe = this._tiles[ge].coords;
              (Fe.z !== this._tileZoom || !ie.contains(new le(Fe.x, Fe.y))) && (this._tiles[ge].current = !1);
            }
            if (Math.abs(h - this._tileZoom) > 1) {
              this._setView(r, h);
              return;
            }
            for (var ht = T.min.y; ht <= T.max.y; ht++)
              for (var Vt = T.min.x; Vt <= T.max.x; Vt++) {
                var hr = new le(Vt, ht);
                if (hr.z = this._tileZoom, !!this._isValidTile(hr)) {
                  var Lr = this._tiles[this._tileCoordsToKey(hr)];
                  Lr ? Lr.current = !0 : I.push(hr);
                }
              }
            if (I.sort(function(ii, xu) {
              return ii.distanceTo(D) - xu.distanceTo(D);
            }), I.length !== 0) {
              this._loading || (this._loading = !0, this.fire("loading"));
              var Pi = document.createDocumentFragment();
              for (Vt = 0; Vt < I.length; Vt++)
                this._addTile(I[Vt], Pi);
              this._level.el.appendChild(Pi);
            }
          }
        }
      },
      _isValidTile: function(r) {
        var u = this._map.options.crs;
        if (!u.infinite) {
          var h = this._globalTileRange;
          if (!u.wrapLng && (r.x < h.min.x || r.x > h.max.x) || !u.wrapLat && (r.y < h.min.y || r.y > h.max.y))
            return !1;
        }
        if (!this.options.bounds)
          return !0;
        var y = this._tileCoordsToBounds(r);
        return je(this.options.bounds).overlaps(y);
      },
      _keyToBounds: function(r) {
        return this._tileCoordsToBounds(this._keyToTileCoords(r));
      },
      _tileCoordsToNwSe: function(r) {
        var u = this._map, h = this.getTileSize(), y = r.scaleBy(h), T = y.add(h), D = u.unproject(y, r.z), I = u.unproject(T, r.z);
        return [D, I];
      },
      // converts tile coordinates to its geographical bounds
      _tileCoordsToBounds: function(r) {
        var u = this._tileCoordsToNwSe(r), h = new et(u[0], u[1]);
        return this.options.noWrap || (h = this._map.wrapLatLngBounds(h)), h;
      },
      // converts tile coordinates to key for the tile cache
      _tileCoordsToKey: function(r) {
        return r.x + ":" + r.y + ":" + r.z;
      },
      // converts tile cache key to coordinates
      _keyToTileCoords: function(r) {
        var u = r.split(":"), h = new le(+u[0], +u[1]);
        return h.z = +u[2], h;
      },
      _removeTile: function(r) {
        var u = this._tiles[r];
        u && (In(u.el), delete this._tiles[r], this.fire("tileunload", {
          tile: u.el,
          coords: this._keyToTileCoords(r)
        }));
      },
      _initTile: function(r) {
        xt(r, "leaflet-tile");
        var u = this.getTileSize();
        r.style.width = u.x + "px", r.style.height = u.y + "px", r.onselectstart = H, r.onmousemove = H, We.ielt9 && this.options.opacity < 1 && kr(r, this.options.opacity);
      },
      _addTile: function(r, u) {
        var h = this._getTilePos(r), y = this._tileCoordsToKey(r), T = this.createTile(this._wrapCoords(r), C(this._tileReady, this, r));
        this._initTile(T), this.createTile.length < 2 && Xe(C(this._tileReady, this, r, null, T)), lr(T, h), this._tiles[y] = {
          el: T,
          coords: r,
          current: !0
        }, u.appendChild(T), this.fire("tileloadstart", {
          tile: T,
          coords: r
        });
      },
      _tileReady: function(r, u, h) {
        u && this.fire("tileerror", {
          error: u,
          tile: h,
          coords: r
        });
        var y = this._tileCoordsToKey(r);
        h = this._tiles[y], h && (h.loaded = +/* @__PURE__ */ new Date(), this._map._fadeAnimated ? (kr(h.el, 0), Mt(this._fadeFrame), this._fadeFrame = Xe(this._updateOpacity, this)) : (h.active = !0, this._pruneTiles()), u || (xt(h.el, "leaflet-tile-loaded"), this.fire("tileload", {
          tile: h.el,
          coords: r
        })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), We.ielt9 || !this._map._fadeAnimated ? Xe(this._pruneTiles, this) : setTimeout(C(this._pruneTiles, this), 250)));
      },
      _getTilePos: function(r) {
        return r.scaleBy(this.getTileSize()).subtract(this._level.origin);
      },
      _wrapCoords: function(r) {
        var u = new le(
          this._wrapX ? Z(r.x, this._wrapX) : r.x,
          this._wrapY ? Z(r.y, this._wrapY) : r.y
        );
        return u.z = r.z, u;
      },
      _pxBoundsToTileRange: function(r) {
        var u = this.getTileSize();
        return new se(
          r.min.unscaleBy(u).floor(),
          r.max.unscaleBy(u).ceil().subtract([1, 1])
        );
      },
      _noTilesToLoad: function() {
        for (var r in this._tiles)
          if (!this._tiles[r].loaded)
            return !1;
        return !0;
      }
    });
    function js(r) {
      return new cs(r);
    }
    var fs = cs.extend({
      // @section
      // @aka TileLayer options
      options: {
        // @option minZoom: Number = 0
        // The minimum zoom level down to which this layer will be displayed (inclusive).
        minZoom: 0,
        // @option maxZoom: Number = 18
        // The maximum zoom level up to which this layer will be displayed (inclusive).
        maxZoom: 18,
        // @option subdomains: String|String[] = 'abc'
        // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
        subdomains: "abc",
        // @option errorTileUrl: String = ''
        // URL to the tile image to show in place of the tile that failed to load.
        errorTileUrl: "",
        // @option zoomOffset: Number = 0
        // The zoom number used in tile URLs will be offset with this value.
        zoomOffset: 0,
        // @option tms: Boolean = false
        // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
        tms: !1,
        // @option zoomReverse: Boolean = false
        // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
        zoomReverse: !1,
        // @option detectRetina: Boolean = false
        // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
        detectRetina: !1,
        // @option crossOrigin: Boolean|String = false
        // Whether the crossOrigin attribute will be added to the tiles.
        // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
        // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
        crossOrigin: !1,
        // @option referrerPolicy: Boolean|String = false
        // Whether the referrerPolicy attribute will be added to the tiles.
        // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
        // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
        // (e.g. to validate an API token).
        // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
        referrerPolicy: !1
      },
      initialize: function(r, u) {
        this._url = r, u = ce(this, u), u.detectRetina && We.retina && u.maxZoom > 0 ? (u.tileSize = Math.floor(u.tileSize / 2), u.zoomReverse ? (u.zoomOffset--, u.minZoom = Math.min(u.maxZoom, u.minZoom + 1)) : (u.zoomOffset++, u.maxZoom = Math.max(u.minZoom, u.maxZoom - 1)), u.minZoom = Math.max(0, u.minZoom)) : u.zoomReverse ? u.minZoom = Math.min(u.maxZoom, u.minZoom) : u.maxZoom = Math.max(u.minZoom, u.maxZoom), typeof u.subdomains == "string" && (u.subdomains = u.subdomains.split("")), this.on("tileunload", this._onTileRemove);
      },
      // @method setUrl(url: String, noRedraw?: Boolean): this
      // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
      // If the URL does not change, the layer will not be redrawn unless
      // the noRedraw parameter is set to false.
      setUrl: function(r, u) {
        return this._url === r && u === void 0 && (u = !0), this._url = r, u || this.redraw(), this;
      },
      // @method createTile(coords: Object, done?: Function): HTMLElement
      // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
      // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
      // callback is called when the tile has been loaded.
      createTile: function(r, u) {
        var h = document.createElement("img");
        return nt(h, "load", C(this._tileOnLoad, this, u, h)), nt(h, "error", C(this._tileOnError, this, u, h)), (this.options.crossOrigin || this.options.crossOrigin === "") && (h.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), typeof this.options.referrerPolicy == "string" && (h.referrerPolicy = this.options.referrerPolicy), h.alt = "", h.src = this.getTileUrl(r), h;
      },
      // @section Extension methods
      // @uninheritable
      // Layers extending `TileLayer` might reimplement the following method.
      // @method getTileUrl(coords: Object): String
      // Called only internally, returns the URL for a tile given its coordinates.
      // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
      getTileUrl: function(r) {
        var u = {
          r: We.retina ? "@2x" : "",
          s: this._getSubdomain(r),
          x: r.x,
          y: r.y,
          z: this._getZoomForUrl()
        };
        if (this._map && !this._map.options.crs.infinite) {
          var h = this._globalTileRange.max.y - r.y;
          this.options.tms && (u.y = h), u["-y"] = h;
        }
        return He(this._url, w(u, this.options));
      },
      _tileOnLoad: function(r, u) {
        We.ielt9 ? setTimeout(C(r, this, null, u), 0) : r(null, u);
      },
      _tileOnError: function(r, u, h) {
        var y = this.options.errorTileUrl;
        y && u.getAttribute("src") !== y && (u.src = y), r(h, u);
      },
      _onTileRemove: function(r) {
        r.tile.onload = null;
      },
      _getZoomForUrl: function() {
        var r = this._tileZoom, u = this.options.maxZoom, h = this.options.zoomReverse, y = this.options.zoomOffset;
        return h && (r = u - r), r + y;
      },
      _getSubdomain: function(r) {
        var u = Math.abs(r.x + r.y) % this.options.subdomains.length;
        return this.options.subdomains[u];
      },
      // stops loading all tiles in the background layer
      _abortLoading: function() {
        var r, u;
        for (r in this._tiles)
          if (this._tiles[r].coords.z !== this._tileZoom && (u = this._tiles[r].el, u.onload = H, u.onerror = H, !u.complete)) {
            u.src = G;
            var h = this._tiles[r].coords;
            In(u), delete this._tiles[r], this.fire("tileabort", {
              tile: u,
              coords: h
            });
          }
      },
      _removeTile: function(r) {
        var u = this._tiles[r];
        if (u)
          return u.el.setAttribute("src", G), cs.prototype._removeTile.call(this, r);
      },
      _tileReady: function(r, u, h) {
        if (!(!this._map || h && h.getAttribute("src") === G))
          return cs.prototype._tileReady.call(this, r, u, h);
      }
    });
    function Sc(r, u) {
      return new fs(r, u);
    }
    var Or = fs.extend({
      // @section
      // @aka TileLayer.WMS options
      // If any custom options not documented here are used, they will be sent to the
      // WMS server as extra parameters in each request URL. This can be useful for
      // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
      defaultWmsParams: {
        service: "WMS",
        request: "GetMap",
        // @option layers: String = ''
        // **(required)** Comma-separated list of WMS layers to show.
        layers: "",
        // @option styles: String = ''
        // Comma-separated list of WMS styles.
        styles: "",
        // @option format: String = 'image/jpeg'
        // WMS image format (use `'image/png'` for layers with transparency).
        format: "image/jpeg",
        // @option transparent: Boolean = false
        // If `true`, the WMS service will return images with transparency.
        transparent: !1,
        // @option version: String = '1.1.1'
        // Version of the WMS service to use
        version: "1.1.1"
      },
      options: {
        // @option crs: CRS = null
        // Coordinate Reference System to use for the WMS requests, defaults to
        // map CRS. Don't change this if you're not sure what it means.
        crs: null,
        // @option uppercase: Boolean = false
        // If `true`, WMS request parameter keys will be uppercase.
        uppercase: !1
      },
      initialize: function(r, u) {
        this._url = r;
        var h = w({}, this.defaultWmsParams);
        for (var y in u)
          y in this.options || (h[y] = u[y]);
        u = ce(this, u);
        var T = u.detectRetina && We.retina ? 2 : 1, D = this.getTileSize();
        h.width = D.x * T, h.height = D.y * T, this.wmsParams = h;
      },
      onAdd: function(r) {
        this._crs = this.options.crs || r.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
        var u = this._wmsVersion >= 1.3 ? "crs" : "srs";
        this.wmsParams[u] = this._crs.code, fs.prototype.onAdd.call(this, r);
      },
      getTileUrl: function(r) {
        var u = this._tileCoordsToNwSe(r), h = this._crs, y = xe(h.project(u[0]), h.project(u[1])), T = y.min, D = y.max, I = (this._wmsVersion >= 1.3 && this._crs === yi ? [T.y, T.x, D.y, D.x] : [T.x, T.y, D.x, D.y]).join(","), Q = fs.prototype.getTileUrl.call(this, r);
        return Q + ue(this.wmsParams, Q, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + I;
      },
      // @method setParams(params: Object, noRedraw?: Boolean): this
      // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
      setParams: function(r, u) {
        return w(this.wmsParams, r), u || this.redraw(), this;
      }
    });
    function Tf(r, u) {
      return new Or(r, u);
    }
    fs.WMS = Or, Sc.wms = Tf;
    var co = En.extend({
      // @section
      // @aka Renderer options
      options: {
        // @option padding: Number = 0.1
        // How much to extend the clip area around the map view (relative to its size)
        // e.g. 0.1 would be 10% of map view in each direction
        padding: 0.1
      },
      initialize: function(r) {
        ce(this, r), z(this), this._layers = this._layers || {};
      },
      onAdd: function() {
        this._container || (this._initContainer(), xt(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this);
      },
      onRemove: function() {
        this.off("update", this._updatePaths, this), this._destroyContainer();
      },
      getEvents: function() {
        var r = {
          viewreset: this._reset,
          zoom: this._onZoom,
          moveend: this._update,
          zoomend: this._onZoomEnd
        };
        return this._zoomAnimated && (r.zoomanim = this._onAnimZoom), r;
      },
      _onAnimZoom: function(r) {
        this._updateTransform(r.center, r.zoom);
      },
      _onZoom: function() {
        this._updateTransform(this._map.getCenter(), this._map.getZoom());
      },
      _updateTransform: function(r, u) {
        var h = this._map.getZoomScale(u, this._zoom), y = this._map.getSize().multiplyBy(0.5 + this.options.padding), T = this._map.project(this._center, u), D = y.multiplyBy(-h).add(T).subtract(this._map._getNewPixelOrigin(r, u));
        We.any3d ? hi(this._container, D, h) : lr(this._container, D);
      },
      _reset: function() {
        this._update(), this._updateTransform(this._center, this._zoom);
        for (var r in this._layers)
          this._layers[r]._reset();
      },
      _onZoomEnd: function() {
        for (var r in this._layers)
          this._layers[r]._project();
      },
      _updatePaths: function() {
        for (var r in this._layers)
          this._layers[r]._update();
      },
      _update: function() {
        var r = this.options.padding, u = this._map.getSize(), h = this._map.containerPointToLayerPoint(u.multiplyBy(-r)).round();
        this._bounds = new se(h, h.add(u.multiplyBy(1 + r * 2)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom();
      }
    }), Cf = co.extend({
      // @section
      // @aka Canvas options
      options: {
        // @option tolerance: Number = 0
        // How much to extend the click tolerance around a path/object on the map.
        tolerance: 0
      },
      getEvents: function() {
        var r = co.prototype.getEvents.call(this);
        return r.viewprereset = this._onViewPreReset, r;
      },
      _onViewPreReset: function() {
        this._postponeUpdatePaths = !0;
      },
      onAdd: function() {
        co.prototype.onAdd.call(this), this._draw();
      },
      _initContainer: function() {
        var r = this._container = document.createElement("canvas");
        nt(r, "mousemove", this._onMouseMove, this), nt(r, "click dblclick mousedown mouseup contextmenu", this._onClick, this), nt(r, "mouseout", this._handleMouseOut, this), r._leaflet_disable_events = !0, this._ctx = r.getContext("2d");
      },
      _destroyContainer: function() {
        Mt(this._redrawRequest), delete this._ctx, In(this._container), Mn(this._container), delete this._container;
      },
      _updatePaths: function() {
        if (!this._postponeUpdatePaths) {
          var r;
          this._redrawBounds = null;
          for (var u in this._layers)
            r = this._layers[u], r._update();
          this._redraw();
        }
      },
      _update: function() {
        if (!(this._map._animatingZoom && this._bounds)) {
          co.prototype._update.call(this);
          var r = this._bounds, u = this._container, h = r.getSize(), y = We.retina ? 2 : 1;
          lr(u, r.min), u.width = y * h.x, u.height = y * h.y, u.style.width = h.x + "px", u.style.height = h.y + "px", We.retina && this._ctx.scale(2, 2), this._ctx.translate(-r.min.x, -r.min.y), this.fire("update");
        }
      },
      _reset: function() {
        co.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths());
      },
      _initPath: function(r) {
        this._updateDashArray(r), this._layers[z(r)] = r;
        var u = r._order = {
          layer: r,
          prev: this._drawLast,
          next: null
        };
        this._drawLast && (this._drawLast.next = u), this._drawLast = u, this._drawFirst = this._drawFirst || this._drawLast;
      },
      _addPath: function(r) {
        this._requestRedraw(r);
      },
      _removePath: function(r) {
        var u = r._order, h = u.next, y = u.prev;
        h ? h.prev = y : this._drawLast = y, y ? y.next = h : this._drawFirst = h, delete r._order, delete this._layers[z(r)], this._requestRedraw(r);
      },
      _updatePath: function(r) {
        this._extendRedrawBounds(r), r._project(), r._update(), this._requestRedraw(r);
      },
      _updateStyle: function(r) {
        this._updateDashArray(r), this._requestRedraw(r);
      },
      _updateDashArray: function(r) {
        if (typeof r.options.dashArray == "string") {
          var u = r.options.dashArray.split(/[, ]+/), h = [], y, T;
          for (T = 0; T < u.length; T++) {
            if (y = Number(u[T]), isNaN(y))
              return;
            h.push(y);
          }
          r.options._dashArray = h;
        } else
          r.options._dashArray = r.options.dashArray;
      },
      _requestRedraw: function(r) {
        this._map && (this._extendRedrawBounds(r), this._redrawRequest = this._redrawRequest || Xe(this._redraw, this));
      },
      _extendRedrawBounds: function(r) {
        if (r._pxBounds) {
          var u = (r.options.weight || 0) + 1;
          this._redrawBounds = this._redrawBounds || new se(), this._redrawBounds.extend(r._pxBounds.min.subtract([u, u])), this._redrawBounds.extend(r._pxBounds.max.add([u, u]));
        }
      },
      _redraw: function() {
        this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null;
      },
      _clear: function() {
        var r = this._redrawBounds;
        if (r) {
          var u = r.getSize();
          this._ctx.clearRect(r.min.x, r.min.y, u.x, u.y);
        } else
          this._ctx.save(), this._ctx.setTransform(1, 0, 0, 1, 0, 0), this._ctx.clearRect(0, 0, this._container.width, this._container.height), this._ctx.restore();
      },
      _draw: function() {
        var r, u = this._redrawBounds;
        if (this._ctx.save(), u) {
          var h = u.getSize();
          this._ctx.beginPath(), this._ctx.rect(u.min.x, u.min.y, h.x, h.y), this._ctx.clip();
        }
        this._drawing = !0;
        for (var y = this._drawFirst; y; y = y.next)
          r = y.layer, (!u || r._pxBounds && r._pxBounds.intersects(u)) && r._updatePath();
        this._drawing = !1, this._ctx.restore();
      },
      _updatePoly: function(r, u) {
        if (this._drawing) {
          var h, y, T, D, I = r._parts, Q = I.length, ie = this._ctx;
          if (Q) {
            for (ie.beginPath(), h = 0; h < Q; h++) {
              for (y = 0, T = I[h].length; y < T; y++)
                D = I[h][y], ie[y ? "lineTo" : "moveTo"](D.x, D.y);
              u && ie.closePath();
            }
            this._fillStroke(ie, r);
          }
        }
      },
      _updateCircle: function(r) {
        if (!(!this._drawing || r._empty())) {
          var u = r._point, h = this._ctx, y = Math.max(Math.round(r._radius), 1), T = (Math.max(Math.round(r._radiusY), 1) || y) / y;
          T !== 1 && (h.save(), h.scale(1, T)), h.beginPath(), h.arc(u.x, u.y / T, y, 0, Math.PI * 2, !1), T !== 1 && h.restore(), this._fillStroke(h, r);
        }
      },
      _fillStroke: function(r, u) {
        var h = u.options;
        h.fill && (r.globalAlpha = h.fillOpacity, r.fillStyle = h.fillColor || h.color, r.fill(h.fillRule || "evenodd")), h.stroke && h.weight !== 0 && (r.setLineDash && r.setLineDash(u.options && u.options._dashArray || []), r.globalAlpha = h.opacity, r.lineWidth = h.weight, r.strokeStyle = h.color, r.lineCap = h.lineCap, r.lineJoin = h.lineJoin, r.stroke());
      },
      // Canvas obviously doesn't have mouse events for individual drawn objects,
      // so we emulate that by calculating what's under the mouse on mousemove/click manually
      _onClick: function(r) {
        for (var u = this._map.mouseEventToLayerPoint(r), h, y, T = this._drawFirst; T; T = T.next)
          h = T.layer, h.options.interactive && h._containsPoint(u) && (!(r.type === "click" || r.type === "preclick") || !this._map._draggableMoved(h)) && (y = h);
        this._fireEvent(y ? [y] : !1, r);
      },
      _onMouseMove: function(r) {
        if (!(!this._map || this._map.dragging.moving() || this._map._animatingZoom)) {
          var u = this._map.mouseEventToLayerPoint(r);
          this._handleMouseHover(r, u);
        }
      },
      _handleMouseOut: function(r) {
        var u = this._hoveredLayer;
        u && (sn(this._container, "leaflet-interactive"), this._fireEvent([u], r, "mouseout"), this._hoveredLayer = null, this._mouseHoverThrottled = !1);
      },
      _handleMouseHover: function(r, u) {
        if (!this._mouseHoverThrottled) {
          for (var h, y, T = this._drawFirst; T; T = T.next)
            h = T.layer, h.options.interactive && h._containsPoint(u) && (y = h);
          y !== this._hoveredLayer && (this._handleMouseOut(r), y && (xt(this._container, "leaflet-interactive"), this._fireEvent([y], r, "mouseover"), this._hoveredLayer = y)), this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : !1, r), this._mouseHoverThrottled = !0, setTimeout(C(function() {
            this._mouseHoverThrottled = !1;
          }, this), 32);
        }
      },
      _fireEvent: function(r, u, h) {
        this._map._fireDOMEvent(u, h || u.type, r);
      },
      _bringToFront: function(r) {
        var u = r._order;
        if (u) {
          var h = u.next, y = u.prev;
          if (h)
            h.prev = y;
          else
            return;
          y ? y.next = h : h && (this._drawFirst = h), u.prev = this._drawLast, this._drawLast.next = u, u.next = null, this._drawLast = u, this._requestRedraw(r);
        }
      },
      _bringToBack: function(r) {
        var u = r._order;
        if (u) {
          var h = u.next, y = u.prev;
          if (y)
            y.next = h;
          else
            return;
          h ? h.prev = y : y && (this._drawLast = y), u.prev = null, u.next = this._drawFirst, this._drawFirst.prev = u, this._drawFirst = u, this._requestRedraw(r);
        }
      }
    });
    function xf(r) {
      return We.canvas ? new Cf(r) : null;
    }
    var Tu = function() {
      try {
        return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function(r) {
          return document.createElement("<lvml:" + r + ' class="lvml">');
        };
      } catch {
      }
      return function(r) {
        return document.createElement("<" + r + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
      };
    }(), Od = {
      _initContainer: function() {
        this._container = Pt("div", "leaflet-vml-container");
      },
      _update: function() {
        this._map._animatingZoom || (co.prototype._update.call(this), this.fire("update"));
      },
      _initPath: function(r) {
        var u = r._container = Tu("shape");
        xt(u, "leaflet-vml-shape " + (this.options.className || "")), u.coordsize = "1 1", r._path = Tu("path"), u.appendChild(r._path), this._updateStyle(r), this._layers[z(r)] = r;
      },
      _addPath: function(r) {
        var u = r._container;
        this._container.appendChild(u), r.options.interactive && r.addInteractiveTarget(u);
      },
      _removePath: function(r) {
        var u = r._container;
        In(u), r.removeInteractiveTarget(u), delete this._layers[z(r)];
      },
      _updateStyle: function(r) {
        var u = r._stroke, h = r._fill, y = r.options, T = r._container;
        T.stroked = !!y.stroke, T.filled = !!y.fill, y.stroke ? (u || (u = r._stroke = Tu("stroke")), T.appendChild(u), u.weight = y.weight + "px", u.color = y.color, u.opacity = y.opacity, y.dashArray ? u.dashStyle = ve(y.dashArray) ? y.dashArray.join(" ") : y.dashArray.replace(/( *, *)/g, " ") : u.dashStyle = "", u.endcap = y.lineCap.replace("butt", "flat"), u.joinstyle = y.lineJoin) : u && (T.removeChild(u), r._stroke = null), y.fill ? (h || (h = r._fill = Tu("fill")), T.appendChild(h), h.color = y.fillColor || y.color, h.opacity = y.fillOpacity) : h && (T.removeChild(h), r._fill = null);
      },
      _updateCircle: function(r) {
        var u = r._point.round(), h = Math.round(r._radius), y = Math.round(r._radiusY || h);
        this._setPath(r, r._empty() ? "M0 0" : "AL " + u.x + "," + u.y + " " + h + "," + y + " 0," + 65535 * 360);
      },
      _setPath: function(r, u) {
        r._path.v = u;
      },
      _bringToFront: function(r) {
        zo(r._container);
      },
      _bringToBack: function(r) {
        ka(r._container);
      }
    }, la = We.vml ? Tu : zn, Zo = co.extend({
      _initContainer: function() {
        this._container = la("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = la("g"), this._container.appendChild(this._rootGroup);
      },
      _destroyContainer: function() {
        In(this._container), Mn(this._container), delete this._container, delete this._rootGroup, delete this._svgSize;
      },
      _update: function() {
        if (!(this._map._animatingZoom && this._bounds)) {
          co.prototype._update.call(this);
          var r = this._bounds, u = r.getSize(), h = this._container;
          (!this._svgSize || !this._svgSize.equals(u)) && (this._svgSize = u, h.setAttribute("width", u.x), h.setAttribute("height", u.y)), lr(h, r.min), h.setAttribute("viewBox", [r.min.x, r.min.y, u.x, u.y].join(" ")), this.fire("update");
        }
      },
      // methods below are called by vector layers implementations
      _initPath: function(r) {
        var u = r._path = la("path");
        r.options.className && xt(u, r.options.className), r.options.interactive && xt(u, "leaflet-interactive"), this._updateStyle(r), this._layers[z(r)] = r;
      },
      _addPath: function(r) {
        this._rootGroup || this._initContainer(), this._rootGroup.appendChild(r._path), r.addInteractiveTarget(r._path);
      },
      _removePath: function(r) {
        In(r._path), r.removeInteractiveTarget(r._path), delete this._layers[z(r)];
      },
      _updatePath: function(r) {
        r._project(), r._update();
      },
      _updateStyle: function(r) {
        var u = r._path, h = r.options;
        u && (h.stroke ? (u.setAttribute("stroke", h.color), u.setAttribute("stroke-opacity", h.opacity), u.setAttribute("stroke-width", h.weight), u.setAttribute("stroke-linecap", h.lineCap), u.setAttribute("stroke-linejoin", h.lineJoin), h.dashArray ? u.setAttribute("stroke-dasharray", h.dashArray) : u.removeAttribute("stroke-dasharray"), h.dashOffset ? u.setAttribute("stroke-dashoffset", h.dashOffset) : u.removeAttribute("stroke-dashoffset")) : u.setAttribute("stroke", "none"), h.fill ? (u.setAttribute("fill", h.fillColor || h.color), u.setAttribute("fill-opacity", h.fillOpacity), u.setAttribute("fill-rule", h.fillRule || "evenodd")) : u.setAttribute("fill", "none"));
      },
      _updatePoly: function(r, u) {
        this._setPath(r, Xn(r._parts, u));
      },
      _updateCircle: function(r) {
        var u = r._point, h = Math.max(Math.round(r._radius), 1), y = Math.max(Math.round(r._radiusY), 1) || h, T = "a" + h + "," + y + " 0 1,0 ", D = r._empty() ? "M0 0" : "M" + (u.x - h) + "," + u.y + T + h * 2 + ",0 " + T + -h * 2 + ",0 ";
        this._setPath(r, D);
      },
      _setPath: function(r, u) {
        r._path.setAttribute("d", u);
      },
      // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
      _bringToFront: function(r) {
        zo(r._path);
      },
      _bringToBack: function(r) {
        ka(r._path);
      }
    });
    We.vml && Zo.include(Od);
    function ds(r) {
      return We.svg || We.vml ? new Zo(r) : null;
    }
    Kt.include({
      // @namespace Map; @method getRenderer(layer: Path): Renderer
      // Returns the instance of `Renderer` that should be used to render the given
      // `Path`. It will ensure that the `renderer` options of the map and paths
      // are respected, and that the renderers do exist on the map.
      getRenderer: function(r) {
        var u = r.options.renderer || this._getPaneRenderer(r.options.pane) || this.options.renderer || this._renderer;
        return u || (u = this._renderer = this._createRenderer()), this.hasLayer(u) || this.addLayer(u), u;
      },
      _getPaneRenderer: function(r) {
        if (r === "overlayPane" || r === void 0)
          return !1;
        var u = this._paneRenderers[r];
        return u === void 0 && (u = this._createRenderer({ pane: r }), this._paneRenderers[r] = u), u;
      },
      _createRenderer: function(r) {
        return this.options.preferCanvas && xf(r) || ds(r);
      }
    });
    var Ld = Pa.extend({
      initialize: function(r, u) {
        Pa.prototype.initialize.call(this, this._boundsToLatLngs(r), u);
      },
      // @method setBounds(latLngBounds: LatLngBounds): this
      // Redraws the rectangle with the passed bounds.
      setBounds: function(r) {
        return this.setLatLngs(this._boundsToLatLngs(r));
      },
      _boundsToLatLngs: function(r) {
        return r = je(r), [
          r.getSouthWest(),
          r.getNorthWest(),
          r.getNorthEast(),
          r.getSouthEast()
        ];
      }
    });
    function vl(r, u) {
      return new Ld(r, u);
    }
    Zo.create = la, Zo.pointsToPath = Xn, Aa.geometryToLayer = Su, Aa.coordsToLatLng = pc, Aa.coordsToLatLngs = fl, Aa.latLngToCoords = vc, Aa.latLngsToCoords = mc, Aa.getFeature = wu, Aa.asFeature = yc, Kt.mergeOptions({
      // @option boxZoom: Boolean = true
      // Whether the map can be zoomed to a rectangular area specified by
      // dragging the mouse while pressing the shift key.
      boxZoom: !0
    });
    var Cu = Xt.extend({
      initialize: function(r) {
        this._map = r, this._container = r._container, this._pane = r._panes.overlayPane, this._resetStateTimeout = 0, r.on("unload", this._destroy, this);
      },
      addHooks: function() {
        nt(this._container, "mousedown", this._onMouseDown, this);
      },
      removeHooks: function() {
        Mn(this._container, "mousedown", this._onMouseDown, this);
      },
      moved: function() {
        return this._moved;
      },
      _destroy: function() {
        In(this._pane), delete this._pane;
      },
      _resetState: function() {
        this._resetStateTimeout = 0, this._moved = !1;
      },
      _clearDeferredResetState: function() {
        this._resetStateTimeout !== 0 && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0);
      },
      _onMouseDown: function(r) {
        if (!r.shiftKey || r.which !== 1 && r.button !== 1)
          return !1;
        this._clearDeferredResetState(), this._resetState(), nn(), rn(), this._startPoint = this._map.mouseEventToContainerPoint(r), nt(document, {
          contextmenu: Li,
          mousemove: this._onMouseMove,
          mouseup: this._onMouseUp,
          keydown: this._onKeyDown
        }, this);
      },
      _onMouseMove: function(r) {
        this._moved || (this._moved = !0, this._box = Pt("div", "leaflet-zoom-box", this._container), xt(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(r);
        var u = new se(this._point, this._startPoint), h = u.getSize();
        lr(this._box, u.min), this._box.style.width = h.x + "px", this._box.style.height = h.y + "px";
      },
      _finish: function() {
        this._moved && (In(this._box), sn(this._container, "leaflet-crosshair")), ao(), is(), Mn(document, {
          contextmenu: Li,
          mousemove: this._onMouseMove,
          mouseup: this._onMouseUp,
          keydown: this._onKeyDown
        }, this);
      },
      _onMouseUp: function(r) {
        if (!(r.which !== 1 && r.button !== 1) && (this._finish(), !!this._moved)) {
          this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(C(this._resetState, this), 0);
          var u = new et(
            this._map.containerPointToLatLng(this._startPoint),
            this._map.containerPointToLatLng(this._point)
          );
          this._map.fitBounds(u).fire("boxzoomend", { boxZoomBounds: u });
        }
      },
      _onKeyDown: function(r) {
        r.keyCode === 27 && (this._finish(), this._clearDeferredResetState(), this._resetState());
      }
    });
    Kt.addInitHook("addHandler", "boxZoom", Cu), Kt.mergeOptions({
      // @option doubleClickZoom: Boolean|String = true
      // Whether the map can be zoomed in by double clicking on it and
      // zoomed out by double clicking while holding shift. If passed
      // `'center'`, double-click zoom will zoom to the center of the
      //  view regardless of where the mouse was.
      doubleClickZoom: !0
    });
    var Nd = Xt.extend({
      addHooks: function() {
        this._map.on("dblclick", this._onDoubleClick, this);
      },
      removeHooks: function() {
        this._map.off("dblclick", this._onDoubleClick, this);
      },
      _onDoubleClick: function(r) {
        var u = this._map, h = u.getZoom(), y = u.options.zoomDelta, T = r.originalEvent.shiftKey ? h - y : h + y;
        u.options.doubleClickZoom === "center" ? u.setZoom(T) : u.setZoomAround(r.containerPoint, T);
      }
    });
    Kt.addInitHook("addHandler", "doubleClickZoom", Nd), Kt.mergeOptions({
      // @option dragging: Boolean = true
      // Whether the map is draggable with mouse/touch or not.
      dragging: !0,
      // @section Panning Inertia Options
      // @option inertia: Boolean = *
      // If enabled, panning of the map will have an inertia effect where
      // the map builds momentum while dragging and continues moving in
      // the same direction for some time. Feels especially nice on touch
      // devices. Enabled by default.
      inertia: !0,
      // @option inertiaDeceleration: Number = 3000
      // The rate with which the inertial movement slows down, in pixels/second.
      inertiaDeceleration: 3400,
      // px/s^2
      // @option inertiaMaxSpeed: Number = Infinity
      // Max speed of the inertial movement, in pixels/second.
      inertiaMaxSpeed: 1 / 0,
      // px/s
      // @option easeLinearity: Number = 0.2
      easeLinearity: 0.2,
      // TODO refactor, move to CRS
      // @option worldCopyJump: Boolean = false
      // With this option enabled, the map tracks when you pan to another "copy"
      // of the world and seamlessly jumps to the original one so that all overlays
      // like markers and vector layers are still visible.
      worldCopyJump: !1,
      // @option maxBoundsViscosity: Number = 0.0
      // If `maxBounds` is set, this option will control how solid the bounds
      // are when dragging the map around. The default value of `0.0` allows the
      // user to drag outside the bounds at normal speed, higher values will
      // slow down map dragging outside bounds, and `1.0` makes the bounds fully
      // solid, preventing the user from dragging outside the bounds.
      maxBoundsViscosity: 0
    });
    var bf = Xt.extend({
      addHooks: function() {
        if (!this._draggable) {
          var r = this._map;
          this._draggable = new Ht(r._mapPane, r._container), this._draggable.on({
            dragstart: this._onDragStart,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this), this._draggable.on("predrag", this._onPreDragLimit, this), r.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), r.on("zoomend", this._onZoomEnd, this), r.whenReady(this._onZoomEnd, this));
        }
        xt(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = [];
      },
      removeHooks: function() {
        sn(this._map._container, "leaflet-grab"), sn(this._map._container, "leaflet-touch-drag"), this._draggable.disable();
      },
      moved: function() {
        return this._draggable && this._draggable._moved;
      },
      moving: function() {
        return this._draggable && this._draggable._moving;
      },
      _onDragStart: function() {
        var r = this._map;
        if (r._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
          var u = je(this._map.options.maxBounds);
          this._offsetLimit = xe(
            this._map.latLngToContainerPoint(u.getNorthWest()).multiplyBy(-1),
            this._map.latLngToContainerPoint(u.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
          ), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
        } else
          this._offsetLimit = null;
        r.fire("movestart").fire("dragstart"), r.options.inertia && (this._positions = [], this._times = []);
      },
      _onDrag: function(r) {
        if (this._map.options.inertia) {
          var u = this._lastTime = +/* @__PURE__ */ new Date(), h = this._lastPos = this._draggable._absPos || this._draggable._newPos;
          this._positions.push(h), this._times.push(u), this._prunePositions(u);
        }
        this._map.fire("move", r).fire("drag", r);
      },
      _prunePositions: function(r) {
        for (; this._positions.length > 1 && r - this._times[0] > 50; )
          this._positions.shift(), this._times.shift();
      },
      _onZoomEnd: function() {
        var r = this._map.getSize().divideBy(2), u = this._map.latLngToLayerPoint([0, 0]);
        this._initialWorldOffset = u.subtract(r).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
      },
      _viscousLimit: function(r, u) {
        return r - (r - u) * this._viscosity;
      },
      _onPreDragLimit: function() {
        if (!(!this._viscosity || !this._offsetLimit)) {
          var r = this._draggable._newPos.subtract(this._draggable._startPos), u = this._offsetLimit;
          r.x < u.min.x && (r.x = this._viscousLimit(r.x, u.min.x)), r.y < u.min.y && (r.y = this._viscousLimit(r.y, u.min.y)), r.x > u.max.x && (r.x = this._viscousLimit(r.x, u.max.x)), r.y > u.max.y && (r.y = this._viscousLimit(r.y, u.max.y)), this._draggable._newPos = this._draggable._startPos.add(r);
        }
      },
      _onPreDragWrap: function() {
        var r = this._worldWidth, u = Math.round(r / 2), h = this._initialWorldOffset, y = this._draggable._newPos.x, T = (y - u + h) % r + u - h, D = (y + u + h) % r - u - h, I = Math.abs(T + h) < Math.abs(D + h) ? T : D;
        this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = I;
      },
      _onDragEnd: function(r) {
        var u = this._map, h = u.options, y = !h.inertia || r.noInertia || this._times.length < 2;
        if (u.fire("dragend", r), y)
          u.fire("moveend");
        else {
          this._prunePositions(+/* @__PURE__ */ new Date());
          var T = this._lastPos.subtract(this._positions[0]), D = (this._lastTime - this._times[0]) / 1e3, I = h.easeLinearity, Q = T.multiplyBy(I / D), ie = Q.distanceTo([0, 0]), ge = Math.min(h.inertiaMaxSpeed, ie), Fe = Q.multiplyBy(ge / ie), ht = ge / (h.inertiaDeceleration * I), Vt = Fe.multiplyBy(-ht / 2).round();
          !Vt.x && !Vt.y ? u.fire("moveend") : (Vt = u._limitOffset(Vt, u.options.maxBounds), Xe(function() {
            u.panBy(Vt, {
              duration: ht,
              easeLinearity: I,
              noMoveStart: !0,
              animate: !0
            });
          }));
        }
      }
    });
    Kt.addInitHook("addHandler", "dragging", bf), Kt.mergeOptions({
      // @option keyboard: Boolean = true
      // Makes the map focusable and allows users to navigate the map with keyboard
      // arrows and `+`/`-` keys.
      keyboard: !0,
      // @option keyboardPanDelta: Number = 80
      // Amount of pixels to pan when pressing an arrow key.
      keyboardPanDelta: 80
    });
    var ml = Xt.extend({
      keyCodes: {
        left: [37],
        right: [39],
        down: [40],
        up: [38],
        zoomIn: [187, 107, 61, 171],
        zoomOut: [189, 109, 54, 173]
      },
      initialize: function(r) {
        this._map = r, this._setPanDelta(r.options.keyboardPanDelta), this._setZoomDelta(r.options.zoomDelta);
      },
      addHooks: function() {
        var r = this._map._container;
        r.tabIndex <= 0 && (r.tabIndex = "0"), nt(r, {
          focus: this._onFocus,
          blur: this._onBlur,
          mousedown: this._onMouseDown
        }, this), this._map.on({
          focus: this._addHooks,
          blur: this._removeHooks
        }, this);
      },
      removeHooks: function() {
        this._removeHooks(), Mn(this._map._container, {
          focus: this._onFocus,
          blur: this._onBlur,
          mousedown: this._onMouseDown
        }, this), this._map.off({
          focus: this._addHooks,
          blur: this._removeHooks
        }, this);
      },
      _onMouseDown: function() {
        if (!this._focused) {
          var r = document.body, u = document.documentElement, h = r.scrollTop || u.scrollTop, y = r.scrollLeft || u.scrollLeft;
          this._map._container.focus(), window.scrollTo(y, h);
        }
      },
      _onFocus: function() {
        this._focused = !0, this._map.fire("focus");
      },
      _onBlur: function() {
        this._focused = !1, this._map.fire("blur");
      },
      _setPanDelta: function(r) {
        var u = this._panKeys = {}, h = this.keyCodes, y, T;
        for (y = 0, T = h.left.length; y < T; y++)
          u[h.left[y]] = [-1 * r, 0];
        for (y = 0, T = h.right.length; y < T; y++)
          u[h.right[y]] = [r, 0];
        for (y = 0, T = h.down.length; y < T; y++)
          u[h.down[y]] = [0, r];
        for (y = 0, T = h.up.length; y < T; y++)
          u[h.up[y]] = [0, -1 * r];
      },
      _setZoomDelta: function(r) {
        var u = this._zoomKeys = {}, h = this.keyCodes, y, T;
        for (y = 0, T = h.zoomIn.length; y < T; y++)
          u[h.zoomIn[y]] = r;
        for (y = 0, T = h.zoomOut.length; y < T; y++)
          u[h.zoomOut[y]] = -r;
      },
      _addHooks: function() {
        nt(document, "keydown", this._onKeyDown, this);
      },
      _removeHooks: function() {
        Mn(document, "keydown", this._onKeyDown, this);
      },
      _onKeyDown: function(r) {
        if (!(r.altKey || r.ctrlKey || r.metaKey)) {
          var u = r.keyCode, h = this._map, y;
          if (u in this._panKeys) {
            if (!h._panAnim || !h._panAnim._inProgress)
              if (y = this._panKeys[u], r.shiftKey && (y = N(y).multiplyBy(3)), h.options.maxBounds && (y = h._limitOffset(N(y), h.options.maxBounds)), h.options.worldCopyJump) {
                var T = h.wrapLatLng(h.unproject(h.project(h.getCenter()).add(y)));
                h.panTo(T);
              } else
                h.panBy(y);
          } else if (u in this._zoomKeys)
            h.setZoom(h.getZoom() + (r.shiftKey ? 3 : 1) * this._zoomKeys[u]);
          else if (u === 27 && h._popup && h._popup.options.closeOnEscapeKey)
            h.closePopup();
          else
            return;
          Li(r);
        }
      }
    });
    Kt.addInitHook("addHandler", "keyboard", ml), Kt.mergeOptions({
      // @section Mouse wheel options
      // @option scrollWheelZoom: Boolean|String = true
      // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
      // it will zoom to the center of the view regardless of where the mouse was.
      scrollWheelZoom: !0,
      // @option wheelDebounceTime: Number = 40
      // Limits the rate at which a wheel can fire (in milliseconds). By default
      // user can't zoom via wheel more often than once per 40 ms.
      wheelDebounceTime: 40,
      // @option wheelPxPerZoomLevel: Number = 60
      // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
      // mean a change of one full zoom level. Smaller values will make wheel-zooming
      // faster (and vice versa).
      wheelPxPerZoomLevel: 60
    });
    var kn = Xt.extend({
      addHooks: function() {
        nt(this._map._container, "wheel", this._onWheelScroll, this), this._delta = 0;
      },
      removeHooks: function() {
        Mn(this._map._container, "wheel", this._onWheelScroll, this);
      },
      _onWheelScroll: function(r) {
        var u = Bo(r), h = this._map.options.wheelDebounceTime;
        this._delta += u, this._lastMousePos = this._map.mouseEventToContainerPoint(r), this._startTime || (this._startTime = +/* @__PURE__ */ new Date());
        var y = Math.max(h - (+/* @__PURE__ */ new Date() - this._startTime), 0);
        clearTimeout(this._timer), this._timer = setTimeout(C(this._performZoom, this), y), Li(r);
      },
      _performZoom: function() {
        var r = this._map, u = r.getZoom(), h = this._map.options.zoomSnap || 0;
        r._stop();
        var y = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), T = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(y)))) / Math.LN2, D = h ? Math.ceil(T / h) * h : T, I = r._limitZoom(u + (this._delta > 0 ? D : -D)) - u;
        this._delta = 0, this._startTime = null, I && (r.options.scrollWheelZoom === "center" ? r.setZoom(u + I) : r.setZoomAround(this._lastMousePos, u + I));
      }
    });
    Kt.addInitHook("addHandler", "scrollWheelZoom", kn);
    var hs = 600;
    Kt.mergeOptions({
      // @section Touch interaction options
      // @option tapHold: Boolean
      // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
      tapHold: We.touchNative && We.safari && We.mobile,
      // @option tapTolerance: Number = 15
      // The max number of pixels a user can shift his finger during touch
      // for it to be considered a valid tap.
      tapTolerance: 15
    });
    var fo = Xt.extend({
      addHooks: function() {
        nt(this._map._container, "touchstart", this._onDown, this);
      },
      removeHooks: function() {
        Mn(this._map._container, "touchstart", this._onDown, this);
      },
      _onDown: function(r) {
        if (clearTimeout(this._holdTimeout), r.touches.length === 1) {
          var u = r.touches[0];
          this._startPos = this._newPos = new le(u.clientX, u.clientY), this._holdTimeout = setTimeout(C(function() {
            this._cancel(), this._isTapValid() && (nt(document, "touchend", Dn), nt(document, "touchend touchcancel", this._cancelClickPrevent), this._simulateEvent("contextmenu", u));
          }, this), hs), nt(document, "touchend touchcancel contextmenu", this._cancel, this), nt(document, "touchmove", this._onMove, this);
        }
      },
      _cancelClickPrevent: function r() {
        Mn(document, "touchend", Dn), Mn(document, "touchend touchcancel", r);
      },
      _cancel: function() {
        clearTimeout(this._holdTimeout), Mn(document, "touchend touchcancel contextmenu", this._cancel, this), Mn(document, "touchmove", this._onMove, this);
      },
      _onMove: function(r) {
        var u = r.touches[0];
        this._newPos = new le(u.clientX, u.clientY);
      },
      _isTapValid: function() {
        return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
      },
      _simulateEvent: function(r, u) {
        var h = new MouseEvent(r, {
          bubbles: !0,
          cancelable: !0,
          view: window,
          // detail: 1,
          screenX: u.screenX,
          screenY: u.screenY,
          clientX: u.clientX,
          clientY: u.clientY
          // button: 2,
          // buttons: 2
        });
        h._simulated = !0, u.target.dispatchEvent(h);
      }
    });
    Kt.addInitHook("addHandler", "tapHold", fo), Kt.mergeOptions({
      // @section Touch interaction options
      // @option touchZoom: Boolean|String = *
      // Whether the map can be zoomed by touch-dragging with two fingers. If
      // passed `'center'`, it will zoom to the center of the view regardless of
      // where the touch events (fingers) were. Enabled for touch-capable web
      // browsers.
      touchZoom: We.touch,
      // @option bounceAtZoomLimits: Boolean = true
      // Set it to false if you don't want the map to zoom beyond min/max zoom
      // and then bounce back when pinch-zooming.
      bounceAtZoomLimits: !0
    });
    var Fs = Xt.extend({
      addHooks: function() {
        xt(this._map._container, "leaflet-touch-zoom"), nt(this._map._container, "touchstart", this._onTouchStart, this);
      },
      removeHooks: function() {
        sn(this._map._container, "leaflet-touch-zoom"), Mn(this._map._container, "touchstart", this._onTouchStart, this);
      },
      _onTouchStart: function(r) {
        var u = this._map;
        if (!(!r.touches || r.touches.length !== 2 || u._animatingZoom || this._zooming)) {
          var h = u.mouseEventToContainerPoint(r.touches[0]), y = u.mouseEventToContainerPoint(r.touches[1]);
          this._centerPoint = u.getSize()._divideBy(2), this._startLatLng = u.containerPointToLatLng(this._centerPoint), u.options.touchZoom !== "center" && (this._pinchStartLatLng = u.containerPointToLatLng(h.add(y)._divideBy(2))), this._startDist = h.distanceTo(y), this._startZoom = u.getZoom(), this._moved = !1, this._zooming = !0, u._stop(), nt(document, "touchmove", this._onTouchMove, this), nt(document, "touchend touchcancel", this._onTouchEnd, this), Dn(r);
        }
      },
      _onTouchMove: function(r) {
        if (!(!r.touches || r.touches.length !== 2 || !this._zooming)) {
          var u = this._map, h = u.mouseEventToContainerPoint(r.touches[0]), y = u.mouseEventToContainerPoint(r.touches[1]), T = h.distanceTo(y) / this._startDist;
          if (this._zoom = u.getScaleZoom(T, this._startZoom), !u.options.bounceAtZoomLimits && (this._zoom < u.getMinZoom() && T < 1 || this._zoom > u.getMaxZoom() && T > 1) && (this._zoom = u._limitZoom(this._zoom)), u.options.touchZoom === "center") {
            if (this._center = this._startLatLng, T === 1)
              return;
          } else {
            var D = h._add(y)._divideBy(2)._subtract(this._centerPoint);
            if (T === 1 && D.x === 0 && D.y === 0)
              return;
            this._center = u.unproject(u.project(this._pinchStartLatLng, this._zoom).subtract(D), this._zoom);
          }
          this._moved || (u._moveStart(!0, !1), this._moved = !0), Mt(this._animRequest);
          var I = C(u._move, u, this._center, this._zoom, { pinch: !0, round: !1 }, void 0);
          this._animRequest = Xe(I, this, !0), Dn(r);
        }
      },
      _onTouchEnd: function() {
        if (!this._moved || !this._zooming) {
          this._zooming = !1;
          return;
        }
        this._zooming = !1, Mt(this._animRequest), Mn(document, "touchmove", this._onTouchMove, this), Mn(document, "touchend touchcancel", this._onTouchEnd, this), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom));
      }
    });
    Kt.addInitHook("addHandler", "touchZoom", Fs), Kt.BoxZoom = Cu, Kt.DoubleClickZoom = Nd, Kt.Drag = bf, Kt.Keyboard = ml, Kt.ScrollWheelZoom = kn, Kt.TapHold = fo, Kt.TouchZoom = Fs, d.Bounds = se, d.Browser = We, d.CRS = Rt, d.Canvas = Cf, d.Circle = dc, d.CircleMarker = ll, d.Class = lt, d.Control = b, d.DivIcon = _c, d.DivOverlay = $i, d.DomEvent = Ns, d.DomUtil = as, d.Draggable = Ht, d.Evented = Ne, d.FeatureGroup = sa, d.GeoJSON = Aa, d.GridLayer = cs, d.Handler = Xt, d.Icon = Na, d.ImageOverlay = ls, d.LatLng = qe, d.LatLngBounds = et, d.Layer = En, d.LayerGroup = ri, d.LineUtil = cc, d.Map = Kt, d.Marker = Vo, d.Mixin = Fn, d.Path = us, d.Point = le, d.PolyUtil = gf, d.Polygon = Pa, d.Polyline = Ni, d.Popup = hl, d.PosAnimation = Ps, d.Projection = fc, d.Rectangle = Ld, d.Renderer = co, d.SVG = Zo, d.SVGOverlay = dl, d.TileLayer = fs, d.Tooltip = Eu, d.Transformation = ur, d.Util = ut, d.VideoOverlay = Ef, d.bind = C, d.bounds = xe, d.canvas = xf, d.circle = cl, d.circleMarker = xd, d.control = A, d.divIcon = kd, d.extend = w, d.featureGroup = Td, d.geoJSON = Md, d.geoJson = ua, d.gridLayer = js, d.icon = Cd, d.imageOverlay = Rd, d.latLng = Oe, d.latLngBounds = je, d.layerGroup = Is, d.map = La, d.marker = _p, d.point = N, d.polygon = bd, d.polyline = _u, d.popup = za, d.rectangle = vl, d.setOptions = ce, d.stamp = z, d.svg = ds, d.svgOverlay = Wo, d.tileLayer = Sc, d.tooltip = pl, d.transformation = Ue, d.version = m, d.videoOverlay = Dd;
    var Pd = window.L;
    d.noConflict = function() {
      return window.L = Pd, this;
    }, window.L = d;
  });
})(Bw, Bw.exports);
var a2 = Bw.exports;
const Ub = /* @__PURE__ */ jx(a2), o2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAFgUlEQVR4Aa1XA5BjWRTN2oW17d3YaZtr2962HUzbDNpjszW24mRt28p47v7zq/bXZtrp/lWnXr337j3nPCe85NcypgSFdugCpW5YoDAMRaIMqRi6aKq5E3YqDQO3qAwjVWrD8Ncq/RBpykd8oZUb/kaJutow8r1aP9II0WmLKLIsJyv1w/kqw9Ch2MYdB++12Onxee/QMwvf4/Dk/Lfp/i4nxTXtOoQ4pW5Aj7wpici1A9erdAN2OH64x8OSP9j3Ft3b7aWkTg/Fm91siTra0f9on5sQr9INejH6CUUUpavjFNq1B+Oadhxmnfa8RfEmN8VNAsQhPqF55xHkMzz3jSmChWU6f7/XZKNH+9+hBLOHYozuKQPxyMPUKkrX/K0uWnfFaJGS1QPRtZsOPtr3NsW0uyh6NNCOkU3Yz+bXbT3I8G3xE5EXLXtCXbbqwCO9zPQYPRTZ5vIDXD7U+w7rFDEoUUf7ibHIR4y6bLVPXrz8JVZEql13trxwue/uDivd3fkWRbS6/IA2bID4uk0UpF1N8qLlbBlXs4Ee7HLTfV1j54APvODnSfOWBqtKVvjgLKzF5YdEk5ewRkGlK0i33Eofffc7HT56jD7/6U+qH3Cx7SBLNntH5YIPvODnyfIXZYRVDPqgHtLs5ABHD3YzLuespb7t79FY34DjMwrVrcTuwlT55YMPvOBnRrJ4VXTdNnYug5ucHLBjEpt30701A3Ts+HEa73u6dT3FNWwflY86eMHPk+Yu+i6pzUpRrW7SNDg5JHR4KapmM5Wv2E8Tfcb1HoqqHMHU+uWDD7zg54mz5/2BSnizi9T1Dg4QQXLToGNCkb6tb1NU+QAlGr1++eADrzhn/u8Q2YZhQVlZ5+CAOtqfbhmaUCS1ezNFVm2imDbPmPng5wmz+gwh+oHDce0eUtQ6OGDIyR0uUhUsoO3vfDmmgOezH0mZN59x7MBi++WDL1g/eEiU3avlidO671bkLfwbw5XV2P8Pzo0ydy4t2/0eu33xYSOMOD8hTf4CrBtGMSoXfPLchX+J0ruSePw3LZeK0juPJbYzrhkH0io7B3k164hiGvawhOKMLkrQLyVpZg8rHFW7E2uHOL888IBPlNZ1FPzstSJM694fWr6RwpvcJK60+0HCILTBzZLFNdtAzJaohze60T8qBzyh5ZuOg5e7uwQppofEmf2++DYvmySqGBuKaicF1blQjhuHdvCIMvp8whTTfZzI7RldpwtSzL+F1+wkdZ2TBOW2gIF88PBTzD/gpeREAMEbxnJcaJHNHrpzji0gQCS6hdkEeYt9DF/2qPcEC8RM28Hwmr3sdNyht00byAut2k3gufWNtgtOEOFGUwcXWNDbdNbpgBGxEvKkOQsxivJx33iow0Vw5S6SVTrpVq11ysA2Rp7gTfPfktc6zhtXBBC+adRLshf6sG2RfHPZ5EAc4sVZ83yCN00Fk/4kggu40ZTvIEm5g24qtU4KjBrx/BTTH8ifVASAG7gKrnWxJDcU7x8X6Ecczhm3o6YicvsLXWfh3Ch1W0k8x0nXF+0fFxgt4phz8QvypiwCCFKMqXCnqXExjq10beH+UUA7+nG6mdG/Pu0f3LgFcGrl2s0kNNjpmoJ9o4B29CMO8dMT4Q5ox8uitF6fqsrJOr8qnwNbRzv6hSnG5wP+64C7h9lp30hKNtKdWjtdkbuPA19nJ7Tz3zR/ibgARbhb4AlhavcBebmTHcFl2fvYEnW0ox9xMxKBS8btJ+KiEbq9zA4RthQXDhPa0T9TEe69gWupwc6uBUphquXgf+/FrIjweHQS4/pduMe5ERUMHUd9xv8ZR98CxkS4F2n3EUrUZ10EYNw7BWm9x1GiPssi3GgiGRDKWRYZfXlON+dfNbM+GgIwYdwAAAAASUVORK5CYII=";
let s2 = Ub.icon({
  iconUrl: o2
});
Ub.Marker.prototype.options.icon = s2;
var Yw = { exports: {} }, Tw = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ex;
function u2() {
  if (Ex)
    return Tw;
  Ex = 1;
  var o = ic();
  function c(H, $) {
    return H === $ && (H !== 0 || 1 / H === 1 / $) || H !== H && $ !== $;
  }
  var d = typeof Object.is == "function" ? Object.is : c, m = o.useState, w = o.useEffect, M = o.useLayoutEffect, C = o.useDebugValue;
  function W(H, $) {
    var J = $(), oe = m({ inst: { value: J, getSnapshot: $ } }), ce = oe[0].inst, ue = oe[1];
    return M(function() {
      ce.value = J, ce.getSnapshot = $, z(ce) && ue({ inst: ce });
    }, [H, J, $]), w(function() {
      return z(ce) && ue({ inst: ce }), H(function() {
        z(ce) && ue({ inst: ce });
      });
    }, [H]), C(J), J;
  }
  function z(H) {
    var $ = H.getSnapshot;
    H = H.value;
    try {
      var J = $();
      return !d(H, J);
    } catch {
      return !0;
    }
  }
  function j(H, $) {
    return $();
  }
  var Z = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? j : W;
  return Tw.useSyncExternalStore = o.useSyncExternalStore !== void 0 ? o.useSyncExternalStore : Z, Tw;
}
var Cw = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Tx;
function l2() {
  return Tx || (Tx = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var o = ic(), c = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function d(ve) {
      {
        for (var ye = arguments.length, G = new Array(ye > 1 ? ye - 1 : 0), Me = 1; Me < ye; Me++)
          G[Me - 1] = arguments[Me];
        m("error", ve, G);
      }
    }
    function m(ve, ye, G) {
      {
        var Me = c.ReactDebugCurrentFrame, ze = Me.getStackAddendum();
        ze !== "" && (ye += "%s", G = G.concat([ze]));
        var kt = G.map(function(It) {
          return String(It);
        });
        kt.unshift("Warning: " + ye), Function.prototype.apply.call(console[ve], console, kt);
      }
    }
    function w(ve, ye) {
      return ve === ye && (ve !== 0 || 1 / ve === 1 / ye) || ve !== ve && ye !== ye;
    }
    var M = typeof Object.is == "function" ? Object.is : w, C = o.useState, W = o.useEffect, z = o.useLayoutEffect, j = o.useDebugValue, Z = !1, H = !1;
    function $(ve, ye, G) {
      Z || o.startTransition !== void 0 && (Z = !0, d("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var Me = ye();
      if (!H) {
        var ze = ye();
        M(Me, ze) || (d("The result of getSnapshot should be cached to avoid an infinite loop"), H = !0);
      }
      var kt = C({
        inst: {
          value: Me,
          getSnapshot: ye
        }
      }), It = kt[0].inst, Nt = kt[1];
      return z(function() {
        It.value = Me, It.getSnapshot = ye, J(It) && Nt({
          inst: It
        });
      }, [ve, Me, ye]), W(function() {
        J(It) && Nt({
          inst: It
        });
        var Xe = function() {
          J(It) && Nt({
            inst: It
          });
        };
        return ve(Xe);
      }, [ve]), j(Me), Me;
    }
    function J(ve) {
      var ye = ve.getSnapshot, G = ve.value;
      try {
        var Me = ye();
        return !M(G, Me);
      } catch {
        return !0;
      }
    }
    function oe(ve, ye, G) {
      return ye();
    }
    var ce = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", ue = !ce, Ke = ue ? oe : $, He = o.useSyncExternalStore !== void 0 ? o.useSyncExternalStore : Ke;
    Cw.useSyncExternalStore = He, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Cw;
}
process.env.NODE_ENV === "production" ? Yw.exports = u2() : Yw.exports = l2();
var Ib = Yw.exports, xw = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cx;
function c2() {
  if (Cx)
    return xw;
  Cx = 1;
  var o = ic(), c = Ib;
  function d(j, Z) {
    return j === Z && (j !== 0 || 1 / j === 1 / Z) || j !== j && Z !== Z;
  }
  var m = typeof Object.is == "function" ? Object.is : d, w = c.useSyncExternalStore, M = o.useRef, C = o.useEffect, W = o.useMemo, z = o.useDebugValue;
  return xw.useSyncExternalStoreWithSelector = function(j, Z, H, $, J) {
    var oe = M(null);
    if (oe.current === null) {
      var ce = { hasValue: !1, value: null };
      oe.current = ce;
    } else
      ce = oe.current;
    oe = W(function() {
      function Ke(Me) {
        if (!He) {
          if (He = !0, ve = Me, Me = $(Me), J !== void 0 && ce.hasValue) {
            var ze = ce.value;
            if (J(ze, Me))
              return ye = ze;
          }
          return ye = Me;
        }
        if (ze = ye, m(ve, Me))
          return ze;
        var kt = $(Me);
        return J !== void 0 && J(ze, kt) ? ze : (ve = Me, ye = kt);
      }
      var He = !1, ve, ye, G = H === void 0 ? null : H;
      return [function() {
        return Ke(Z());
      }, G === null ? void 0 : function() {
        return Ke(G());
      }];
    }, [Z, H, $, J]);
    var ue = w(j, oe[0], oe[1]);
    return C(function() {
      ce.hasValue = !0, ce.value = ue;
    }, [ue]), z(ue), ue;
  }, xw;
}
var bw = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xx;
function f2() {
  return xx || (xx = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var o = ic(), c = Ib;
    function d(Z, H) {
      return Z === H && (Z !== 0 || 1 / Z === 1 / H) || Z !== Z && H !== H;
    }
    var m = typeof Object.is == "function" ? Object.is : d, w = c.useSyncExternalStore, M = o.useRef, C = o.useEffect, W = o.useMemo, z = o.useDebugValue;
    function j(Z, H, $, J, oe) {
      var ce = M(null), ue;
      ce.current === null ? (ue = {
        hasValue: !1,
        value: null
      }, ce.current = ue) : ue = ce.current;
      var Ke = W(function() {
        var G = !1, Me, ze, kt = function(Mt) {
          if (!G) {
            G = !0, Me = Mt;
            var ut = J(Mt);
            if (oe !== void 0 && ue.hasValue) {
              var lt = ue.value;
              if (oe(lt, ut))
                return ze = lt, lt;
            }
            return ze = ut, ut;
          }
          var tn = Me, vt = ze;
          if (m(tn, Mt))
            return vt;
          var Ne = J(Mt);
          return oe !== void 0 && oe(vt, Ne) ? vt : (Me = Mt, ze = Ne, Ne);
        }, It = $ === void 0 ? null : $, Nt = function() {
          return kt(H());
        }, Xe = It === null ? void 0 : function() {
          return kt(It());
        };
        return [Nt, Xe];
      }, [H, $, J, oe]), He = Ke[0], ve = Ke[1], ye = w(Z, He, ve);
      return C(function() {
        ue.hasValue = !0, ue.value = ye;
      }, [ye]), z(ye), ye;
    }
    bw.useSyncExternalStoreWithSelector = j, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), bw;
}
process.env.NODE_ENV === "production" ? c2() : f2();
function Bi(o) {
  for (var c = arguments.length, d = Array(c > 1 ? c - 1 : 0), m = 1; m < c; m++)
    d[m - 1] = arguments[m];
  if (process.env.NODE_ENV !== "production") {
    var w = S2[o], M = w ? typeof w == "function" ? w.apply(null, d) : w : "unknown error nr: " + o;
    throw Error("[Immer] " + M);
  }
  throw Error("[Immer] minified error nr: " + o + (d.length ? " " + d.map(function(C) {
    return "'" + C + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function mf(o) {
  return !!o && !!o[Rr];
}
function rc(o) {
  var c;
  return !!o && (function(d) {
    if (!d || typeof d != "object")
      return !1;
    var m = Object.getPrototypeOf(d);
    if (m === null)
      return !0;
    var w = Object.hasOwnProperty.call(m, "constructor") && m.constructor;
    return w === Object || typeof w == "function" && Function.toString.call(w) === w2;
  }(o) || Array.isArray(o) || !!o[Lx] || !!(!((c = o.constructor) === null || c === void 0) && c[Lx]) || vE(o) || mE(o));
}
function gd(o, c, d) {
  d === void 0 && (d = !1), yp(o) === 0 ? (d ? Object.keys : hp)(o).forEach(function(m) {
    d && typeof m == "symbol" || c(m, o[m], o);
  }) : o.forEach(function(m, w) {
    return c(w, m, o);
  });
}
function yp(o) {
  var c = o[Rr];
  return c ? c.i > 3 ? c.i - 4 : c.i : Array.isArray(o) ? 1 : vE(o) ? 2 : mE(o) ? 3 : 0;
}
function dp(o, c) {
  return yp(o) === 2 ? o.has(c) : Object.prototype.hasOwnProperty.call(o, c);
}
function d2(o, c) {
  return yp(o) === 2 ? o.get(c) : o[c];
}
function jb(o, c, d) {
  var m = yp(o);
  m === 2 ? o.set(c, d) : m === 3 ? o.add(d) : o[c] = d;
}
function Fb(o, c) {
  return o === c ? o !== 0 || 1 / o == 1 / c : o != o && c != c;
}
function vE(o) {
  return g2 && o instanceof Map;
}
function mE(o) {
  return _2 && o instanceof Set;
}
function lf(o) {
  return o.o || o.t;
}
function yE(o) {
  if (Array.isArray(o))
    return Array.prototype.slice.call(o);
  var c = Bb(o);
  delete c[Rr];
  for (var d = hp(c), m = 0; m < d.length; m++) {
    var w = d[m], M = c[w];
    M.writable === !1 && (M.writable = !0, M.configurable = !0), (M.get || M.set) && (c[w] = { configurable: !0, writable: !0, enumerable: M.enumerable, value: o[w] });
  }
  return Object.create(Object.getPrototypeOf(o), c);
}
function gE(o, c) {
  return c === void 0 && (c = !1), _E(o) || mf(o) || !rc(o) || (yp(o) > 1 && (o.set = o.add = o.clear = o.delete = h2), Object.freeze(o), c && gd(o, function(d, m) {
    return gE(m, !0);
  }, !0)), o;
}
function h2() {
  Bi(2);
}
function _E(o) {
  return o == null || typeof o != "object" || Object.isFrozen(o);
}
function tl(o) {
  var c = $w[o];
  return c || Bi(18, o), c;
}
function p2(o, c) {
  $w[o] || ($w[o] = c);
}
function Vw() {
  return process.env.NODE_ENV === "production" || pp || Bi(0), pp;
}
function Mw(o, c) {
  c && (tl("Patches"), o.u = [], o.s = [], o.v = c);
}
function Zg(o) {
  Ww(o), o.p.forEach(v2), o.p = null;
}
function Ww(o) {
  o === pp && (pp = o.l);
}
function bx(o) {
  return pp = { p: [], l: pp, h: o, m: !0, _: 0 };
}
function v2(o) {
  var c = o[Rr];
  c.i === 0 || c.i === 1 ? c.j() : c.g = !0;
}
function Rw(o, c) {
  c._ = c.p.length;
  var d = c.p[0], m = o !== void 0 && o !== d;
  return c.h.O || tl("ES5").S(c, o, m), m ? (d[Rr].P && (Zg(c), Bi(4)), rc(o) && (o = $g(c, o), c.l || Gg(c, o)), c.u && tl("Patches").M(d[Rr].t, o, c.u, c.s)) : o = $g(c, d, []), Zg(c), c.u && c.v(c.u, c.s), o !== Hb ? o : void 0;
}
function $g(o, c, d) {
  if (_E(c))
    return c;
  var m = c[Rr];
  if (!m)
    return gd(c, function(W, z) {
      return Mx(o, m, c, W, z, d);
    }, !0), c;
  if (m.A !== o)
    return c;
  if (!m.P)
    return Gg(o, m.t, !0), m.t;
  if (!m.I) {
    m.I = !0, m.A._--;
    var w = m.i === 4 || m.i === 5 ? m.o = yE(m.k) : m.o, M = w, C = !1;
    m.i === 3 && (M = new Set(w), w.clear(), C = !0), gd(M, function(W, z) {
      return Mx(o, m, w, W, z, d, C);
    }), Gg(o, w, !1), d && o.u && tl("Patches").N(m, d, o.u, o.s);
  }
  return m.o;
}
function Mx(o, c, d, m, w, M, C) {
  if (process.env.NODE_ENV !== "production" && w === d && Bi(5), mf(w)) {
    var W = $g(o, w, M && c && c.i !== 3 && !dp(c.R, m) ? M.concat(m) : void 0);
    if (jb(d, m, W), !mf(W))
      return;
    o.m = !1;
  } else
    C && d.add(w);
  if (rc(w) && !_E(w)) {
    if (!o.h.D && o._ < 1)
      return;
    $g(o, w), c && c.A.l || Gg(o, w);
  }
}
function Gg(o, c, d) {
  d === void 0 && (d = !1), !o.l && o.h.D && o.m && gE(c, d);
}
function Dw(o, c) {
  var d = o[Rr];
  return (d ? lf(d) : o)[c];
}
function Rx(o, c) {
  if (c in o)
    for (var d = Object.getPrototypeOf(o); d; ) {
      var m = Object.getOwnPropertyDescriptor(d, c);
      if (m)
        return m;
      d = Object.getPrototypeOf(d);
    }
}
function cf(o) {
  o.P || (o.P = !0, o.l && cf(o.l));
}
function kw(o) {
  o.o || (o.o = yE(o.t));
}
function Zw(o, c, d) {
  var m = vE(c) ? tl("MapSet").F(c, d) : mE(c) ? tl("MapSet").T(c, d) : o.O ? function(w, M) {
    var C = Array.isArray(w), W = { i: C ? 1 : 0, A: M ? M.A : Vw(), P: !1, I: !1, R: {}, l: M, t: w, k: null, o: null, j: null, C: !1 }, z = W, j = mm;
    C && (z = [W], j = cm);
    var Z = Proxy.revocable(z, j), H = Z.revoke, $ = Z.proxy;
    return W.k = $, W.j = H, $;
  }(c, d) : tl("ES5").J(c, d);
  return (d ? d.A : Vw()).p.push(m), m;
}
function m2(o) {
  return mf(o) || Bi(22, o), function c(d) {
    if (!rc(d))
      return d;
    var m, w = d[Rr], M = yp(d);
    if (w) {
      if (!w.P && (w.i < 4 || !tl("ES5").K(w)))
        return w.t;
      w.I = !0, m = Dx(d, M), w.I = !1;
    } else
      m = Dx(d, M);
    return gd(m, function(C, W) {
      w && d2(w.t, C) === W || jb(m, C, c(W));
    }), M === 3 ? new Set(m) : m;
  }(o);
}
function Dx(o, c) {
  switch (c) {
    case 2:
      return new Map(o);
    case 3:
      return Array.from(o);
  }
  return yE(o);
}
function y2() {
  function o(C, W) {
    var z = M[C];
    return z ? z.enumerable = W : M[C] = z = { configurable: !0, enumerable: W, get: function() {
      var j = this[Rr];
      return process.env.NODE_ENV !== "production" && w(j), mm.get(j, C);
    }, set: function(j) {
      var Z = this[Rr];
      process.env.NODE_ENV !== "production" && w(Z), mm.set(Z, C, j);
    } }, z;
  }
  function c(C) {
    for (var W = C.length - 1; W >= 0; W--) {
      var z = C[W][Rr];
      if (!z.P)
        switch (z.i) {
          case 5:
            m(z) && cf(z);
            break;
          case 4:
            d(z) && cf(z);
        }
    }
  }
  function d(C) {
    for (var W = C.t, z = C.k, j = hp(z), Z = j.length - 1; Z >= 0; Z--) {
      var H = j[Z];
      if (H !== Rr) {
        var $ = W[H];
        if ($ === void 0 && !dp(W, H))
          return !0;
        var J = z[H], oe = J && J[Rr];
        if (oe ? oe.t !== $ : !Fb(J, $))
          return !0;
      }
    }
    var ce = !!W[Rr];
    return j.length !== hp(W).length + (ce ? 0 : 1);
  }
  function m(C) {
    var W = C.k;
    if (W.length !== C.t.length)
      return !0;
    var z = Object.getOwnPropertyDescriptor(W, W.length - 1);
    if (z && !z.get)
      return !0;
    for (var j = 0; j < W.length; j++)
      if (!W.hasOwnProperty(j))
        return !0;
    return !1;
  }
  function w(C) {
    C.g && Bi(3, JSON.stringify(lf(C)));
  }
  var M = {};
  p2("ES5", { J: function(C, W) {
    var z = Array.isArray(C), j = function(H, $) {
      if (H) {
        for (var J = Array($.length), oe = 0; oe < $.length; oe++)
          Object.defineProperty(J, "" + oe, o(oe, !0));
        return J;
      }
      var ce = Bb($);
      delete ce[Rr];
      for (var ue = hp(ce), Ke = 0; Ke < ue.length; Ke++) {
        var He = ue[Ke];
        ce[He] = o(He, H || !!ce[He].enumerable);
      }
      return Object.create(Object.getPrototypeOf($), ce);
    }(z, C), Z = { i: z ? 5 : 4, A: W ? W.A : Vw(), P: !1, I: !1, R: {}, l: W, t: C, k: j, o: null, g: !1, C: !1 };
    return Object.defineProperty(j, Rr, { value: Z, writable: !0 }), j;
  }, S: function(C, W, z) {
    z ? mf(W) && W[Rr].A === C && c(C.p) : (C.u && function j(Z) {
      if (Z && typeof Z == "object") {
        var H = Z[Rr];
        if (H) {
          var $ = H.t, J = H.k, oe = H.R, ce = H.i;
          if (ce === 4)
            gd(J, function(ye) {
              ye !== Rr && ($[ye] !== void 0 || dp($, ye) ? oe[ye] || j(J[ye]) : (oe[ye] = !0, cf(H)));
            }), gd($, function(ye) {
              J[ye] !== void 0 || dp(J, ye) || (oe[ye] = !1, cf(H));
            });
          else if (ce === 5) {
            if (m(H) && (cf(H), oe.length = !0), J.length < $.length)
              for (var ue = J.length; ue < $.length; ue++)
                oe[ue] = !1;
            else
              for (var Ke = $.length; Ke < J.length; Ke++)
                oe[Ke] = !0;
            for (var He = Math.min(J.length, $.length), ve = 0; ve < He; ve++)
              J.hasOwnProperty(ve) || (oe[ve] = !0), oe[ve] === void 0 && j(J[ve]);
          }
        }
      }
    }(C.p[0]), c(C.p));
  }, K: function(C) {
    return C.i === 4 ? d(C) : m(C);
  } });
}
var kx, pp, SE = typeof Symbol < "u" && typeof Symbol("x") == "symbol", g2 = typeof Map < "u", _2 = typeof Set < "u", Ox = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u", Hb = SE ? Symbol.for("immer-nothing") : ((kx = {})["immer-nothing"] = !0, kx), Lx = SE ? Symbol.for("immer-draftable") : "__$immer_draftable", Rr = SE ? Symbol.for("immer-state") : "__$immer_state", S2 = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(o) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + o;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(o) {
  return "Cannot apply patch, path doesn't resolve: " + o;
}, 16: 'Sets cannot have "replace" patches.', 17: function(o) {
  return "Unsupported patch operation: " + o;
}, 18: function(o) {
  return "The plugin for '" + o + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + o + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(o) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + o + "'";
}, 22: function(o) {
  return "'current' expects a draft, got: " + o;
}, 23: function(o) {
  return "'original' expects a draft, got: " + o;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" }, w2 = "" + Object.prototype.constructor, hp = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(o) {
  return Object.getOwnPropertyNames(o).concat(Object.getOwnPropertySymbols(o));
} : Object.getOwnPropertyNames, Bb = Object.getOwnPropertyDescriptors || function(o) {
  var c = {};
  return hp(o).forEach(function(d) {
    c[d] = Object.getOwnPropertyDescriptor(o, d);
  }), c;
}, $w = {}, mm = { get: function(o, c) {
  if (c === Rr)
    return o;
  var d = lf(o);
  if (!dp(d, c))
    return function(w, M, C) {
      var W, z = Rx(M, C);
      return z ? "value" in z ? z.value : (W = z.get) === null || W === void 0 ? void 0 : W.call(w.k) : void 0;
    }(o, d, c);
  var m = d[c];
  return o.I || !rc(m) ? m : m === Dw(o.t, c) ? (kw(o), o.o[c] = Zw(o.A.h, m, o)) : m;
}, has: function(o, c) {
  return c in lf(o);
}, ownKeys: function(o) {
  return Reflect.ownKeys(lf(o));
}, set: function(o, c, d) {
  var m = Rx(lf(o), c);
  if (m != null && m.set)
    return m.set.call(o.k, d), !0;
  if (!o.P) {
    var w = Dw(lf(o), c), M = w == null ? void 0 : w[Rr];
    if (M && M.t === d)
      return o.o[c] = d, o.R[c] = !1, !0;
    if (Fb(d, w) && (d !== void 0 || dp(o.t, c)))
      return !0;
    kw(o), cf(o);
  }
  return o.o[c] === d && (d !== void 0 || c in o.o) || Number.isNaN(d) && Number.isNaN(o.o[c]) || (o.o[c] = d, o.R[c] = !0), !0;
}, deleteProperty: function(o, c) {
  return Dw(o.t, c) !== void 0 || c in o.t ? (o.R[c] = !1, kw(o), cf(o)) : delete o.R[c], o.o && delete o.o[c], !0;
}, getOwnPropertyDescriptor: function(o, c) {
  var d = lf(o), m = Reflect.getOwnPropertyDescriptor(d, c);
  return m && { writable: !0, configurable: o.i !== 1 || c !== "length", enumerable: m.enumerable, value: d[c] };
}, defineProperty: function() {
  Bi(11);
}, getPrototypeOf: function(o) {
  return Object.getPrototypeOf(o.t);
}, setPrototypeOf: function() {
  Bi(12);
} }, cm = {};
gd(mm, function(o, c) {
  cm[o] = function() {
    return arguments[0] = arguments[0][0], c.apply(this, arguments);
  };
}), cm.deleteProperty = function(o, c) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(c)) && Bi(13), cm.set.call(this, o, c, void 0);
}, cm.set = function(o, c, d) {
  return process.env.NODE_ENV !== "production" && c !== "length" && isNaN(parseInt(c)) && Bi(14), mm.set.call(this, o[0], c, d, o[0]);
};
var E2 = function() {
  function o(d) {
    var m = this;
    this.O = Ox, this.D = !0, this.produce = function(w, M, C) {
      if (typeof w == "function" && typeof M != "function") {
        var W = M;
        M = w;
        var z = m;
        return function(ce) {
          var ue = this;
          ce === void 0 && (ce = W);
          for (var Ke = arguments.length, He = Array(Ke > 1 ? Ke - 1 : 0), ve = 1; ve < Ke; ve++)
            He[ve - 1] = arguments[ve];
          return z.produce(ce, function(ye) {
            var G;
            return (G = M).call.apply(G, [ue, ye].concat(He));
          });
        };
      }
      var j;
      if (typeof M != "function" && Bi(6), C !== void 0 && typeof C != "function" && Bi(7), rc(w)) {
        var Z = bx(m), H = Zw(m, w, void 0), $ = !0;
        try {
          j = M(H), $ = !1;
        } finally {
          $ ? Zg(Z) : Ww(Z);
        }
        return typeof Promise < "u" && j instanceof Promise ? j.then(function(ce) {
          return Mw(Z, C), Rw(ce, Z);
        }, function(ce) {
          throw Zg(Z), ce;
        }) : (Mw(Z, C), Rw(j, Z));
      }
      if (!w || typeof w != "object") {
        if ((j = M(w)) === void 0 && (j = w), j === Hb && (j = void 0), m.D && gE(j, !0), C) {
          var J = [], oe = [];
          tl("Patches").M(w, j, J, oe), C(J, oe);
        }
        return j;
      }
      Bi(21, w);
    }, this.produceWithPatches = function(w, M) {
      if (typeof w == "function")
        return function(j) {
          for (var Z = arguments.length, H = Array(Z > 1 ? Z - 1 : 0), $ = 1; $ < Z; $++)
            H[$ - 1] = arguments[$];
          return m.produceWithPatches(j, function(J) {
            return w.apply(void 0, [J].concat(H));
          });
        };
      var C, W, z = m.produce(w, M, function(j, Z) {
        C = j, W = Z;
      });
      return typeof Promise < "u" && z instanceof Promise ? z.then(function(j) {
        return [j, C, W];
      }) : [z, C, W];
    }, typeof (d == null ? void 0 : d.useProxies) == "boolean" && this.setUseProxies(d.useProxies), typeof (d == null ? void 0 : d.autoFreeze) == "boolean" && this.setAutoFreeze(d.autoFreeze);
  }
  var c = o.prototype;
  return c.createDraft = function(d) {
    rc(d) || Bi(8), mf(d) && (d = m2(d));
    var m = bx(this), w = Zw(this, d, void 0);
    return w[Rr].C = !0, Ww(m), w;
  }, c.finishDraft = function(d, m) {
    var w = d && d[Rr];
    process.env.NODE_ENV !== "production" && (w && w.C || Bi(9), w.I && Bi(10));
    var M = w.A;
    return Mw(M, m), Rw(void 0, M);
  }, c.setAutoFreeze = function(d) {
    this.D = d;
  }, c.setUseProxies = function(d) {
    d && !Ox && Bi(20), this.O = d;
  }, c.applyPatches = function(d, m) {
    var w;
    for (w = m.length - 1; w >= 0; w--) {
      var M = m[w];
      if (M.path.length === 0 && M.op === "replace") {
        d = M.value;
        break;
      }
    }
    w > -1 && (m = m.slice(w + 1));
    var C = tl("Patches").$;
    return mf(d) ? C(d, m) : this.produce(d, function(W) {
      return C(W, m);
    });
  }, o;
}(), es = new E2(), Yb = es.produce;
es.produceWithPatches.bind(es);
es.setAutoFreeze.bind(es);
es.setUseProxies.bind(es);
es.applyPatches.bind(es);
es.createDraft.bind(es);
es.finishDraft.bind(es);
var Vb = globalThis && globalThis.__extends || function() {
  var o = function(c, d) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(m, w) {
      m.__proto__ = w;
    } || function(m, w) {
      for (var M in w)
        Object.prototype.hasOwnProperty.call(w, M) && (m[M] = w[M]);
    }, o(c, d);
  };
  return function(c, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Class extends value " + String(d) + " is not a constructor or null");
    o(c, d);
    function m() {
      this.constructor = c;
    }
    c.prototype = d === null ? Object.create(d) : (m.prototype = d.prototype, new m());
  };
}(), T2 = globalThis && globalThis.__generator || function(o, c) {
  var d = { label: 0, sent: function() {
    if (M[0] & 1)
      throw M[1];
    return M[1];
  }, trys: [], ops: [] }, m, w, M, C;
  return C = { next: W(0), throw: W(1), return: W(2) }, typeof Symbol == "function" && (C[Symbol.iterator] = function() {
    return this;
  }), C;
  function W(j) {
    return function(Z) {
      return z([j, Z]);
    };
  }
  function z(j) {
    if (m)
      throw new TypeError("Generator is already executing.");
    for (; d; )
      try {
        if (m = 1, w && (M = j[0] & 2 ? w.return : j[0] ? w.throw || ((M = w.return) && M.call(w), 0) : w.next) && !(M = M.call(w, j[1])).done)
          return M;
        switch (w = 0, M && (j = [j[0] & 2, M.value]), j[0]) {
          case 0:
          case 1:
            M = j;
            break;
          case 4:
            return d.label++, { value: j[1], done: !1 };
          case 5:
            d.label++, w = j[1], j = [0];
            continue;
          case 7:
            j = d.ops.pop(), d.trys.pop();
            continue;
          default:
            if (M = d.trys, !(M = M.length > 0 && M[M.length - 1]) && (j[0] === 6 || j[0] === 2)) {
              d = 0;
              continue;
            }
            if (j[0] === 3 && (!M || j[1] > M[0] && j[1] < M[3])) {
              d.label = j[1];
              break;
            }
            if (j[0] === 6 && d.label < M[1]) {
              d.label = M[1], M = j;
              break;
            }
            if (M && d.label < M[2]) {
              d.label = M[2], d.ops.push(j);
              break;
            }
            M[2] && d.ops.pop(), d.trys.pop();
            continue;
        }
        j = c.call(o, d);
      } catch (Z) {
        j = [6, Z], w = 0;
      } finally {
        m = M = 0;
      }
    if (j[0] & 5)
      throw j[1];
    return { value: j[0] ? j[1] : void 0, done: !0 };
  }
}, ym = globalThis && globalThis.__spreadArray || function(o, c) {
  for (var d = 0, m = c.length, w = o.length; d < m; d++, w++)
    o[w] = c[d];
  return o;
}, C2 = Object.defineProperty, x2 = Object.defineProperties, b2 = Object.getOwnPropertyDescriptors, Nx = Object.getOwnPropertySymbols, M2 = Object.prototype.hasOwnProperty, R2 = Object.prototype.propertyIsEnumerable, Px = function(o, c, d) {
  return c in o ? C2(o, c, { enumerable: !0, configurable: !0, writable: !0, value: d }) : o[c] = d;
}, yd = function(o, c) {
  for (var d in c || (c = {}))
    M2.call(c, d) && Px(o, d, c[d]);
  if (Nx)
    for (var m = 0, w = Nx(c); m < w.length; m++) {
      var d = w[m];
      R2.call(c, d) && Px(o, d, c[d]);
    }
  return o;
}, Ow = function(o, c) {
  return x2(o, b2(c));
}, D2 = function(o, c, d) {
  return new Promise(function(m, w) {
    var M = function(z) {
      try {
        W(d.next(z));
      } catch (j) {
        w(j);
      }
    }, C = function(z) {
      try {
        W(d.throw(z));
      } catch (j) {
        w(j);
      }
    }, W = function(z) {
      return z.done ? m(z.value) : Promise.resolve(z.value).then(M, C);
    };
    W((d = d.apply(o, c)).next());
  });
};
function vf(o, c) {
  function d() {
    for (var m = [], w = 0; w < arguments.length; w++)
      m[w] = arguments[w];
    if (c) {
      var M = c.apply(void 0, m);
      if (!M)
        throw new Error("prepareAction did not return an object");
      return yd(yd({
        type: o,
        payload: M.payload
      }, "meta" in M && { meta: M.meta }), "error" in M && { error: M.error });
    }
    return { type: o, payload: m[0] };
  }
  return d.toString = function() {
    return "" + o;
  }, d.type = o, d.match = function(m) {
    return m.type === o;
  }, d;
}
(function(o) {
  Vb(c, o);
  function c() {
    for (var d = [], m = 0; m < arguments.length; m++)
      d[m] = arguments[m];
    var w = o.apply(this, d) || this;
    return Object.setPrototypeOf(w, c.prototype), w;
  }
  return Object.defineProperty(c, Symbol.species, {
    get: function() {
      return c;
    },
    enumerable: !1,
    configurable: !0
  }), c.prototype.concat = function() {
    for (var d = [], m = 0; m < arguments.length; m++)
      d[m] = arguments[m];
    return o.prototype.concat.apply(this, d);
  }, c.prototype.prepend = function() {
    for (var d = [], m = 0; m < arguments.length; m++)
      d[m] = arguments[m];
    return d.length === 1 && Array.isArray(d[0]) ? new (c.bind.apply(c, ym([void 0], d[0].concat(this))))() : new (c.bind.apply(c, ym([void 0], d.concat(this))))();
  }, c;
})(Array);
(function(o) {
  Vb(c, o);
  function c() {
    for (var d = [], m = 0; m < arguments.length; m++)
      d[m] = arguments[m];
    var w = o.apply(this, d) || this;
    return Object.setPrototypeOf(w, c.prototype), w;
  }
  return Object.defineProperty(c, Symbol.species, {
    get: function() {
      return c;
    },
    enumerable: !1,
    configurable: !0
  }), c.prototype.concat = function() {
    for (var d = [], m = 0; m < arguments.length; m++)
      d[m] = arguments[m];
    return o.prototype.concat.apply(this, d);
  }, c.prototype.prepend = function() {
    for (var d = [], m = 0; m < arguments.length; m++)
      d[m] = arguments[m];
    return d.length === 1 && Array.isArray(d[0]) ? new (c.bind.apply(c, ym([void 0], d[0].concat(this))))() : new (c.bind.apply(c, ym([void 0], d.concat(this))))();
  }, c;
})(Array);
function Gw(o) {
  return rc(o) ? Yb(o, function() {
  }) : o;
}
process.env.NODE_ENV;
process.env.NODE_ENV;
function Wb(o) {
  var c = {}, d = [], m, w = {
    addCase: function(M, C) {
      if (process.env.NODE_ENV !== "production") {
        if (d.length > 0)
          throw new Error("`builder.addCase` should only be called before calling `builder.addMatcher`");
        if (m)
          throw new Error("`builder.addCase` should only be called before calling `builder.addDefaultCase`");
      }
      var W = typeof M == "string" ? M : M.type;
      if (!W)
        throw new Error("`builder.addCase` cannot be called with an empty action type");
      if (W in c)
        throw new Error("`builder.addCase` cannot be called with two reducers for the same action type");
      return c[W] = C, w;
    },
    addMatcher: function(M, C) {
      if (process.env.NODE_ENV !== "production" && m)
        throw new Error("`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
      return d.push({ matcher: M, reducer: C }), w;
    },
    addDefaultCase: function(M) {
      if (process.env.NODE_ENV !== "production" && m)
        throw new Error("`builder.addDefaultCase` can only be called once");
      return m = M, w;
    }
  };
  return o(w), [c, d, m];
}
function k2(o) {
  return typeof o == "function";
}
var Ax = !1;
function O2(o, c, d, m) {
  d === void 0 && (d = []), process.env.NODE_ENV !== "production" && typeof c == "object" && (Ax || (Ax = !0, console.warn("The object notation for `createReducer` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer")));
  var w = typeof c == "function" ? Wb(c) : [c, d, m], M = w[0], C = w[1], W = w[2], z;
  if (k2(o))
    z = function() {
      return Gw(o());
    };
  else {
    var j = Gw(o);
    z = function() {
      return j;
    };
  }
  function Z(H, $) {
    H === void 0 && (H = z());
    var J = ym([
      M[$.type]
    ], C.filter(function(oe) {
      var ce = oe.matcher;
      return ce($);
    }).map(function(oe) {
      var ce = oe.reducer;
      return ce;
    }));
    return J.filter(function(oe) {
      return !!oe;
    }).length === 0 && (J = [W]), J.reduce(function(oe, ce) {
      if (ce)
        if (mf(oe)) {
          var ue = oe, Ke = ce(ue, $);
          return Ke === void 0 ? oe : Ke;
        } else {
          if (rc(oe))
            return Yb(oe, function(He) {
              return ce(He, $);
            });
          var Ke = ce(oe, $);
          if (Ke === void 0) {
            if (oe === null)
              return oe;
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return Ke;
        }
      return oe;
    }, H);
  }
  return Z.getInitialState = z, Z;
}
var zx = !1;
function L2(o, c) {
  return o + "/" + c;
}
function Zb(o) {
  var c = o.name;
  if (!c)
    throw new Error("`name` is a required option for createSlice");
  typeof process < "u" && process.env.NODE_ENV === "development" && o.initialState === void 0 && console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
  var d = typeof o.initialState == "function" ? o.initialState : Gw(o.initialState), m = o.reducers || {}, w = Object.keys(m), M = {}, C = {}, W = {};
  w.forEach(function(Z) {
    var H = m[Z], $ = L2(c, Z), J, oe;
    "reducer" in H ? (J = H.reducer, oe = H.prepare) : J = H, M[Z] = J, C[$] = J, W[Z] = oe ? vf($, oe) : vf($);
  });
  function z() {
    process.env.NODE_ENV !== "production" && typeof o.extraReducers == "object" && (zx || (zx = !0, console.warn("The object notation for `createSlice.extraReducers` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice")));
    var Z = typeof o.extraReducers == "function" ? Wb(o.extraReducers) : [o.extraReducers], H = Z[0], $ = H === void 0 ? {} : H, J = Z[1], oe = J === void 0 ? [] : J, ce = Z[2], ue = ce === void 0 ? void 0 : ce, Ke = yd(yd({}, $), C);
    return O2(d, function(He) {
      for (var ve in Ke)
        He.addCase(ve, Ke[ve]);
      for (var ye = 0, G = oe; ye < G.length; ye++) {
        var Me = G[ye];
        He.addMatcher(Me.matcher, Me.reducer);
      }
      ue && He.addDefaultCase(ue);
    });
  }
  var j;
  return {
    name: c,
    reducer: function(Z, H) {
      return j || (j = z()), j(Z, H);
    },
    actions: W,
    caseReducers: M,
    getInitialState: function() {
      return j || (j = z()), j.getInitialState();
    }
  };
}
var N2 = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW", P2 = function(o) {
  o === void 0 && (o = 21);
  for (var c = "", d = o; d--; )
    c += N2[Math.random() * 64 | 0];
  return c;
}, A2 = [
  "name",
  "message",
  "stack",
  "code"
], Lw = (
  /** @class */
  function() {
    function o(c, d) {
      this.payload = c, this.meta = d;
    }
    return o;
  }()
), Ux = (
  /** @class */
  function() {
    function o(c, d) {
      this.payload = c, this.meta = d;
    }
    return o;
  }()
), z2 = function(o) {
  if (typeof o == "object" && o !== null) {
    for (var c = {}, d = 0, m = A2; d < m.length; d++) {
      var w = m[d];
      typeof o[w] == "string" && (c[w] = o[w]);
    }
    return c;
  }
  return { message: String(o) };
};
(function() {
  function o(c, d, m) {
    var w = vf(c + "/fulfilled", function(Z, H, $, J) {
      return {
        payload: Z,
        meta: Ow(yd({}, J || {}), {
          arg: $,
          requestId: H,
          requestStatus: "fulfilled"
        })
      };
    }), M = vf(c + "/pending", function(Z, H, $) {
      return {
        payload: void 0,
        meta: Ow(yd({}, $ || {}), {
          arg: H,
          requestId: Z,
          requestStatus: "pending"
        })
      };
    }), C = vf(c + "/rejected", function(Z, H, $, J, oe) {
      return {
        payload: J,
        error: (m && m.serializeError || z2)(Z || "Rejected"),
        meta: Ow(yd({}, oe || {}), {
          arg: $,
          requestId: H,
          rejectedWithValue: !!J,
          requestStatus: "rejected",
          aborted: (Z == null ? void 0 : Z.name) === "AbortError",
          condition: (Z == null ? void 0 : Z.name) === "ConditionError"
        })
      };
    }), W = !1, z = typeof AbortController < "u" ? AbortController : (
      /** @class */
      function() {
        function Z() {
          this.signal = {
            aborted: !1,
            addEventListener: function() {
            },
            dispatchEvent: function() {
              return !1;
            },
            onabort: function() {
            },
            removeEventListener: function() {
            },
            reason: void 0,
            throwIfAborted: function() {
            }
          };
        }
        return Z.prototype.abort = function() {
          process.env.NODE_ENV !== "production" && (W || (W = !0, console.info("This platform does not implement AbortController. \nIf you want to use the AbortController to react to `abort` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.")));
        }, Z;
      }()
    );
    function j(Z) {
      return function(H, $, J) {
        var oe = m != null && m.idGenerator ? m.idGenerator(Z) : P2(), ce = new z(), ue;
        function Ke(ve) {
          ue = ve, ce.abort();
        }
        var He = function() {
          return D2(this, null, function() {
            var ve, ye, G, Me, ze, kt, It;
            return T2(this, function(Nt) {
              switch (Nt.label) {
                case 0:
                  return Nt.trys.push([0, 4, , 5]), Me = (ve = m == null ? void 0 : m.condition) == null ? void 0 : ve.call(m, Z, { getState: $, extra: J }), I2(Me) ? [4, Me] : [3, 2];
                case 1:
                  Me = Nt.sent(), Nt.label = 2;
                case 2:
                  if (Me === !1 || ce.signal.aborted)
                    throw {
                      name: "ConditionError",
                      message: "Aborted due to condition callback returning false."
                    };
                  return ze = new Promise(function(Xe, Mt) {
                    return ce.signal.addEventListener("abort", function() {
                      return Mt({
                        name: "AbortError",
                        message: ue || "Aborted"
                      });
                    });
                  }), H(M(oe, Z, (ye = m == null ? void 0 : m.getPendingMeta) == null ? void 0 : ye.call(m, { requestId: oe, arg: Z }, { getState: $, extra: J }))), [4, Promise.race([
                    ze,
                    Promise.resolve(d(Z, {
                      dispatch: H,
                      getState: $,
                      extra: J,
                      requestId: oe,
                      signal: ce.signal,
                      abort: Ke,
                      rejectWithValue: function(Xe, Mt) {
                        return new Lw(Xe, Mt);
                      },
                      fulfillWithValue: function(Xe, Mt) {
                        return new Ux(Xe, Mt);
                      }
                    })).then(function(Xe) {
                      if (Xe instanceof Lw)
                        throw Xe;
                      return Xe instanceof Ux ? w(Xe.payload, oe, Z, Xe.meta) : w(Xe, oe, Z);
                    })
                  ])];
                case 3:
                  return G = Nt.sent(), [3, 5];
                case 4:
                  return kt = Nt.sent(), G = kt instanceof Lw ? C(null, oe, Z, kt.payload, kt.meta) : C(kt, oe, Z), [3, 5];
                case 5:
                  return It = m && !m.dispatchConditionRejection && C.match(G) && G.meta.condition, It || H(G), [2, G];
              }
            });
          });
        }();
        return Object.assign(He, {
          abort: Ke,
          requestId: oe,
          arg: Z,
          unwrap: function() {
            return He.then(U2);
          }
        });
      };
    }
    return Object.assign(j, {
      pending: M,
      rejected: C,
      fulfilled: w,
      typePrefix: c
    });
  }
  return o.withTypes = function() {
    return o;
  }, o;
})();
function U2(o) {
  if (o.meta && o.meta.rejectedWithValue)
    throw o.payload;
  if (o.error)
    throw o.error;
  return o.payload;
}
function I2(o) {
  return o !== null && typeof o == "object" && typeof o.then == "function";
}
var wE = "listenerMiddleware";
vf(wE + "/add");
vf(wE + "/removeAll");
vf(wE + "/remove");
var Ix;
typeof queueMicrotask == "function" && queueMicrotask.bind(typeof window < "u" ? window : typeof global < "u" ? global : globalThis);
y2();
Zb({
  name: "auth",
  initialState: { accessToken: null, id: null, email: null },
  reducers: {
    setCredentials: (o, { payload: { accessToken: c, id: d, email: m } }) => {
      o.accessToken = c, o.id = d, o.email = m;
    }
  }
});
const j2 = {
  listEvents: {
    distance: 20,
    sports: [],
    startTime: Ye().toISOString(),
    endTime: Ye().add(1, "year").add(1, "month").toISOString()
  },
  mapEvents: {
    distance: 20,
    sports: [],
    startTime: Ye().toISOString(),
    endTime: Ye().add(1, "year").add(1, "month").toISOString()
  },
  sportParner: {
    distance: 20,
    sports: [],
    level: "",
    gender: ""
  }
};
Zb({
  name: "filter",
  initialState: j2,
  reducers: {
    changeDistance: (o, c) => {
      o[c.payload.type].distance = c.payload.value;
    },
    addSports: (o, c) => {
      o[c.payload.type].sports.push(c.payload.value);
    },
    removeSport: (o, c) => {
      o[c.payload.type].sports = o[c.payload.type].sports.filter((d) => d !== c.payload.value);
    },
    setStartTime: (o, c) => {
      o[c.payload.type].startTime = c.payload.value;
    },
    setEndTime: (o, c) => {
      o[c.payload.type].endTime = c.payload.value;
    },
    changeGender: (o, c) => {
      o[c.payload.type].gender = c.payload.value;
    },
    changeLevel: (o, c) => {
      o[c.payload.type].level = c.payload.value;
    }
  }
});
function F2(o) {
  return r2({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M256 288c79.5 0 144-64.5 144-144S335.5 0 256 0 112 64.5 112 144s64.5 144 144 144zm128 32h-55.1c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16H128C57.3 320 0 377.3 0 448v16c0 26.5 21.5 48 48 48h416c26.5 0 48-21.5 48-48v-16c0-70.7-57.3-128-128-128z" } }] })(o);
}
function $b() {
  let o = 0, c, d, m = "";
  for (; o < arguments.length; )
    (c = arguments[o++]) && (d = Gb(c)) && (m && (m += " "), m += d);
  return m;
}
function Gb(o) {
  if (typeof o == "string")
    return o;
  let c, d = "";
  for (let m = 0; m < o.length; m++)
    o[m] && (c = Gb(o[m])) && (d && (d += " "), d += c);
  return d;
}
function Qb(o) {
  var c, d, m = "";
  if (typeof o == "string" || typeof o == "number")
    m += o;
  else if (typeof o == "object")
    if (Array.isArray(o))
      for (c = 0; c < o.length; c++)
        o[c] && (d = Qb(o[c])) && (m && (m += " "), m += d);
    else
      for (c in o)
        o[c] && (m && (m += " "), m += c);
  return m;
}
function qb() {
  for (var o, c, d = 0, m = ""; d < arguments.length; )
    (o = arguments[d++]) && (c = Qb(o)) && (m && (m += " "), m += c);
  return m;
}
const Kb = ({ imgUrl: o, rounded: c = !0, ...d }) => /* @__PURE__ */ React.createElement(
  "div",
  {
    className: $b(
      "flex flex-col justify-center items-center bg-white border flex-shrink ",
      qb(c && "rounded-full overflow-hidden"),
      "w-full h-full"
    ),
    ...d
  },
  o ? /* @__PURE__ */ React.createElement("img", { src: o, alt: "", className: "cursor-pointer" }) : /* @__PURE__ */ React.createElement(F2, { className: "w-1/2 h-1/2", style: { color: "#303030" } })
), H2 = ({ sports: o }) => /* @__PURE__ */ Et.createElement("div", { className: "flex  bg-accent6 rounded-full items-center px-4 py-1" }, o.map((c, d) => /* @__PURE__ */ Et.createElement("div", { className: "flex items-center gap-x-2" }, d !== 0 && /* @__PURE__ */ Et.createElement("div", { className: "bg-black w-2 h-2 rounded-full ml-2" }), /* @__PURE__ */ Et.createElement("h3", { className: "text-main3" }, c)))), B2 = () => /* @__PURE__ */ Et.createElement("div", { className: "bg-main3 w-full h-[280px] flex" }, /* @__PURE__ */ Et.createElement(Kb, null), /* @__PURE__ */ Et.createElement("div", { className: "flex flex-col" }, /* @__PURE__ */ Et.createElement("div", { className: "flex " }, /* @__PURE__ */ Et.createElement("h1", { className: "text-main3 text-2xl font-bold" }, "John Doe"), /* @__PURE__ */ Et.createElement(H2, { sports: ["Soccer", "Basketball", "Tennis"] }), /* @__PURE__ */ Et.createElement("div", { className: "bg-primary p-5 rounded-full" }, /* @__PURE__ */ Et.createElement("h2", null, "PRO"))), /* @__PURE__ */ Et.createElement("p", null, "Address"), /* @__PURE__ */ Et.createElement("div", { className: "flex" }, /* @__PURE__ */ Et.createElement("p", null, "Male"), /* @__PURE__ */ Et.createElement("p", null, "Age")), /* @__PURE__ */ Et.createElement("p", null, "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book."))), Y2 = ({ events: o }) => {
  const c = (d) => /* @__PURE__ */ Et.createElement(
    "div",
    {
      className: "bg-white md:h-[52px] h-[40px] w-full flex flex-col rounded-lg px-3 p-1",
      key: d.id
    },
    /* @__PURE__ */ Et.createElement("h4", { className: "font-semibold tracking-wide" }, d.title),
    /* @__PURE__ */ Et.createElement("p", { className: "text-accent4 text-sm" }, d.startTime)
  );
  return /* @__PURE__ */ Et.createElement(
    "div",
    {
      className: $b(
        "bg-accent6 rounded-2xl md:w-[175px] w-[150px]  md:h-[165px] h-[130px]",
        " px-2 pt-2 overflow-y-auto flex flex-col gap-y-2 items-center ",
        qb(o.length === 0 && "justify-center")
      )
    },
    o.length === 0 ? /* @__PURE__ */ Et.createElement("h4", { className: "w-20 align-center" }, "No Lessons on this day") : o.map((d) => c(d))
  );
}, V2 = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], W2 = {
  id: "1",
  title: "Math",
  startTime: "12:00"
};
function Z2() {
  const o = () => /* @__PURE__ */ Et.createElement("div", { className: "flex gap-x-2" }, V2.map((c, d) => /* @__PURE__ */ Et.createElement("div", { className: "flex flex-col overflow-x-auto " }, /* @__PURE__ */ Et.createElement("h4", { className: "font-semibold truncate" }, c), /* @__PURE__ */ Et.createElement(Y2, { key: c + d, events: [W2] }))));
  return /* @__PURE__ */ Et.createElement("div", { className: "flex flex-col" }, /* @__PURE__ */ Et.createElement("div", { className: "flex justify-between" }, /* @__PURE__ */ Et.createElement("h2", null, "Available lesson"), /* @__PURE__ */ Et.createElement("h3", { className: "mr-3" }, "Week 1 (1-7 June)")), /* @__PURE__ */ Et.createElement("div", { className: "flex" }, o()));
}
const $2 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjYiIGhlaWdodD0iNTgiIHZpZXdCb3g9IjAgMCA2NiA1OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTM0LjMzMjQgNTYuNTg1NEwzMi40NTc2IDU3LjA4NjVDMzEuMDE5IDU3LjQ2OTEgMjkuNTAxIDU2LjkxNTQgMjguNjU2NCA1NS43MDA1TDIwLjYzMTIgNDQuMjU1N0wzNC4xMjIgNDUuNjk0M0wzNi42ODI2IDUxLjc5MzFDMzcuNTAwNCA1My43NzMxIDM2LjQwNTIgNTYuMDMwNSAzNC4zMzI0IDU2LjU4NTRaTTguMjg5MjEgMjAuNDI5N0wzLjkzMzIxIDIxLjYwNDNDMS4xMDg2MSAyMi4zNjk1IC0wLjU4MTYwOCAyNS4yNzM1IDAuMTg0NjExIDI4LjA5OTFMMi45NDMyMSAzOC4zOTUxQzMuNjk2MDIgNDEuMjE5NyA2LjYwMDAyIDQyLjg5NjUgOS40MzgwMyA0Mi4xMzAzTDEzLjc5NCA0MC45NjkxTDguMjg5MjEgMjAuNDI5N1pNNTEuNjk4NyA0MS4xNzAyTDQxLjAyMDEgMS4zMTEzM0M0MC42OTk0IDAuMTExOTg2IDM5LjI3NTIgLTAuMzkwMjMzIDM4LjI3MjggMC4zMzk4OTJMMTIuMTEyMSAxOS40MTE4TDE3LjYxMzggMzkuOTQ0MUw0OS44MDUzIDQzLjM4MjJDNTEuMDM4NyA0My41MTQyIDUyLjAyMDQgNDIuMzY2NSA1MS42OTg3IDQxLjE3MDJaTTUzLjMxODggOC4xNjM5OUM1My4wMTc3IDguMTYzOTkgNTIuNzE1NSA4LjA4NzY4IDUyLjQzNzEgNy45MjY4MUM1MS41OTE0IDcuNDM5MDIgNTEuMzAyNyA2LjM1ODI3IDUxLjc5MDUgNS41MTM2OEw1NC4zNDQ5IDEuMDkwNjRDNTQuODMxNiAwLjI0Mzk4NiA1NS45MTU1IC0wLjA0NDc2NDQgNTYuNzU4IDAuNDQ0MDQ5QzU3LjYwMzYgMC45MzE4MyA1Ny44OTI0IDIuMDEyNTggNTcuNDA0NiAyLjg1NzE4TDU0Ljg1MDIgNy4yODAyMUM1NC41MjIzIDcuODQ3NCA1My45MjgzIDguMTYzOTkgNTMuMzE4OCA4LjE2Mzk5Wk01NS44NDEyIDIwLjQ2NThDNTUuMDYwNiAyMC40NjU4IDU0LjM0NjkgMTkuOTQ1IDU0LjEzNTUgMTkuMTU2MUM1My44ODM5IDE4LjIxMzUgNTQuNDQyOCAxNy4yNDUyIDU1LjM4NTQgMTYuOTkxNUw2MC4zMTg5IDE1LjY3MDVDNjEuMjY2NiAxNS40MTg4IDYyLjIzMDkgMTUuOTc1NyA2Mi40ODQ1IDE2LjkyMDNDNjIuNzM2MiAxNy44NjI5IDYyLjE3NzIgMTguODMxMyA2MS4yMzQ3IDE5LjA4NDlMNTYuMzAxMiAyMC40MDZDNTYuMTQ1NCAyMC40NDcyIDU1Ljk5MjggMjAuNDY1OCA1NS44NDEyIDIwLjQ2NThaTTY0LjIzMTUgMzQuOTM1M0M2My45MzA0IDM0LjkzNTMgNjMuNjI4MiAzNC44NTkgNjMuMzQ5OCAzNC42OTgxTDU4LjkyNjcgMzIuMTQzN0M1OC4wODExIDMxLjY1NTkgNTcuNzkyNCAzMC41NzUxIDU4LjI4MDEgMjkuNzMwNUM1OC43Njc5IDI4Ljg4MzkgNTkuODUwNyAyOC41OTUxIDYwLjY5MzMgMjkuMDg0TDY1LjExNjMgMzEuNjM4NEM2NS45NjE5IDMyLjEyNjEgNjYuMjUwNyAzMy4yMDY5IDY1Ljc2MjkgMzQuMDUxNUM2NS40MzYgMzQuNjE4NyA2NC44NDEgMzQuOTM1MyA2NC4yMzE1IDM0LjkzNTNaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K", G2 = () => /* @__PURE__ */ Et.createElement("div", { className: "flex p-2 bg-white gap-x-2 shadow-xl w-full" }, /* @__PURE__ */ Et.createElement("div", { className: "md:w-24 w-12 md:h-24 h-12  bg-primary p-3  rounded-lg flex items-center justify-center" }, /* @__PURE__ */ Et.createElement("img", { src: $2 })), /* @__PURE__ */ Et.createElement("div", { className: "flex flex-col" }, /* @__PURE__ */ Et.createElement("h3", null, "Title"), /* @__PURE__ */ Et.createElement("p", null, "12.10.2023"), /* @__PURE__ */ Et.createElement("p", null, "Content"))), Q2 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTcuMDQyNTcgMC44Njc0TDguMTAwMTQgMi45OTY3MkM4LjI0MjY1IDMuMjkxMiA4LjYyNTE4IDMuNTcwNTggOC45NDc3IDMuNjMwOTlMMTAuODYwMyAzLjk0ODEyQzEyLjA4MjkgNC4xNTE5OSAxMi4zNjc5IDUuMDQyOTkgMTEuNDkwNCA1LjkzMzk4TDkuOTk3NzcgNy40MzY1OUM5Ljc1MDI2IDcuNjg1NzcgOS42MDc3NSA4LjE3NjU3IDkuNjkwMjUgOC41MzE0NkwxMC4xMTc4IDEwLjM4ODlDMTAuNDU1MyAxMS44NTM4IDkuNjc1MjUgMTIuNDI3NyA4LjM5MjY2IDExLjY1NzVMNi42MDAwNCAxMC41ODUzQzYuMjc3NTIgMTAuMzg5IDUuNzM3NDggMTAuMzg5IDUuNDE0OTYgMTAuNTg1M0wzLjYyMjM0IDExLjY1NzVDMi4zMzk3NSAxMi40MjAxIDEuNTU5NyAxMS44NTM4IDEuODk3MjIgMTAuMzg4OUwyLjMyNDc1IDguNTMxNDZDMi4zOTIyNSA4LjE2OTAyIDIuMjQ5NzQgNy42NzgyMiAyLjAwMjIzIDcuNDI5MDRMMC41MDk2MjUgNS45MjY0M0MtMC4zNjc5MzUgNS4wNDI5OSAtMC4wODI5MTUzIDQuMTUxOTkgMS4xMzk2NyAzLjk0MDU3TDMuMDUyMyAzLjYyMzQ0QzMuMzc0ODIgMy41NzA1OCAzLjc1NzM1IDMuMjgzNjUgMy44OTk4NiAyLjk4OTE3TDQuOTU3NDMgMC44NTk4NDlDNS41MzQ5NyAtMC4yODc4NzIgNi40NjUwMyAtMC4yODc4NzIgNy4wNDI1NyAwLjg2NzRaIiBmaWxsPSIjNDhCM0VGIi8+Cjwvc3ZnPgo=", q2 = ({ name: o, imgUrl: c, rating: d, review: m, date: w }) => /* @__PURE__ */ Et.createElement("div", { className: "flex flex-col" }, /* @__PURE__ */ Et.createElement("div", { className: "flex flex-row md:h-[50px] gap-x-2" }, /* @__PURE__ */ Et.createElement("div", { className: "md:w-[50px] w-[35px]" }, /* @__PURE__ */ Et.createElement(Kb, { imgUrl: c, rounded: !0 })), /* @__PURE__ */ Et.createElement("div", { className: "flex flex-col" }, /* @__PURE__ */ Et.createElement("h4", null, o), /* @__PURE__ */ Et.createElement("p", null, w)), /* @__PURE__ */ Et.createElement("div", { className: "flex flex-row flex-1 justify-end self-start items-center mr-3" }, /* @__PURE__ */ Et.createElement("img", { className: "h-3", src: Q2, alt: "review star" }), /* @__PURE__ */ Et.createElement("p", null, d))), /* @__PURE__ */ Et.createElement("p", null, m)), eU = () => /* @__PURE__ */ uf.jsxs("div", { className: "flex flex-col", children: [
  /* @__PURE__ */ uf.jsx(B2, {}),
  /* @__PURE__ */ uf.jsx(Z2, {}),
  /* @__PURE__ */ uf.jsxs("div", { className: "flex", children: [
    /* @__PURE__ */ uf.jsx("div", { children: /* @__PURE__ */ uf.jsx(G2, {}) }),
    /* @__PURE__ */ uf.jsx("div", { children: /* @__PURE__ */ uf.jsx(
      q2,
      {
        name: "Test name",
        rating: 5,
        review: "Test review to wirte about hte person",
        date: "2021-10-10"
      }
    ) })
  ] })
] });
export {
  eU as Profile
};
